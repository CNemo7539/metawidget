<?xml version="1.0" encoding="UTF-8"?>
<book lang="en">
	<title>Metawidget Reference Documentation</title>

	<bookinfo>
		<productname>Metawidget</productname>
		<releaseinfo>V 0.7</releaseinfo>

		<mediaobject>
			<imageobject>
				<imagedata fileref="images/logo.gif" />
			</imageobject>
		</mediaobject>
	</bookinfo>

	<toc />

	<preface id="preface">
		<title>Preface</title>

		<para>
			Metawidget is an object/user interface mapping tool for Java
			environments. The term object/user interface mapping (OIM) refers to
			the technique of inspecting objects, at runtime, and creating
			User Interface (UI) widgets.
		</para>

		<para>
			As much as possible, Metawidget does this without introducing
			new technologies. As shown in <xref linkend="preface-diagram"/>,
			Metawidget inspects an application's
			<emphasis>existing</emphasis> back-end architecture (such as JavaBeans, annotations,
			XML configuration files) and creates widgets native to its
			<emphasis>existing</emphasis> front-end framework (such as Swing, Java Server Faces, Struts or Android).
		</para>
	
		<figure id="preface-diagram">
			<title>Metawidget inspects existing back-ends and creates widgets native to existing front-ends</title>			
			<screenshot>
				<graphic fileref="../shared/images/overview.png"/>
			</screenshot>
		</figure>				

		<para>
			Building great UIs is both art and science. Metawidget
			does not attempt to address the <emphasis>art</emphasis>, it only automates the
			<emphasis>science</emphasis>. That is to say, it does not overlap with those areas of
			UI design involving creativity and subjectivity - its goal is
			only to ease the creation of areas that are already rigidly
			defined. Typically, this means those areas that display data and
			those that collect data - these tend to be both commonplace and
			consistent (indeed, consistency is a desirable trait) so there
			is good opportunity for automation.
		</para>
		
		<tip>
			<title>Note</title>
			This Reference Documentation is included in the distribution as a PDF, a single HTML page or as multiple
			HTML pages, depending on your reading preference.
		</tip>

	</preface>
		
	<preface id="preface-supported-technologies">
		<title>Supported Technologies</title>
		
		<para>
			A primary goal of Metawidget is to work with your <emphasis>existing</emphasis>
			front-end and back-end architecture. Out of the box, Metawidget supports a broad range of both
			front-end and back-end technologies, and makes it easy to add your own. 
		</para>
		
		<para>
			Metawidget comes with a native UI component for each supported front-end.
			This support includes: Android (for mobile phones), Google Web Toolkit, Java Server
			Faces (including extensions such as Facelets and JBoss RichFaces), 'plain' Java Server Pages,
			Spring Web MVC, Struts and Swing (including extensions such as Beans Binding, JGoodies
			and MigLayout).
		</para>
		
		<para>
			Metawidget can read business object information from any combination of supported
			back-end technologies. This support includes: annotations, Commons
			JEXL, Commons Validator, Groovy, Hibernate, Hibernate Validator, JavaBeans, Java Persistence
			Architecture (JPA), Javassist, JBoss jBPM, Scala and the Swing AppFramework. 
		</para>
		
		<para>
			Note it is <emphasis>not</emphasis> a goal of Metawidget that all widgets look the same on
			every front-end framework, or that all back-end technologies conform to some 'lowest common
			denominator': every technology has different features, and Metawidget takes advantage of this.
		</para>
		
		<para>
			The next chapter presents a tutorial covering using Metawidget with a variety of front-ends and
			back-ends. Chapter 2 then follows with a more in-depth architectual overview. Chapters 3 and
			4 explore each supported front-end and back-end technology in detail. Finally, chapters
			5 and 6 offer general advice and performance tips.
		</para>
		
	</preface>
	
	<chapter id="chapter-introduction">
		<title>Introduction to Metawidget</title>
		
		<section id="section-introduction-preface">
			<title>Preface</title>

			<para>
				This chapter is an introductory tutorial for new users of
				Metawidget. Before you begin, you need to download at least the binary distribution, and
				preferrably the source code distribution as well, from <uri>http://www.metawidget.org/download.html</uri>.
			</para>
			
		</section>
		
		<section id="section-introduction-part1">
			<title>Part 1 - The First Metawidget Application</title>

			<section id="section-introduction-part1-preface">
				<title>Preface</title>
	
				<para>
					Part 1 starts with a simple Swing application and develops it in easy to understand steps.
					Metawidget supports many UI frameworks, not just Swing, but we start with Swing because it
					ships with Java SE and requires minimal setup.
				</para>
	
				<para>
					This tutorial should take around 20 minutes. We recommend you use your preferred Java
					development environment. If you use an Integrated Development Environment (IDE), you will
					need to start a new Java project and add <filename>metawidget.jar</filename> to it. Otherwise,
					you just need to ensure <filename>metawidget.jar</filename> is on your classpath.					
				</para>
				
			</section>
			
			<section id="section-introduction-part1-object">
				<title>The Object</title>
				
				<para>
					Metawidget is an object/user interface mapping tool (OIM), so first we need an object to map from - the <emphasis>O</emphasis> in OIM:
				</para>
	
	<programlisting language="java">package com.myapp;
	
public class Person {
	public String name;
	public int age;
	public boolean retired;
}</programlisting>
					
				<para>		
					Note this tutorial uses public member variables for brevity. The
					recommended design is to use JavaBean property getter and setter methods.
					Metawidget supports both approaches.
				</para>
				
			</section>
					
			<section id="section-introduction-part1-interface">
				<title>The Interface</title>
				
				<para>
					Next we need a User Interface framework - the <emphasis>I</emphasis> in OIM:
				</para>
								
	<programlisting language="java">package com.myapp;
	
import javax.swing.*;
import org.metawidget.inspector.propertytype.*;
import org.metawidget.swing.*;

public class Main {
	public static void main( String[] args ) {
		Person person = new Person();
	
		SwingMetawidget metawidget = new SwingMetawidget();
		metawidget.setInspector( new PropertyTypeInspector() );
		metawidget.setToInspect( person );
	
		JFrame frame = new JFrame( "Metawidget Tutorial" );
		frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
		frame.getContentPane().add( metawidget );
		frame.setSize( 400, 220 );
		frame.setVisible( true );
	}
}</programlisting>
	
				<para>		
	 				Note many IDEs include visual UI builders
					for dragging and dropping widgets. Metawidget integrates
					with these tools, and Metawidget widgets can be dragged and
					dropped like any other. As we shall see, however, Metawidget
					widgets automatically fill themselves with child widgets at runtime,
					saving significant development time.
				</para>
				
			</section>
	
			<section id="section-introduction-part1-output">
				<title>The Output</title>
				
				<para>
					Run the code. You should see the screen in <xref linkend="section-introduction-part1-output-screenshot"/>.
				</para>
				
				<figure id="section-introduction-part1-output-screenshot">
					<title>SwingMetawidget rendering of Person class</title>			
					<screenshot>
						<graphic fileref="../shared/images/swing-tutorial1.jpg" width="100mm"/>
					</screenshot>
				</figure>				
				
				<para>
					The <classname>SwingMetawidget</classname> has automatically populated itself with child widgets at
					runtime. It has chosen <classname>JSpinner</classname>, <classname>JTextField</classname> and <classname>JCheckBox</classname>
					widgets based on the types of the properties of the <classname>Person</classname> class. This is the First Goal Of Metawidget:
				</para>
				
			    <important>
			    	<title>First Goal Of Metawidget</title>
					Metawidget creates UI widgets by inspecting existing back-end architectures   
				</important>

				<para>
					By default, <classname>SwingMetawidget</classname> has laid out the <classname>JComponents</classname> using <classname>java.awt.GridBagLayout</classname>.
					Try resizing the window, and the <classname>JComponents</classname> will resize with it. If you've ever tried using <classname>GridBagLayout</classname> yourself, either
					through code or a visual UI builder, you'll know how fiddly it can be. Having Metawidget do it for you is a real time-saver.  
				</para>
				
				<para>
					Clearly this is not a complete UI. There are no Save or Cancel buttons, for example,
					and the <classname>JComponents</classname> appear uncomfortably tight to the left, top and right edges of the <classname>JFrame</classname>. This is
					explained by the Second Goal Of Metawidget:
				</para>
				
			    <important>
			    	<title>Second Goal Of Metawidget</title>
					Metawidget does not try to 'own' the entire UI - it focusses on
					creating native sub-widgets for slotting into existing UIs  
			    </important>
				
				<para>
					You slot Metawidget alongside your standard UI components, often combining several Metawidgets on the same screen. We'll
					see how this works later.
				</para>
				
			</section>
				
			<section id="section-introduction-part1-finetune">
				<title>Fine-Tuning The Output</title>
				
				<para>
					At the moment, the order of fields in our UI is alphabetical - it does not match
					the order they are defined in the <classname>Person</classname> class. <classname>PropertyTypeInspector</classname> sorts fields
					alphabetically, because the Java Language Specification
					does not retain field ordering information within class files.
				</para>
				
				<para>
					To describe a different ordering, Metawidget needs a way to capture additional information.
					There are several ways Metawidget can do this, but the
					simplest for now is to use the built-in Metawidget annotation <classname>@UiComesAfter</classname>.
				</para>
				
				<tip>
					<title>Note</title>
					The following code uses annotations, so you'll need Java SE 5. Metawidget itself can run
					on J2SE 1.4, but you'll need to capture the additional information from a different source
					(see <xref linkend="section-introduction-part1-xmlinspector"/>)
				</tip>
								
				<para>
					Annotate the <classname>Person</classname> class as shown below (lines to add are shown in bold):
				</para>
				
				<programlisting language="java">package com.myapp;

<emphasis role="bold">import org.metawidget.inspector.annotation.*;</emphasis>

public class Person {
	public String name;
	
	<emphasis role="bold">@UiComesAfter( "name" )</emphasis>
	public int age;
	
	<emphasis role="bold">@UiComesAfter( "age" )</emphasis>
	public boolean retired;
}</programlisting>
	
				<para>
					Again, such annotations can (and should) be applied to getter methods, but for brevity here they
					are applied directly to the member variable.
				</para>
				
				<para>
					To recognise the annotations, Metawidget needs to use a different Inspector. Metawidget
					comes with multiple Inspectors, each targeting different sources of information. Change the Main class to use
					<classname>MetawidgetAnnotationInspector</classname> (lines to change are shown in bold):
				</para>
				
				<programlisting language="java">package com.myapp;

import javax.swing.*;
<emphasis role="bold">import org.metawidget.inspector.annotation.*;</emphasis>
import org.metawidget.swing.*;

public class Main {
	public static void main( String[] args ) {
		Person person = new Person();
	
		SwingMetawidget metawidget = new SwingMetawidget();
		<emphasis role="bold">metawidget.setInspector( new MetawidgetAnnotationInspector() );</emphasis>
		metawidget.setToInspect( person );

		JFrame frame = new JFrame( "Metawidget Tutorial" );
		frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
		frame.getContentPane().add( metawidget );
		frame.setSize( 400, 220 );
		frame.setVisible( true );
	}
}</programlisting>
	
				<para>
					Run the code. It does not yield the correct result - the fields appear in the correct order, as in
					<xref linkend="section-introduction-part1-incorrect-screenshot"/>, but they	are all <classname>JTextFields</classname>. We
					have lost our <classname>JSpinner</classname> and <classname>JCheckBox</classname>! What happened?
				</para>
				
				<figure id="section-introduction-part1-incorrect-screenshot">
					<title>SwingMetawidget incorrect rendering</title>			
					<screenshot>
						<graphic fileref="../shared/images/swing-tutorial2.jpg" width="100mm" />
					</screenshot>
				</figure>				

				<para>
					Metawidget Inspectors are very targeted in what they inspect. Although
					<classname>MetawidgetAnnotationInspector</classname> looks for Metawidget annotations (such as <classname>@UiComesAfter</classname>), it does <emphasis>not</emphasis>
					look for property type information (like <classname>PropertyTypeInspector</classname> did). Without type information, <classname>SwingMetawidget</classname>
					is unable to accurately choose <classname>JComponents</classname>.
				</para>
						
			</section>
			
			<section id="section-introduction-part1-compositeinspector">
				<title>Combining Multiple Inspection Results</title>
				
				<para>
					What we need is to <emphasis>combine</emphasis> the results of
					<classname>MetawidgetAnnotationInspector</classname> and <classname>PropertyTypeInspector</classname> before
					returning them to <classname>SwingMetawidget</classname>. We do this using <classname>CompositeInspector</classname>:
				</para>
	
				<programlisting language="java">package com.myapp;
				
import javax.swing.*;
<emphasis role="bold">import org.metawidget.inspector.annotation.*;
import org.metawidget.inspector.propertytype.*;
import org.metawidget.inspector.composite.*;</emphasis>
import org.metawidget.swing.*;

public class Main {
	public static void main( String[] args ) {
		Person person = new Person();
	
		SwingMetawidget metawidget = new SwingMetawidget();
		<emphasis role="bold">CompositeInspectorConfig config = new CompositeInspectorConfig()
			.setInspectors( 
				new MetawidgetAnnotationInspector(),
				new PropertyTypeInspector() );
		metawidget.setInspector( new CompositeInspector( config ) );</emphasis>
		metawidget.setToInspect( person );

		JFrame frame = new JFrame( "Metawidget Tutorial" );
		frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
		frame.getContentPane().add( metawidget );
		frame.setSize( 400, 220 );
		frame.setVisible( true );
	}
}</programlisting>

				<para>
					Run the code again. This time the fields should appear both in the correct order <emphasis>and</emphasis> with the
					correct <classname>JComponents</classname>.			
				</para>
				
				<para>
					From here, adding new fields is as simple as adding new member variables and annotating them:
				</para>
				
				<programlisting language="java">package com.myapp;

import org.metawidget.inspector.annotation.*;

public class Person {
	public String name;
	
	@UiComesAfter( "name" )
	public int age;
	
	@UiComesAfter( "age" )
	public boolean retired;

	<emphasis role="bold">@UiComesAfter( "retired" )
	@UiLarge
	public String notes;

	@UiComesAfter( "notes" )
	@UiSection( "Work" )
	public String employer;

	@UiComesAfter( "employer" )
	public String department;</emphasis>
}</programlisting>

				<para>
					This code produces the screen in <xref linkend="section-introduction-part1-more-screenshot"/>.
				</para>
				
				<figure id="section-introduction-part1-more-screenshot">
					<title>Additional fields and a section heading</title>			
					<screenshot>
						<graphic fileref="../shared/images/swing-tutorial3.jpg" width="100mm" />
					</screenshot>
				</figure>				
				
			</section>

			<section id="section-introduction-part1-layout">
				<title>Fine-Tuning The Layout</title>
				
				<para>
					By default, <classname>SwingMetawidget</classname> lays out <classname>JComponents</classname> using <classname>org.metawidget.swing.layout.GridBagLayout</classname>.
					You can swap this for a different layout using <function>SwingMetawidget.setLayoutClass</function>, or you can fine-tune the existing
					one using <function>SwingMetawidget.setParameter</function>:
				</para>
				
				<programlisting language="java">package com.myapp;

import javax.swing.*;
import org.metawidget.inspector.*;
import org.metawidget.inspector.annotation.*;
import org.metawidget.inspector.propertytype.*;
import org.metawidget.inspector.composite.*;
import org.metawidget.swing.*;

public class Main {
	public static void main( String[] args ) {
		Person person = new Person();

		SwingMetawidget metawidget = new SwingMetawidget();
		CompositeInspectorConfig config = new CompositeInspectorConfig()
			.setInspectors(
				new MetawidgetAnnotationInspector(),
				new PropertyTypeInspector() );
		metawidget.setInspector( new CompositeInspector( config ) );
		<emphasis role="bold">metawidget.setParameter( "numberOfColumns", 2 );</emphasis>
		metawidget.setToInspect( person );

		JFrame frame = new JFrame( "Metawidget Tutorial" );
		frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
		frame.getContentPane().add( metawidget );
		frame.setSize( 400, 220 );
		frame.setVisible( true );
	}
}</programlisting>

				<para>
					Run the code. The <classname>JComponents</classname> are now arranged across two columns as in
					<xref linkend="section-introduction-part1-columns-screenshot"/>. <classname>GridBagLayout</classname> is smart enough
					to give large <classname>JComponents</classname> like <parameter>Notes</parameter> the full width of the <classname>JFrame</classname>.
				</para>
				
				<figure id="section-introduction-part1-columns-screenshot">
					<title>A two-column layout</title>			
					<screenshot>
						<graphic fileref="../shared/images/swing-tutorial4.jpg" width="100mm" />
					</screenshot>
				</figure>				
				
				<para>
					Again, if you've ever used <classname>java.awt.GridBagLayout</classname> by hand, you'll appreciate how much easier Metawidget makes
					this.
				</para>
			</section>
				
			<section id="section-introduction-part1-creation">
				<title>Controlling Widget Creation</title>
				
				<para>
					Widget creation can be fine-tuned by dropping child controls inside the <classname>SwingMetawidget</classname>. This approach works well
					both within code and within visual UI builders.
				</para>
				
				<para>
					Modify the code to add a <classname>JComboBox</classname> to the Metawidget:
				</para>
								
				<programlisting language="java">package com.myapp;

import javax.swing.*;
import org.metawidget.inspector.*;
import org.metawidget.inspector.annotation.*;
import org.metawidget.inspector.propertytype.*;
import org.metawidget.inspector.composite.*;
import org.metawidget.swing.*;

public class Main {
	public static void main( String[] args ) {
		Person person = new Person();

		SwingMetawidget metawidget = new SwingMetawidget();
		CompositeInspectorConfig config = new CompositeInspectorConfig()
			.setInspectors(
				new MetawidgetAnnotationInspector(),
				new PropertyTypeInspector() );
		metawidget.setInspector( new CompositeInspector( config ) );
		metawidget.setParameter( "numberOfColumns", 2 );		
		metawidget.setToInspect( person );
		<emphasis role="bold">JComboBox combo = new JComboBox();
		combo.setName( "retired" );
		metawidget.add( combo );</emphasis>

		JFrame frame = new JFrame( "Metawidget Tutorial" );
		frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
		frame.getContentPane().add( metawidget );
		frame.setSize( 400, 220 );
		frame.setVisible( true );
	}
}</programlisting>

				<para>
					Run the code. The <classname>JComboBox</classname> appears in place of the <parameter>retired</parameter> <classname>JCheckBox</classname>,
					because it has the same name (eg. 'retired') as Metawidget would have given the <classname>JCheckbox</classname>.
				</para>
				
				<figure id="section-introduction-part1-override-screenshot">
					<title>The 'retired' field has been overridden</title>
					<screenshot>
						<graphic fileref="../shared/images/swing-tutorial5.jpg" width="100mm" />
					</screenshot>
				</figure>				

				<para>
					To suppress a widget's creation entirely, simply supplying an empty <classname>JPanel</classname> will not work as Metawidget
					will still create an accompanying label in the left hand column. Instead, Metawidget includes special <classname>Stub</classname> widgets
					for this purpose:
				</para>
				
				<programlisting language="java">package com.myapp;

import javax.swing.*;
import org.metawidget.inspector.*;
import org.metawidget.inspector.annotation.*;
import org.metawidget.inspector.propertytype.*;
import org.metawidget.inspector.composite.*;
import org.metawidget.swing.*;

public class Main {
	public static void main( String[] args ) {
		Person person = new Person();

		SwingMetawidget metawidget = new SwingMetawidget();
		CompositeInspectorConfig config = new CompositeInspectorConfig()
			.setInspectors(
				new MetawidgetAnnotationInspector(),
				new PropertyTypeInspector() );
		metawidget.setInspector( new CompositeInspector( config ) );
		metawidget.setParameter( "numberOfColumns", 2 );
		metawidget.setToInspect( person );
		<emphasis role="bold">metawidget.add( new Stub( "retired" ));</emphasis>

		JFrame frame = new JFrame( "Metawidget Tutorial" );
		frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
		frame.getContentPane().add( metawidget );
		frame.setSize( 400, 220 );
		frame.setVisible( true );
	}
}</programlisting>

				<para>
					Run the code. The <parameter>retired</parameter> field and its label will not appear.
				</para>
				
				<figure id="section-introduction-part1-suppress-screenshot">
					<title>The 'retired' field has been suppressed</title>
					<screenshot>
						<graphic fileref="../shared/images/swing-tutorial6.jpg" width="100mm" />
					</screenshot>
				</figure>				

				<para>
					Alternatively, you can use a <classname>@UiHidden</classname> annotation on the business class:
				</para>
								
				<programlisting language="java">package com.myapp;

import org.metawidget.inspector.annotation.*;

public class Person {
	public String name;
	
	@UiComesAfter( "name" )
	public int age;
	
	@UiComesAfter( "age" )
	<emphasis role="bold">@UiHidden</emphasis>
	public boolean retired;

	@UiComesAfter( "retired" )
	@UiLarge
	public String notes;

	@UiComesAfter( "notes" )
	@UiSection( "Work" )
	public String employer;

	@UiComesAfter( "employer" )
	public String department;
}</programlisting>

			</section>
			
			<section id="section-introduction-part1-inspector-config">
				<title>Configuring Inspectors Externally</title>

				<para>
					So far we have been instantiating our Inspectors in Java code. Whilst this approach is possible
					for all Inspectors, many UI frameworks employ visual UI builders or intermediate languages (such as JSPs) that
					make getting to the internal Java code cumbersome (eg. you have to derive custom widgets).
				</para>
				
				<para>
					As an alternative, Metawidget supports external XML configuration. Create a file called <filename>inspector-config.xml</filename>
					in the same folder as your <classname>Main</classname> class:
				</para>
			
				<programlisting language="xml">&lt;?xml version="1.0"?&gt;
&lt;inspector-config xmlns="http://metawidget.org/inspector-config"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://metawidget.org/inspector-config
		http://metawidget.org/inspector-config"&gt;

	&lt;compositeInspector xmlns="java:org.metawidget.inspector.composite"
		config="CompositeInspectorConfig"&gt;
		&lt;inspectors&gt;
			&lt;metawidgetAnnotationInspector
				xmlns="java:org.metawidget.inspector.annotation" /&gt;
			&lt;propertyTypeInspector
				xmlns="java:org.metawidget.inspector.propertytype"/&gt;
		&lt;/inspectors&gt;
	&lt;/compositeInspector&gt;

&lt;/inspector-config&gt;</programlisting>			
				
				<para>
					The <filename>inspector-config.xml</filename> file uses XML namespaces (the <parameter>xmlns</parameter> attribute)
					to support XSD validation. The child elements refer either to
					Inspectors (<parameter>&lt;compositeInspector&gt;</parameter>, <parameter>&lt;metawidgetAnnotationInspector&gt;</parameter> and
					<parameter>&lt;propertyTypeInspector&gt;</parameter>) or configuration settings (<parameter>&lt;inspectors&gt;</parameter>).
					Configuration settings map to setters on the <classname>Config</classname> class (in this case,
					<function>CompositeInspectorConfig.setInspectors</function>).
				</para>
				
				<para>
					To use <filename>inspector-config.xml</filename>, modify the code:
				</para>
					
				<programlisting language="java">package com.myapp;

<emphasis role="bold">import javax.swing.*;
import org.metawidget.swing.*;</emphasis>

public class Main {
	public static void main( String[] args ) {
		Person person = new Person();

		SwingMetawidget metawidget = new SwingMetawidget();
		<emphasis role="bold">metawidget.setInspectorConfig( "com/myapp/inspector-config.xml" );</emphasis>
		metawidget.setParameter( "numberOfColumns", 2 );
		metawidget.setToInspect( person );
		metawidget.add( new Stub( "retired" ));

		JFrame frame = new JFrame( "Metawidget Tutorial" );
		frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
		frame.getContentPane().add( metawidget );
		frame.setSize( 400, 220 );
		frame.setVisible( true );
	}
}</programlisting>

				<para>
					Run the code. The output is the same as before, but this time we are configuring our Inspectors via XML.
				</para>
				
				<para>
					Visual UI builders can set the <parameter>inspectorConfig</parameter> property from the builder, with no coding required. Other
					UI frameworks (eg. JSPs, Android) have similar 'code free' approaches (eg. setting an attribute on a JSP tag, setting an
					attribute in an Android layout file).
				</para>
				
			</section>
			
			<section id="section-introduction-part1-xmlinspector">
				<title>Inspecting Different Sources</title>
	
				<para>
					It could be argued UI-oriented annotations such as <classname>@UiComesAfter</classname> sit
					uncomfortably on a business class from a 'separation of concerns' perspective. It has advantages
					in that it keeps the metadata close to the data it refers to. It
					is also sufficiently abstract that it does not tie the code to any particular UI framework.			
				</para>
				
				<para>
					However, for those needing a different approach Metawidget can use
					different Inspectors to gather information from almost any source. One example is to
					use <classname>XmlInspector</classname>.
				</para>
				
				<para>
					<classname>XmlInspector</classname> is a very simple Inspector: it takes as its input XML in the same format
					that Inspectors usually output. Create a file called <filename>metawidget-metadata.xml</filename> in the same
					folder as your <classname>Main</classname> class:
				</para>
	
				<programlisting language="xml">&lt;?xml version="1.0"?&gt;
&lt;inspection-result xmlns="http://metawidget.org/inspection-result"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://metawidget.org/inspection-result
		http://metawidget.org/inspection-result/inspection-result-1.0.xsd "&gt;

	&lt;entity type="com.myapp.Person"&gt;
		&lt;property name="name" /&gt;
		&lt;property name="age" /&gt;
		&lt;property name="retired" /&gt;
		&lt;property name="notes" large="true"/&gt;
		&lt;property name="employer" section="Work"/&gt;
		&lt;property name="department"/&gt;
	&lt;/entity&gt;

&lt;/inspection-result&gt;</programlisting>
	
				<para>
					Note that <classname>XmlInspector</classname> does not need a <parameter>comes-after</parameter> attribute: XML nodes are
					inherently ordered, and <classname>CompositeInspector</classname> combines inspection results so that later results
					respect the ordering of earlier results. <classname>XmlInspector</classname> also does not need to specify a <parameter>type</parameter>
					attribute: we will still be using <classname>PropertTypeInspector</classname> to look up the types.
				</para>
	
				<para>
					Update <filename>inspector-config.xml</filename>:
				</para>
	
				<programlisting language="xml">&lt;?xml version="1.0"?&gt;
&lt;inspector-config xmlns="http://metawidget.org/inspector-config"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://metawidget.org/inspector-config
		http://metawidget.org/inspector-config"&gt;

	&lt;compositeInspector xmlns="java:org.metawidget.inspector.composite"
		config="CompositeInspectorConfig"&gt;
		&lt;inspectors&gt;
			<emphasis role="bold">&lt;xmlInspector xmlns="java:org.metawidget.inspector.xml"
				config="XmlInspectorConfig"&gt;
				&lt;file&gt;com/myapp/metawidget-metadata.xml&lt;/file&gt;
			&lt;/xmlInspector&gt;</emphasis>
			&lt;propertyTypeInspector
				xmlns="java:org.metawidget.inspector.propertytype"/&gt;
		&lt;/inspectors&gt;
	&lt;/compositeInspector&gt;

&lt;/inspector-config&gt;</programlisting>
	
				<para>
					Remove all the annotations from the <classname>Person</classname> class and run the code again.
					The ordering is still correct, and there is still a section heading, but this time it is being
					dictated by <classname>XmlInspector</classname>.
				</para>
				
				<para>
					This idea of the same UI characteristics being derivable from different back-end sources
					is fundamental to Metawidget. There is a lot of metadata already lurking in back-end
					systems - it just needs extracting. For example, <classname>JpaInspector</classname> understands this...
				</para>
				
				<programlisting language="java">public class Person {
	@Column( nullable = false )
	public String name;
}</programlisting>
	
				<para>
					...denotes <parameter>name</parameter> is a required field (could be rendered with a star after it in the UI). Equally,
					<classname>PropertyTypeInspector</classname> understands that...
				</para>
				
				<programlisting language="java">public class Person {
	private String name;
	
	public String getName()	{
		return this.name;
	}
	
	// No setter
}</programlisting>
	
				<para>
					...signifies <parameter>name</parameter> is a read-only field (could be rendered as a label in the UI).
				</para>
				
				<para>
					Metawidget comes with a range of Inspectors, and it is straightforward
					to write your own to inspect anything from XML configuration files to database schemas
					to annotations. The inspection process is loosely coupled from the
					widget creation process, so the same Inspector can supply information to multiple
					UI frameworks.
				</para>
				
			</section>
			
		</section>

		<section id="section-introduction-part2">
			<title>Part 2 - The Address Book Application</title>
			
			<section id="section-introduction-part2-preface">
				<title>Preface</title>
	
				<para>
					Part 2 explores a more substantial application, and shows how Metawidget can be used to map the <emphasis>same</emphasis> back-end
					to <emphasis>multiple</emphasis> front-ends. We will develop an Address Book application with
					desktop-based, Web-based and mobile-based UIs.
				</para>
				
				<para>
					This tutorial should take around 45 minutes. To save time, we use the pre-built example
					applications located in the <filename>examples</filename> folder. Also to save time, we will not
					focus on any one front-end framework in detail. For detailed framework-specific instructions, please see 
					<xref linkend="chapter-metawidgets"/>.
				</para>
				
			</section>			
			
			<section id="section-introduction-part2-desktop">
				<title>Desktop Address Book</title>
				
				<para>
					The Desktop Address Book is essentially a larger version of the Swing application developed in
					Part 1 - it just has more business objects and more Swing widgets.
				</para>
				
				<para>
					The application is pre-built for you in <filename>examples\swing\addressbook-swing.jar</filename> or, if you've downloaded
					the source code distribution, you can build it yourself by typing:
				</para>
				
				<programlisting language="shell">ant example-swing-addressbook</programlisting>
				
				<para>
					This is a self-executing JAR. For convenience, it has <filename>MAINFEST.MF</filename> dependencies hard-wired into it to <filename>..\..\metawidget.jar</filename> and
					<filename>lib\beansbinding.jar</filename> among others, so it's best not to move it to a different folder (if you do, you'll need to
					manually put <filename>metawidget.jar</filename> and <filename>beansbinding.jar</filename> on your classpath).
				</para>
				
				<para> 
					Run the code by navigating to the <filename>examples\swing</filename> folder and typing:
				</para>				
				
				<programlisting language="shell">java -jar addressbook-swing.jar</programlisting>
				
				<para>
					The opening screen displays a search filter (at the top) and lists
					existing Address Book entries (at the bottom) as in <xref linkend="section-introduction-part2-desktop-opening-screenshot"/>.
				</para>
				
				<figure id="section-introduction-part2-desktop-opening-screenshot">
					<title>Desktop Address Book opening screen</title>
					<screenshot>
						<graphic fileref="../shared/images/desktop-addressbook1.jpg" width="100mm" />
					</screenshot>
				</figure>				
				
				<para>
					The three search filter fields (<parameter>Firstname</parameter>, <parameter>Surname</parameter> and <parameter>Type</parameter>)
					are created by <classname>SwingMetawidget</classname>
					based on the <classname>ContactSearch</classname> business class. This includes populating the <parameter>Type</parameter> dropdown based
					on the <classname>ContactType</classname>
					enum. The <guibutton>Search</guibutton>, <guibutton>Add Personal Contact</guibutton> and <guibutton>Add Business Contact</guibutton> buttons
					are created by <classname>SwingMetawidget</classname> based on annotated methods in the <classname>ContactDialog</classname> class.
				</para>
				
				<tip>
					<title>Tip</title>
					To view the source code for the examples, such as the code for the <classname>ContactSearch</classname>,
					<classname>ContactType</classname> and <classname>ContactDialog</classname> classes, download the Metawidget
					source code distribution or browse it online at
					<uri>http://metawidget.svn.sourceforge.net/viewvc/metawidget/trunk/examples/src/java/org/metawidget/example</uri>. 
				</tip>				

				<para>
					Click <guibutton>Add Personal Contact</guibutton>. The screen displays a form for filling out Personal Contact information
					as in <xref linkend="section-introduction-part2-desktop-add-screenshot"/>.
				</para>
				
				<figure id="section-introduction-part2-desktop-add-screenshot">
					<title>Desktop Address Book 'Add Personal Contact' screen</title>
					<screenshot>
						<graphic fileref="../shared/images/desktop-addressbook2.jpg" width="100mm" />
					</screenshot>
				</figure>				

				<para>
					All the form fields are created by <classname>SwingMetawidget</classname> based on the <classname>PersonalContact</classname> business class.
					This class is itself derived from the <classname>Contact</classname> business class. It includes some Metawidget annotations
					for dropdown values and section headings.
				</para>
				
				<para>
					Note the code only has one <classname>JDialog</classname> class (<classname>ContactDialog</classname>), but is capable of supporting both
					<classname>PersonalContact</classname> and <classname>BusinessContact</classname> UIs. The fields in the UI change depending on
					the object passed to <classname>ContactDialog</classname> at runtime. This is the Third Goal Of Metawidget:
				</para>
				
			    <important>
			    	<title>Third Goal Of Metawidget</title>			    
					Metawidget performs inspection <emphasis>at runtime</emphasis>, detecting types and subtypes dynamically				
				</important>
				
				<para>
					The <parameter>Address</parameter> field is created as a nested <classname>SwingMetawidget</classname>. This is the default behaviour when Metawidget
					encounters datatypes it does not know how to represent with any other UI widget. The <parameter>Communications</parameter> field
					has been overridden with a manually specified <classname>JTable</classname>.
				</para>
				
				<para>
					In addition, <function>JTable.setCellEditor</function> uses <classname>SwingMetawidget</classname> to render single
					<classname>JComponents</classname> as <classname>CellEditors</classname>. This includes automatically populating dropdown values.
				</para>
				
				<section id="section-introduction-part2-desktop-readonly">
					<title>Read-Only Mode</title>

					<para>
						The Desktop Address Book uses Metawidget's <function>setReadOnly(true)</function> method to display
						read-only screens. Return to the main screen, and double-click on an existing contact (such as
						Homer Simpson). The same <classname>ContactDialog</classname> is used, but this time
						all the widgets are read-only labels as in <xref linkend="section-introduction-part2-desktop-readonly-screenshot"/>.
					</para>
					
					<figure id="section-introduction-part2-desktop-readonly-screenshot">
						<title>Desktop Address Book read-only mode</title>
						<screenshot>
							<graphic fileref="../shared/images/desktop-addressbook3.jpg" width="100mm" />
						</screenshot>
					</figure>

					<para>
						Click <guibutton>Edit</guibutton>. The labels are transformed into editable widgets by using
						Metawidget's <function>setReadOnly(false)</function>, as in <xref linkend="section-introduction-part2-desktop-editable-screenshot"/>.
					</para>
					
					<figure id="section-introduction-part2-desktop-editable-screenshot">
						<title>Desktop Address Book edit mode</title>
						<screenshot>
							<graphic fileref="../shared/images/desktop-addressbook4.jpg" width="100mm" />
						</screenshot>
					</figure>
					
				</section>
				
				<section id="section-introduction-part2-desktop-binding">
					<title>Binding</title>

					<para>
						The data from the <classname>PersonalContact</classname> object is automatically inserted into the
						<classname>JComponents</classname>. It is also automatically saved back when clicking <guibutton>Save</guibutton>.
					</para>
					
					<para>					
						Swing does not define a <classname>JComponent</classname> to <classname>Object</classname> mapping mechanism, so by default
						<classname>SwingMetawidget</classname> only supplies
						<function>setValue</function> and <function>getValue</function> methods for manually fetching values. This situation is no
						worse than a normal Swing application, but Metawidget can do better.
					</para>
				
					<para> 					
						<classname>SwingMetawidget</classname> directly supports third-party binding alternatives such as Apache BeanUtils and
						Beans Binding (JSR 295) via <function>SwingMetawidget.setPropertyBindingClass</function>. These
						binding implementations automatically map <classname>JComponent</classname> values to <classname>Object</classname> values,
						including performing the necessary conversions, further reducing the amount of boilerplate code required.
					</para>
					
				</section>
				
				<section id="section-introduction-part2-desktop-i18n">
					<title>Localization</title>

					<para>
						All text within the application has been localized to the <classname>org.metawidget.example.shared.addressbook.resource.Resources</classname>
						resource bundle. Text created manually (such as the buttons) uses typical Swing localization code (eg. <function>bundle.getString</function>). Text created by
						<classname>SwingMetawidget</classname> uses <function>SwingMetawidget.setBundle</function>, which internally defers to <function>bundle.getString</function>.
					</para>
					
					<para>	
						Localization is very easy with Metawidget. For field names, if no resource bundle is supplied, Metawidget uses a 'uncamel-cased' version of the name. If
						a bundle <emphasis>is</emphasis> supplied, Metawidget uses the field name as the bundle key. For section labels, if a bundle is supplied,
						Metawidget uses a 'camel-cased' version of the label as the key.
					</para>
					
					<para>
						This means developers can initially
						build their UIs without worrying about resource bundles, then turn on localization support later.
					</para>
					
				</section>
				
			</section>
			
			<section id="section-introduction-part2-web">
				<title>Web Address Book</title>
				
				<para>
					As there are a large number of Java Web application frameworks to choose from, this example comes written
					in five of the most popular: Google Web Toolkit (GWT), Java Server Faces (JSF), Java Server Pages (JSP),
					Spring Web MVC and Struts. We recommend you follow along using the one most relevant to you.
				</para>
				
				<para>
					Web-based applications are inherently more difficult to setup and run than desktop-based
					applications because they require a container application. For
					this tutorial, we will use Apache Tomcat 6 (Tomcat), as it is one of the easier containers
					to get running. Tomcat can be downloaded from <uri>http://tomcat.apache.org</uri>.
				</para>
				
				<para>
					Take a fresh install of Tomcat. The Address Book WAR is pre-built for you in
					either <filename>examples\faces\addressbook-faces.war</filename>, <filename>examples\gwt\addressbook-gwt.war</filename>,
					<filename>examples\jsp\addressbook-jsp.war</filename>, <filename>examples\spring\addressbook-spring.war</filename> or
					<filename>examples\struts\addressbook-struts.war</filename>. If you've downloaded the source code distribution, you can build it
					yourself by typing:
				</para>
				
				<programlisting language="shell">ant example-faces-addressbook</programlisting>

				<para>
					(replacing <parameter>faces</parameter> with <parameter>gwt</parameter>, <parameter>jsp</parameter>, <parameter>spring</parameter> or <parameter>struts</parameter> as appropriate).
				</para>

				<tip>
					<title>Tip</title>
					For most web environments, deploying Metawidget is as simple as adding <filename>metawidget.jar</filename> to
					<filename>WEB-INF\lib</filename>. For GWT, you'll also need to include <filename>metawidget.jar</filename>
					and <filename>examples\gwt\metawidget-gwt-client.jar</filename> in the <parameter>CLASSPATH</parameter>
					during your <parameter>GWTCompiler</parameter> step.
				</tip>				

				<para>
					Copy the WAR into Tomcat's <filename>webapps</filename> folder, start Tomcat, and open a Web browser
					to <uri>http://localhost:8080/addressbook-faces</uri>. The home page displays
					a search filter (at the top) and lists existing Address Book entries (at the bottom)
					as in <xref linkend="section-introduction-part2-web-opening-screenshot"/>.
				</para>
				
				<figure id="section-introduction-part2-web-opening-screenshot">
					<title>Web Address Book opening screen</title>
					<screenshot>
						<graphic fileref="../shared/images/web-addressbook1.jpg" width="100mm" />
					</screenshot>
				</figure>

				<para>
					As with the Desktop Address Book, the three search filter fields are created
					by Metawidget (this time <classname>UIMetawidget</classname>, <classname>GwtMetawidget</classname>, <classname>SpringMetawidgetTag</classname>
					or <classname>StrutsMetawidgetTag</classname>) based on the <classname>ContactSearch</classname> business class:
				</para>
				
				<programlisting language="jsp">&lt;m:metawidget value="#{contact.search}"&gt;
	...
&lt;/m:metawidget&gt;</programlisting>
				
				<para>
 					Again, this includes populating the <parameter>Type</parameter> dropdown and localizing the text. The <guibutton>Search</guibutton>,
					<guibutton>Add Personal Contact</guibutton> and <guibutton>Add Business Contact</guibutton> buttons are either manually specified
					in the JSP page (for GWT, Spring and Struts) or created by <classname>UIMetawidget</classname> based on annotated methods
					in the <classname>ContactBean</classname> (for JSF).
				</para>
								
				<para>
					The look of the Web page relies entirely on HTML and CSS technologies:
				</para>
				
<programlisting language="jsp">&lt;m:metawidget value="#{contact.search}"&gt;
	<emphasis role="bold">&lt;f:param name="tableStyleClass" value="table-form"/&gt;
	&lt;f:param name="columnClasses"
		value="table-label-column,table-component-column,required" /&gt;</emphasis>
	...
&lt;/m:metawidget&gt;</programlisting>
				
				<para>
					Only the layout	of 'one column for the label, one column for the widget' is dictated by Metawidget, and that is again
					pluggable and configurable.
				</para>
				
				<para>
					Click <guibutton>Add Personal Contact</guibutton>. The page displays a form for filling out Personal Contact information
					as in <xref linkend="section-introduction-part2-web-add-screenshot"/>.
				</para>
				
				<figure id="section-introduction-part2-web-add-screenshot">
					<title>Web Address Book 'Add Personal Contact' screen</title>
					<screenshot>
						<graphic fileref="../shared/images/web-addressbook2.jpg" width="100mm" />
					</screenshot>
				</figure>

				<para>
					All the form fields are created by Metawidget based on the <classname>PersonalContact</classname> business class. The section headings
					are the same, but have this time been rendered as HTML.
				</para>
				
				<para>
					The <parameter>Address</parameter> field is a nested Metawidget. The <parameter>Communications</parameter> field
					has been overridden in the JSP page with a manually specified table. <classname>UIMetawidget</classname> understands a manually-specified widget to
					override an automatic one if it has the same <parameter>value</parameter> binding as the automatic
					widget would have (<classname>GwtMetawidget</classname>, <classname>SpringMetawidget</classname> and <classname>StrutsMetawidget</classname> do
					something similar):
				</para>
				
				<programlisting language="jsp">&lt;m:metawidget value="#{contact.current}"&gt;
	...		
	&lt;h:dataTable value="#{contact.current.communications}"&gt;
		...
	&lt;/h:dataTable&gt;						
	...							
&lt;m:metawidget&gt;</programlisting>
				
				<para>
					JSF has built-in support for executing actions on table rows. In order to use it, however, the <classname>Set</classname>
					returned by <function>Contact.getCommunications</function> must be wrapped into a <classname>DataModel</classname>. This is handled by
					<function>ContactController.getCurrentCommunications</function>, but this presents a problem: the mapping for the
					<classname>HtmlDataTable</classname> must be <parameter>#{contact.currentCommunications}</parameter>, but the mapping required to override
					<classname>UIMetawidget</classname>'s automatic widget creation is <parameter>#{contact.current.communications}</parameter>.
				</para>
				
				<para>
					<classname>UIMetawidget</classname> supplies <classname>UIStub</classname> for these situations. Stubs have a binding, but do nothing with it
					and render nothing. They can be used either to suppress widget creation entirely (a stub
					with an empty body) or to replace the automatic widget creation with one or more other widgets
					with different bindings:
				</para>
				
				<programlisting language="jsp">&lt;m:metawidget value="#{contact.current}"&gt;
	...		
	&lt;m:stub value="#{contact.current.communications}"&gt;
		&lt;h:dataTable value="#{contact.currentCommunications}"&gt;
			...
		&lt;/h:dataTable&gt;						
	&lt;/m:stub&gt;						
	...							
&lt;m:metawidget&gt;</programlisting>

				<para>
					JSP, Spring, Struts lack some component-based features found in Swing and JSF. Specifically,
					whilst it is possible for tags to reference their <emphasis>parent</emphasis>
					(using <function>TagSupport.findAncestorWithClass</function>), they have no way to interrogate
					their <emphasis>children</emphasis>. Therefore, it is not possible to directly support arbitrary child tags
					within <classname>HtmlMetawidget</classname>, <classname>SpringMetawidget</classname> and <classname>StrutsMetawidget</classname>.
				</para>

				<para>
					Instead, we wrap the overridden <parameter>Communications</parameter> field in Metawidget's <classname>Stub</classname> tag. Metawidget
					and its Stub tags have explicit	support for co-ordinating the overriding of widget creation:
				</para>
				
				<programlisting language="jsp">&lt;m:metawidget property="contactForm"&gt;
	...		
	&lt;m:stub property="communications"&gt;
		&lt;table class="data-table"&gt;
			...
		&lt;/table&gt;
	&lt;/m:stub&gt;						
	...							
&lt;m:metawidget&gt;</programlisting>

				<para>
					<classname>GwtMetawidget</classname> uses stubs around GWT widgets like <classname>FlexTable</classname>, but can use
					the overriding widget directly if it supports the <classname>HasName</classname> interface (eg. TextBox, CheckBox, etc).
				</para>

				<section id="section-introduction-part2-web-mixing">
					<title>Mixing Metawidgets</title>
					
					<para>
						This section only applies to Spring and Struts.
					</para>

					<para>
						Within the <parameter>Communications</parameter> table, implementing <guibutton>Add Communication</guibutton> calls for a design decision.
						Struts does not support multiple <classname>ActionForms</classname> per <classname>Action</classname>, so we are unable to combine
						<classname>PersonalContactForm</classname> with a <classname>CommunicationForm</classname> (as we did in the JSF). Spring has a similar
						limitation of not supporting multiple <parameter>commandNames</parameter> per form. Instead, we need to either:
					</para>
					
					<itemizedlist>
						<listitem>
							<para>
								add fields from <classname>Communication</classname> to <classname>PersonalContactForm</classname>, and ignore them when
								saving the <classname>PersonalContact</classname>; or
							</para>
						</listitem>
						<listitem>
							<para>
						 		output plain HTML tags (eg. independent of Spring and Struts) and handle them manually
						 	</para>
						 </listitem>
					</itemizedlist>
					
					<para>
						Both approaches would be valid. For this tutorial, we choose the latter as it allows us to introduce <classname>HtmlMetawidget</classname>
						(a Metawidget for plain HTML/JSP webapps that don't use Struts or Spring) and demonstrate <emphasis>mixing</emphasis> two Metawidgets on
						the same page:
					</para>
	
					<programlisting language="jsp"><emphasis role="bold">&lt;m:metawidget property="contactForm"&gt;</emphasis>
	...
	&lt;m:stub property="communications"&gt;
		&lt;table class="data-table"&gt;
		...
		&lt;tr&gt;
			&lt;jsp:useBean id="communication"
			class="org.metawidget.example.shared.addressbook.model.Communication"/&gt;						
			&lt;td&gt;<emphasis role="bold">&lt;mh:metawidget value="communication.type"
				style="width: 100%" layoutClass=""/&gt;</emphasis>&lt;/td&gt;
			&lt;td&gt;<emphasis role="bold">&lt;mh:metawidget value="communication.value"
				style="width: 100%" layoutClass=""/&gt;</emphasis>&lt;/td&gt;
		&lt;/tr&gt;
		...
		&lt;/table&gt;
	&lt;/m:stub&gt;
	...
<emphasis role="bold">&lt;/m:metawidget&gt;</emphasis></programlisting>
	
					<para>
						The two different tag prefixes <parameter>m:</parameter> and <parameter>mh:</parameter> denote different tag libraries. 
						<classname>HtmlMetawidget</classname> is very similiar to <classname>StrutsMetawidget</classname>, but has to use
						<parameter>jsp:useBean</parameter> to manually instantiate the bean (rather than letting Struts do it). 
						The default layout has been changed using <parameter>layoutClass=""</parameter> from a <classname>TableLayout</classname> to
						a plain layout (eg. one without a label column).
					</para>
					
				</section>				
				
				<section id="section-introduction-part2-web-expression-lookup">
					<title>Expression Based Lookups</title>
					
					<para>
						This section does not apply to GWT.
					</para>

					<para>
						In the Desktop Address Book, the <parameter>title</parameter> dropdown was populated by
						a static <parameter>lookup</parameter> attribute in <filename>metawidget-metadata.xml</filename>. JSP and JSF-based technologies can do better, because they have a built-in
						scope-based component model and Expression Language.
					</para>
					
					<para>
						<function>Contact.getTitle</function> is annotated
						using <classname>@UiFacesLookup</classname> and <classname>@UiSpringLookup</classname> (and <function>ContactForm.getTitle</function>
						is annotated using <classname>@UiStrutsLookup</classname>). These are used at runtime to create dynamic lookups.
					</para>
					
					<para>
						These annotations, unlike the ones we have used so far, <emphasis>are</emphasis> UI-framework specific so you may prefer
						to declare them in <filename>metawidget-metadata.xml</filename>. Before doing so, however, you should understand we are still
						not introducing runtime dependencies into our business classes: an important feature of annotations is they 'fall away gracefully'
						if their implementing class is not found. Annotations never throw <classname>ClassDefNotFoundError</classname>.
					</para>
					
				</section>

				<section id="section-introduction-part2-web-richfaces">
					<title>Alternate Widget Libraries</title>
					
					<para>
						This section only applies to JSF.
					</para>
					
					<para>
						Go into Tomcat's <filename>webapps\addressbook-faces</filename> folder (the exploded WAR)
						and edit <filename>contact.jsp</filename> to change <uri>http://metawidget.org/faces</uri> to <uri>http://metawidget.org/faces/richfaces</uri>
						(shown in bold):
					</para>
					
					<programlisting language="jsp">&lt;%@ page language="java" %&gt;
...
&lt;%@ taglib uri="http://metawidget.org/faces<emphasis role="bold">/richfaces</emphasis>" prefix="m"%&gt;
...
&lt;tags:page&gt;</programlisting>
	
					<para>
						Now refresh the Web browser. Notice how the <parameter>Date of Birth</parameter> field for Personal Contacts becomes a RichFaces date picker
						widget, and the <parameter>Number of Staff</parameter> field for Business Contacts becomes a RichFaces slider widget. This shows how easy
						it is to leverage widget libraries with Metawidget (this example cheats a bit, as we've pre-added the RichFaces JARs into
						<filename>WEB-INF\lib</filename> and some lines into <filename>web.xml</filename>, but you get the idea).
					</para>
					
				</section>

			</section>

			<section id="section-introduction-part2-mobile">
				<title>Mobile Address Book</title>
				
				<para>
					For the Mobile Address Book we use the Android platform. Android has uniquely strong support for reflection
					and annotations, and guarantees the availability of key packages such as <classname>org.w3c.dom</classname>. This affords
					Metawidget excellent runtime access to inspect the <emphasis>O</emphasis> in OIM.
				</para>
				
				<para>
					Like Web-based applications, Mobile applications require a container to run. Download version 1.0_r1 of
					the Android SDK from <uri>http://code.google.com/android/download.html</uri>.
					Then, change to the installation directory (usually <filename>android-sdk-windows-1.0_r1</filename>) and run the emulator by
					opening a command prompt and typing:
				</para>
				
				<programlisting language="shell">tools\emulator</programlisting>
				
				<para>
					The emulator may take a little while to start. Once finished, it will display the phone's desktop. The Address Book APK
					is pre-built for you in <filename>examples\android\addressbook-android.apk</filename>. If you've downloaded the source code distribution, you
					can build it yourself by typing:
				</para>
				
				<programlisting language="shell">ant example-android-addressbook</programlisting>

				<para>
					(ensuring your <filename>build.properties</filename> is setup correctly to point to the Android SDK).
				</para>

				<para>				
					Next, open a <emphasis>second</emphasis> command prompt, change to the Android installation directory and type:
				</para>
				
				<programlisting language="shell">tools\adb install &lt;metawidget folder&gt;\examples\android\addressbook-android.apk</programlisting>
				
				<para>
					This deploys the APK into the emulator. To run it, use the arrow pad on the emulator to move to the <parameter>All</parameter>
					button, then click the center of the arrow pad. Select the Address Book application and press the center of the arrow pad again.
					The emulator displays a search filter (at the top) and lists existing Address Book entries (at the bottom)
					as in <xref linkend="section-introduction-part2-mobile-opening-screenshot"/>.
				</para>
				
				<figure id="section-introduction-part2-mobile-opening-screenshot">
					<title>Mobile Address Book opening screen</title>
					<screenshot>
						<graphic fileref="../shared/images/mobile-addressbook1.jpg" width="60mm" />
					</screenshot>
				</figure>

				<para>
					As with the Desktop and Web Address Books, the three search filter fields are created
					by Metawidget (this time <classname>AndroidMetawidget</classname>) based on the <classname>ContactSearch</classname> business class.
					Again, this includes populating the <parameter>Type</parameter> dropdown.
				</para>

				<para>
					The look of the screen relies entirely on Android XML layout files, styles and themes. Only the 'one column for the label, one column
					for the widget' layout is dictated by Metawidget, and that is pluggable and configurable.
				</para>

				<para>
					Choose <guibutton>Add Personal</guibutton> from the Android menu. The page displays a form for filling out Personal Contact information
					as in <xref linkend="section-introduction-part2-mobile-add-screenshot"/>.
				</para>
				
				<figure id="section-introduction-part2-mobile-add-screenshot">
					<title>Mobile Address Book 'Add Personal Contact' screen</title>
					<screenshot>
						<graphic fileref="../shared/images/mobile-addressbook2.jpg" width="60mm" />
					</screenshot>
				</figure>

				<para>
					UIs in Android are typically defined in XML layout files, though they can also be built programmatically.
					<classname>AndroidMetawidget</classname> supports both approaches. For example, the Personal Contact screen is
					defined in <filename>contact.xml</filename>, and contains a Metawidget defined in much the same way as in
					JSP (including configuring section style and overriding widget creation): 
				</para>

				<programlisting language="xml">&lt;view class="org.metawidget.android.widget.AndroidMetawidget" android:id="@+id/metawidget"
	inspectorConfig="@raw/inspector_config"
	paramSectionStyle="@style/section"&gt;
	
	&lt;view class="org.metawidget.android.widget.Stub" tag="communications"&gt;
			
		&lt;ListView android:id="@id+/communications" ... /&gt;
	       			
		&lt;Button android:id="@+id/buttonAddCommunication"
			android:text="@string/addCommunication" ... /&gt;
	
	&lt;/view&gt;
       
&lt;/view&gt;</programlisting>
				
				<para>
					Within <classname>CommunicationDialog</classname>, a Metawidget is defined programatically in much the same way as in
					Swing:
				</para>
				
				<programlisting language="java">mMetawidget = new AndroidMetawidget( activity );
mMetawidget.setInspectorConfig( R.raw.inspector_config );				
...
mMetawidget.setToInspect( mCommunication );</programlisting>
				
				<para>
					This produces the dialog box in <xref linkend="section-introduction-part2-mobile-dialog-screenshot"/>.
				</para>
				
				<figure id="section-introduction-part2-mobile-dialog-screenshot">
					<title>Mobile Address Book Communications Dialog</title>
					<screenshot>
						<graphic fileref="../shared/images/mobile-addressbook3.jpg" width="60mm" />
					</screenshot>
				</figure>

			</section>
		</section>
			
		<section id="section-introduction-part3-other-examples">
			<title>Part 3 - Other Examples</title>
			
			<section id="section-introduction-part3-preface">
				<title>Preface</title>
	
				<para>
					The Metawidget distribution includes other examples showcasing particular features
					on particular platforms. These additional examples are not a required part of the tutorial
					and may be skipped. However, you may find them useful depending on which platform you
					use.
				</para>
	
			</section>
			
			<section id="section-introduction-part3-applet">
				<title>Swing Applet Address Book Example</title>
	
				<para>
					The Swing Applet Address Book Example demonstrates using Metawidget in applets. The example is pre-built for you in
					<filename>examples\swing\applet\addressbook</filename>. If you've downloaded the source code distribution, you can build it
					yourself by typing:
				</para>
				
				<programlisting language="shell">ant example-swing-addressbook-applet</programlisting>

				<para>
					To run the applet, open the <filename>index.html</filename> file in a Web browser. The code
					is identical to the Swing Address Book covered in Part 2 of this tutorial, except
					it uses <classname>org.metawidget.example.swing.applet.AddressBookApplet</classname> instead
					of <classname>org.metawidget.example.swing.addressbook.MainFrame</classname>.
				</para>

				<para>
					The notable feature of the example is how the applet is packaged. Metawidget is highly modular and has no
					mandatory third-party JAR dependencies. The <filename>example-swing-addressbook-applet</filename> Ant task
					builds only those Inspectors necessary for the Address Book application. The resulting <filename>metawidget-applet.jar</filename> is
					then further compressed using <filename>pack200</filename> to around 45KB. This small download size
					makes Metawidget very viable for Applet-based environments.
				</para>
	
			</section>
			
			<section id="section-introduction-part3-gwt-hosted">
				<title>GWT Hosted Mode Address Book Example</title>
	
				<para>
					The <filename>examples\gwt\addressbook-gwt.war</filename> discussed in Part 2 of this tutorial demonstrates GWT
					running in <emphasis>GWT Web mode</emphasis>. Developers may prefer instead to run the example in <emphasis>GWT hosted mode</emphasis>
					as in <xref linkend="section-introduction-part3-gwt-hosted-screenshot"/>.
				</para>

				<figure id="section-introduction-part3-gwt-hosted-screenshot">
					<title>Address Book Example running in GWT Hosted Mode</title>
					<screenshot>
						<graphic fileref="../shared/images/web-gwt-hosted.jpg" width="100mm" />
					</screenshot>
				</figure>

				<para>
					There are two ways to set up a hosted mode project. For Windows developers, there is an automated Ant build
					included in the source distribution (not the binary distribution). To run it, type: 
				</para>
				
				<programlisting language="shell">cd examples\web\gwt
ant</programlisting>
								
				<para>
					You will need to either configure <parameter>GWT_HOME</parameter> and <parameter>METAWIDGET_HOME</parameter>
					environment variables or pass <parameter>-Dgwt.home</parameter> and <parameter>-Dmetawidget.home</parameter>
					arguments to Ant. The build will create an Eclipse
					project which can be imported by using Eclipse's File -> Import menu and choosing
					"Existing Projects into Workspace" (as described in the GWT Getting	Started Guide).
				</para>
				
				<para>
					Alternatively, to set up a hosted mode project manually: 
				</para>

				<itemizedlist>
					<listitem>
						<para>
							Create a new GWT project using the usual method (described in the GWT Getting Started guide). First
							create a folder called, say, <filename>HostedAddressBook</filename>. Within that folder, run...
						</para>
						<programlisting language="shell">projectCreator -eclipse HostedAddressBook</programlisting>
						<para>
							...and then... 
						</para>						
						<programlisting language="shell">applicationCreator
	-eclipse HostedAddressBook org.metawidget.example.gwt.addressbook.client.AddressBook</programlisting>
					</listitem>
					<listitem>
						<para>
							Delete the contents of <filename>HostedAddressBook\src\org\metawidget\example</filename>.
						</para>
					</listitem>   
					<listitem>
						<para>
							From the Metawidget source distribution, copy from the <filename>examples\java\org\metawidget\example</filename>
							folder the <filename>gwt</filename> and <filename>shared</filename> folders, and the
							<filename>GwtAddressBook.gwt.xml</filename> file, into <filename>HostedAddressBook\src\org\metawidget\example</filename> 
						</para>
					</listitem>
					<listitem>
						<para>
							From the Metawidget source distribution, copy from the <filename>examples\web\gwt\addressbook\WEB-INF</filename>
							folder the <filename>inspector-config.xml</filename> and <filename>metawidget-metadata.xml</filename> files into
							<filename>HostedAddressBook/src</filename>
						</para>
					</listitem>
					<listitem>
						<para>
							From the Metawidget source distribution, copy from the <filename>lib</filename> folder the <filename>ejb3-persistence.jar</filename>,
							<filename>hibernate-validator.jar</filename> and <filename>javax.servlet.jsp.jar</filename> files into a new folder
							called <filename>HostedAddressBook/lib</filename>
						</para>
					</listitem>   
					<listitem>
						<para>
							From the Metawidget binary distribution, copy <filename>metawidget.jar</filename> and <filename>examples\gwt\metawidget-gwt-client.jar</filename>
							into <filename>HostedAddressBook\lib</filename>
						</para>
					</listitem>
					<listitem>
						<para>
							Modify <filename>HostedAddressBook\AddressBook.launch</filename>. Change...
						</para>
						<programlisting language="shell">...
&lt;stringAttribute key="org.eclipse.jdt.launching.PROGRAM_ARGUMENTS"
	value="-out www org.metawidget.example.<emphasis role="bold">gwt.addressbook.AddressBook</emphasis>/AddressBook.html"/&gt;					
...</programlisting>
						<para>
							...to...
						</para>
						<programlisting language="shell">...
&lt;stringAttribute key="org.eclipse.jdt.launching.PROGRAM_ARGUMENTS"
	value="-out www org.metawidget.example.<emphasis role="bold">GwtAddressBook</emphasis>/AddressBook.html"/&gt;					
...</programlisting>
					</listitem>   
					<listitem>
						<para>
							In Eclipse, use the File -> Import menu and choose "Existing Projects into Workspace" (as described in the GWT Getting
							Started Guide). Select <filename>HostedAddressBook</filename>
						</para>
					</listitem>
					<listitem>
						<para>
							In Eclipse, edit the Build Path of the new project and add all 5 JARs from <filename>HostedAddressBook\lib</filename>
						</para>
					</listitem>
				</itemizedlist>					
				
				<para>
					You should now be able to run the GWT Address Book sample application in hosted mode.
				</para>
				
			</section>

			<section id="section-introduction-part3-seam">
				<title>Seam Example</title>
	
				<para>
					The Seam Booking Example demonstrates updating an existing Seam application to use Metawidget, reducing
					boilerplate code. The example requires you to have previously downloaded Seam 2.1.0.SP1
					and JBoss 4.2.3.GA, and you should be familiar with the existing Seam
					Booking application.
				</para>
				
				<para>
					The example is located in <filename>examples\faces\seam\booking</filename>. It is
					not pre-built. To build it, change to the <filename>examples\faces\seam\booking</filename> folder and type:
				</para>
				
				<programlisting language="shell">ant</programlisting>

				<para>
					To run it, type:
				</para>

				<programlisting language="shell">cd \Applications\jboss-4.2.3.GA
bin\run</programlisting>

				<para>
					Open a Web browser to <uri>http://localhost:8080/seam-booking</uri>. The updated Metawidget
					Seam Booking Example looks very similar to the original, as in <xref linkend="section-introduction-part3-seam-screenshot"/>,
					but uses significantly less boilerplate code.
				</para>
				
				<figure id="section-introduction-part3-seam-screenshot">
					<title>Seam Booking with Metawidget</title>
					<screenshot>
						<graphic fileref="../shared/images/web-seam-booking.jpg" width="100mm" />
					</screenshot>
				</figure>
				
				<para>
					The files modified for adding Metawidget support are in <filename>examples\faces\seam\booking</filename>. Most of the
					UI code in <filename>view\book.xhtml</filename>, <filename>view\confirm.xhtml</filename> and
					<filename>view\hotelview.xhtml</filename> has been replaced with a single Metawidget tag. Some annotations
					have been added to <filename>Hotel.java</filename> and <filename>Booking.java</filename>, though
					Metawidget also leverages the existing JPA and Hibernate Validator ones.
				</para>
				
				<para>
					The example further demonstrates packaging Metawidget for multi-tier environments. The <filename>pack-as-frontend-backend</filename>
					Ant task in Metawidget's <filename>build.xml</filename> creates two JAR files: <filename>metawidget-frontend.jar</filename> for
					deployment in the WAR, and <filename>metawidget-backend.jar</filename> for deployment in the EJB layer. This ensures a clean
					separation between frontend and backend code, and is important for avoiding	WAR/EJB classloading problems.
				</para>
				
			</section>

			<section id="section-introduction-part3-groovy">
				<title>Groovy Example</title>

				<para>
					The Seam Groovy Booking Example demonstrates updating an existing Seam Groovy application to 
					use Metawidget, reducing boilerplate code. The example is a more advanced version of the previous Seam section, so you
					should work through that first.
				</para>

				<para>
					The example is located in <filename>examples\faces\seam\groovybooking</filename>. It is
					not pre-built. To build it, change to the <filename>examples\faces\seam\groovybooking</filename> folder and type:
				</para>
				
				<programlisting language="shell">ant</programlisting>

				<para>
					To run it, type:
				</para>

				<programlisting language="shell">cd \Applications\jboss-4.2.3.GA
bin\run</programlisting>

				<para>
					Open a Web browser to <uri>http://localhost:8080/jboss-seam-groovy</uri>. As with the previous
					section, the updated Metawidget Seam Groovy Booking Example looks very similar to the original, but
					uses significantly less	boilerplate code. Also, this time we are using Groovy to define
					our business classes. The biggest impact this has is in <code>inspector-config.xml</code>,
					where the Inspectors have been configured to use a Groovy property style instead of a JavaBean
					property style.
				</para>
				
				<para>
					Metawidget supports pluggable 'property styles' for JavaBean and Groovy property styles.
					Groovy properties differ from JavaBean properties in that their annotations are tied to
					the private member variable, rather than the getters and setters. The use of Groovy is configured
					per <classname>Inspector</classname>, as in <filename>examples\faces\seam\groovybooking\resources\WEB-INF\inspector-config.xml</filename>:
				</para>

				<programlisting language="xml">&lt;propertyTypeInspector config="org.metawidget.inspector.impl.BaseObjectInspectorConfig"&gt;
	&lt;propertyStyle&gt;
		org.metawidget.inspector.impl.propertystyle.groovy.GroovyPropertyStyle
	&lt;/propertyStyle&gt;
&lt;/propertyTypeInspector&gt;</programlisting>

			</section>
			
			<section id="section-introduction-part3-jbpm">
				<title>jBPM Example</title>
		
				<para>
					The Seam DVD Store Example demonstrates updating an existing Seam jBPM application to use Metawidget, reducing
					boilerplate code. The example requires you to have previously downloaded Seam 2.1.0.SP1
					and JBoss 4.2.3.GA, and you should be familiar with the existing Seam DVD Store application.
				</para>

				<para>
					The example is located in <filename>examples\faces\seam\dvdstore</filename>. It is
					not pre-built. To build it, change to the <filename>examples\faces\seam\dvdstore</filename> folder and type:
				</para>
				
				<programlisting language="shell">ant</programlisting>

				<para>
					To run it, type:
				</para>

				<programlisting language="shell">cd \Applications\jboss-4.2.3.GA
bin\run</programlisting>

				<para>
					Open a Web browser to <uri>http://localhost:8080/seam-dvd</uri>. As with the previous
					two sections, the updated Metawidget Seam DVD Store example looks very similar to the original, 
					as in <xref linkend="section-introduction-part3-jbpm-screenshot"/>, but
					uses significantly less	boilerplate code.
				</para>
				
				<figure id="section-introduction-part3-jbpm-screenshot">
					<title>Seam DVD Store with Metawidget</title>
					<screenshot>
						<graphic fileref="../shared/images/web-seam-dvd.jpg" width="100mm" />
					</screenshot>
				</figure>
				
				<para>
 					This time, as well as generating <classname>UIComponents</classname>
					for business objects such as <classname>com.jboss.dvd.seam.Customer</classname>, Metawidget inspects jBPM files like
					<filename>newuser.jpdl.xml</filename> and <filename>checkout.jpdl.xml</filename> to generate the
					correct <classname>UICommand</classname> buttons for each screen.				
				</para>

			</section>
			
			<section id="section-introduction-part3-swingappframework">
				<title>Swing AppFramework Example</title>
	
				<para>
					The Swing AppFramework Car Demo demonstrates using Metawidget with the Swing AppFramework. Metawidget
					can use Swing AppFramework's <classname>@Action</classname> annotation to identify actions, both amongst
					a business object's properties and in external controllers, and automatically generate <classname>JButtons</classname>
					for them.
				</para>
	
				<para>
					The application is pre-built for you in <filename>examples\swing\appframework-swing.jar</filename> or, if you've downloaded
					the source code distribution, you can build it yourself by typing:
				</para>
				
				<programlisting language="shell">ant example-swing-appframework</programlisting>
				
				<para>
					This is a self-executing JAR. For convenience, it has <filename>MAINFEST.MF</filename> dependencies hard-wired into it to
					<filename>..\..\metawidget.jar</filename> and <filename>lib\AppFramework.jar</filename> among others, so it's best not to move
					it to a different folder (if you do, you'll need to manually put those JARs on your classpath).
				</para>
				
				<para> 
					Run the code by navigating to the <filename>examples\swing</filename> folder and typing:
				</para>				
				
				<programlisting language="shell">java -jar appframework-swing.jar</programlisting>
				
				<para>
					The opening screen displays two fields to allow you to enter the make and type of a car. You can also optionally
					add an owner by clicking the <guibutton>Add an Owner</guibutton> button, or save the car using the <guibutton>Save</guibutton>
					button.
				</para>
				
				<para>
					The <guibutton>Add an Owner</guibutton> button is generated by Metawidget based on the <function>addOwner</function> method
					in the <classname>Car</classname> class (which has been annotated <classname>@org.jdesktop.application.Action</classname>). The
					<guibutton>Save</guibutton> button is generated based on the <function>save</function> method in the <classname>CarApplication</classname>
					class (also annotated <classname>@Action</classname>). Two different Metawidgets are used in the example: one pointed
					at the <classname>Car</classname> class, the other at the <classname>CarApplication</classname> class.
				</para>
				
				<para>
					Metawidget supports pluggable 'action styles'. The use of Swing AppFramework is configured
					per <classname>Inspector</classname>, as in <filename>examples/src/java/org/metawidget/example/swing/appframework/inspector-config.xml</filename>
					from the source distribution:
				</para>

				<programlisting language="xml">&lt;metawidgetAnnotationInspector config="org.metawidget.inspector.impl.BaseObjectInspectorConfig"&gt;
	&lt;actionStyle&gt;
		org.metawidget.inspector.impl.actionstyle.swing.SwingAppFrameworkActionStyle
	&lt;/actionStyle&gt;
&lt;/metawidgetAnnotationInspector&gt;</programlisting>

				<para>
					As a further feature, after the <guibutton>Add an Owner</guibutton> button is clicked it disappears. This is
					acheived by using <classname>JexlInspector</classname> to introduce an expression language for Swing similar to JSP's EL.
					The method is annotated...
				</para>
				
				<programlisting language="java">@Action( name = "add" )
@UiJexlAttribute( name = HIDDEN, value = "${this.owner != null}" )
public void addOwner() {
	mOwner = new Owner();
	fireActionEvent( "addOwner" );
}</programlisting>
				
				<para>
					...such that the button gets hidden when the car has an owner.
				</para>
				
			</section>

			<section id="section-introduction-part3-scala">
				<title>Scala Example</title>
	
				<para>
					The Scala Animal Races Example demonstrates using SwingMetawidget together with Scala and MigLayout.
				</para>
	
				<para>
					The application is pre-built for you in <filename>examples\swing\animalraces-swing.jar</filename> or, if you've downloaded
					the source code distribution, you can build it yourself by typing:
				</para>
				
				<programlisting language="shell">ant example-swing-animalraces</programlisting>
				
				<para>
					This is a self-executing JAR. For convenience, it has <filename>MAINFEST.MF</filename> dependencies hard-wired into it to
					<filename>..\..\metawidget.jar</filename> and <filename>lib\scala-library.jar</filename> among others, so it's best not to move
					it to a different folder (if you do, you'll need to manually put those JARs on your classpath).
				</para>
				
				<para> 
					Run the code by navigating to the <filename>examples\swing</filename> folder and typing:
				</para>				
				
				<programlisting language="shell">java -jar animalraces-swing.jar</programlisting>
				
				<para>
					The screen displays fields to allow you to change the name, speed and type of each animal as well buttons
					to start and stop the race.
				</para>
				
				<figure id="section-introduction-part3-scala-screenshot">
					<title>Scala and MigLayout with Metawidget</title>
					<screenshot>
						<graphic fileref="../shared/images/desktop-animalraces.jpg" width="100mm" />
					</screenshot>
				</figure>

				<para>
					Animal Races whimsical User Interface demonstrates how Metawidget's goal of not 'owning' the UI allows multiple
					Metawidgets to be combined in unconventional ways. There are three Metawidgets across the top (one for each animal in
					the race), and a fourth Metawidget for the buttons at the bottom.
				</para>
				
				<para>
					The top three Metawidgets all use MigLayout. Because Metawidget does not hide the underlying UI framework, using
					MigLayout allows the Animal Races code to easily pad the Metawidget: 
				</para>

				<programlisting language="java">metawidget.setLayoutClass( MigLayout.class );
metawidget.setToInspect( animal );
((MigLayout) metawidget.getLayout()).setLayoutConstraints( new LC().insets( "10" ));</programlisting>

				<para>
					The Animal Races code is written purely in Scala, located at
					<filename>examples/src/scala/org/metawidget/example/swing/animalraces/AnimalRaces.scala</filename>. It uses
					<classname>BeanUtilsBinding.PROPERTYSTYLE_SCALA</classname> to allow Metawidget to inspect Scala-based business objects: 
				</para>
				
				<programlisting language="scala">val metawidget = new SwingMetawidget()
metawidget.setPropertyBindingClass( classOf[ BeanUtilsBinding ])
metawidget.setParameter( "propertyStyle", BeanUtilsBinding.PROPERTYSTYLE_SCALA )
metawidget.setToInspect( animal )</programlisting>

			</section>

		</section>

		<section id="section-introduction-part4-conclusion">
			<title>Conclusion</title>
			
			<para>
				That concludes the introductory tutorial. In summary, we now:
			</para>

			<itemizedlist>
				<listitem>
					<para>
						have seen how to build an application whose UI is largely dictated by its business classes, not by hand-written UI code
					</para>
				</listitem>
				<listitem>
					<para>
						significantly reduced the amount of UI code needed in our applications
					</para>
				</listitem>
				<listitem>
					<para>
						have seen how to build an application that targets multiple platforms. If we were to add a new field to one of the business classes
						(say, <parameter>numberOfChildren</parameter> to <classname>PersonalContact</classname>), it would automatically appear
						and be functional on every platform.
					</para>
				</listitem>
			</itemizedlist>
			
		</section>

	</chapter>

	<chapter id="chapter-architecture">
		<title>Architecture</title>
		
		<section id="section-architecture-preface">
			<title>Preface</title>

			<para>
				There is a large diversity of front-end and back-end technologies. Metawidget strives to unify this
				diversity with two over-arching concepts: Metawidgets that create widgets for
				specific front-end frameworks (<classname>SwingMetawidget</classname>, <classname>UIMetawidget</classname>, etc.) and Inspectors that
				inspect specific back-end architectures (<classname>PropertyTypeInspector</classname>, <classname>JpaInspector</classname>, etc.).
			</para>
			
		</section>
		
		<section id="section-architecture-metawidgets">
			<title>Metawidgets</title>

			<section id="section-architecture-metawidgets-interface">
				<title>Interface</title>
				
				<para>
					Most UI frameworks require widgets inherit one of their base classes, such as <classname>javax.swing.JComponent</classname>
					or <classname>javax.faces.UIComponent</classname>. As Java does not support multiple inheritance, this means there cannot be
					a common 'Metawidget base class' per se.
				</para>
				
				<para>
					In addition, all Metawidgets support roughly the same functionality but different UI frameworks have different in-built capabilities.
					For example, JSF has <function>UIComponent.setRenderer</function> for choosing different layouts
					for the same widget, whereas <classname>SwingMetawidget</classname> has to roll its own <function>setLayout</function> method.
					This means there cannot be a common 'Metawidget interface' either.
				</para>
				
				<para>
					Therefore, Metawidgets are not required to extend any base class or implement any interface. However, they all follow roughly the
					same design, with roughly the same method names:
				</para>
				
				<orderedlist>
					<listitem>
						<para>
							<function>setToInspect</function> is called to set the Object for inspection
						</para>
					</listitem>
					<listitem>
						<para>
							<function>buildWidgets</function> is called to begin the process. It first calls <function>Inspector.inspect</function> to return
							a DOM of inspection results
						</para>
					</listitem>
					<listitem>
						<para>							
							<function>buildWidgets</function> calls <function>buildWidget</function> to choose a suitable widget for the
							top-level element of the DOM (based on its <parameter>@type</parameter> attribute). If <function>buildWidget</function>
							returns such a widget, or <parameter>null</parameter>, skip to 6
						</para>
					</listitem>
					<listitem>
						<para>							
							if <function>buildWidget</function> returns another Metawidget for the top-level element, ignore it (as that would lead
							to infinite recursion), but treat it as a trigger to call <function>buildCompoundWidget</function>
						</para>
					</listitem>
					<listitem>
						<para>							
							<function>buildCompoundWidget</function> iterates over each child of the top-level DOM element, calling <function>buildWidget</function> for
							each. The returned widget is added to the Metawidget. It is fine at this stage for <function>buildWidget</function> to return another
							Metawidget, as this is how nested Metawidgets get created
						</para>
					</listitem>
					<listitem>
						<para>
							widget creation can be overridden if there are existing child widgets with suitably matching attributes
						</para>
					</listitem>
					<listitem>
						<para>
							as a final step, the created widgets are passed to a layout and/or binding mechanism. Layout and binding can be configured by
							arbitrary parameters passed through the Metawidget to the layout/binding. Layouts can further by adorned with facet widgets
							passed through the Metawidget.    
						</para>
					</listitem>
				</orderedlist>
				
				<para>
					For those looking to write their own Metawidget (say, for a currently unsupported platform) there is a
					<classname>MetawidgetMixin</classname> class that implements the above steps 2-6 for you, see <xref linkend="section-metawidgets-implementing-your-own-mixin"/>.
					All of the supplied Metawidgets are implemented using this class.
				</para>
				
			</section>
			
			<section id="section-architecture-metawidgets-look">
				<title>Customizing Look and Feel</title>

				<para>
					As much as possible, Metawidgets defer to the existing Look and Feel technology of their target UI framework. For example,
					<classname>HtmlMetawidget</classname> uses HTML/CSS, <classname>SwingMetawidget</classname> uses Swing Look-and-Feels,
					and <classname>AndroidMetawidget</classname> uses Android styles and themes.
				</para>
				
				<para>
					The one area Metawidget <emphasis>does</emphasis> control is how the widgets it creates are laid out. Typically this is in
					a tabular 'one column for the label, one column for the widget' format, but this is pluggable.
				</para>
				
				<para>
					Metawidgets come with different <classname>Layout</classname> classes (<classname>LayoutRenderer</classname> classes
					for JSF) that can arrange the widgets in different ways, and these are set on the Metawidget in a framework-specific
					way. For example, JSF uses <parameter>&lt;m:metawidget rendererType=""&gt;</parameter> whereas <classname>SwingMetawidget</classname>
					uses <function>setLayoutClass</function>. Where possible, the layout classes defer back to the capabilities
					of the native framework. For example, Swing's <classname>GroupLayout</classname> or Android's <classname>TableLayout</classname>.
				</para>
				
				<para>
					Some layouts will add localized labels and section headings to the widgets, whereas other layouts may leave them unadorned. Different
					Layouts may support different parameters (for example, a <classname>TableLayout</classname> may support <parameter>numberOfColumns</parameter>)
					and these are passed from the Metawidget to the layout in a generic fashion. For example, JSF uses <parameter>&lt;f:param name="" value=""&gt;</parameter>
					tags, whereas <classname>SwingMetawidget</classname> has a <function>setParameter(name, value)</function> method.
				</para>
				
			</section>
			
			<section id="section-architecture-metawidgets-override">
				<title>Overriding Widget Creation</title>

				<para>
					Metawidget tries to automate much of the widget creation, but provides many hooks to customize the process:
				</para>
				
				<itemizedlist>
					<listitem>
						<para>
							<emphasis role="bold">stub</emphasis> child widgets can be used to suppress widget creation entirely or to
							replace automatic widget creation with one or more other widgets with different bindings 
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis role="bold">layouts</emphasis> are pluggable 
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis role="bold">parameters</emphasis> set on a Metawidget pass through to the chosen
							layout to configure settings such as <parameter>sectionStyle</parameter> and
							<parameter>numberOfColumns</parameter>
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis role="bold">facet</emphasis> child widgets pass through to the chosen layout
							as decorations (such as button bars)
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis role="bold">subclasses</emphasis> can override key methods such as <function>buildWidget</function>
							to fine-tune widget creation
						</para>
					</listitem>
				</itemizedlist>
				
			</section>
		</section>
		
		<section id="section-architecture-inspectors">
			<title>Inspectors</title>

			<section id="section-architecture-inspectors-interface">
				<title>Interface</title>

				<para>
					All Inspectors must implement the <classname>Inspector</classname> interface. This is a simple
					interface that defines only one method:
				</para>
				
				<programlisting language="java">String inspect( Object toInspect, String type, String... names );</programlisting>
				
			</section>
			
		</section>
	</chapter>

	<chapter id="chapter-metawidgets">
		<title>Metawidgets</title>
		
		<section id="section-metawidgets-preface">
			<title>Preface</title>

			<para>
				Metawidget ships with native widgets for different UI frameworks. Whilst all Metawidget widgets are
				broadly similar, they are tailored to take advantage of their native environment. This chapter examines
				each Metawidget widget in detail.
			</para>
			
		</section>

		<section id="section-metawidgets-desktop">
			<title>Desktop Metawidgets</title>

			<section id="section-metawidgets-desktop-swing">
				<title>SwingMetawidget</title>
	
				<para>
					<classname>SwingMetawidget</classname> is a Swing component. For an introduction
					to <classname>SwingMetawidget</classname>, see <xref linkend="section-introduction-part1"/>
					and <xref linkend="section-introduction-part2-desktop"/>.
				</para>
	
				<section id="section-metawidgets-desktop-swing-installation">
					<title>Installation</title>

					<para>
						There are two steps to installing <classname>SwingMetawidget</classname> within a Swing application:
					</para>
					
					<orderedlist>
						<listitem>
							<para>
								Add <filename>metawidget.jar</filename> to your <parameter>CLASSPATH</parameter>.
							</para>
						</listitem>
						<listitem>
							<para>
								Add an <filename>inspector-config.xml</filename> to your <parameter>CLASSPATH</parameter> (or you may prefer
								to configure the Metawidget programmatically, as detailed in <xref linkend="section-introduction-part1"/>).
							</para>
						</listitem>
					</orderedlist>
					
				</section>
				
				<section id="section-metawidgets-desktop-swing-propertybinding">
					<title>Property Binding</title>
					
					<para>
						Swing does not include an automatic <classname>JComponent</classname> to <classname>Object</classname> binding mechanism, but Metawidget
						supports third-party alternatives via <function>setPropertyBindingClass</function>.
					</para>
					
					<section id="section-metawidgets-desktop-swing-binding-beansbinding">
						<title>Beans Binding</title>
						
						<para>
							<classname>org.metawidget.swing.propertybinding.beansbinding.BeansBinding</classname> supports the various Beans Binding
							update strategies by calling <function>metawidget.setParameter( UpdateStrategy.class, UpdateStrategy.READ_WRITE )</function>.
							If set to <parameter>READ</parameter> or <parameter>READ_WRITE</parameter>, the object being inspected must
							provide <classname>PropertyChangeSupport</classname>.
						</para>
					</section>
				
				</section>
	
				<section id="section-metawidgets-desktop-swing-actionbinding">
					<title>Action Binding</title>
					
					<para>
						Swing supplies <code>javax.swing.Action</code> for binding <classname>JButtons</classname> to backing classes, and this is
						typically combined with Java-based reflection to support runtime binding. This is exactly what the default action binding,
						<classname>ReflectionBinding</classname>, does.
					</para>
					
					<para>
						However, Metawidget makes action bindings pluggable to support other use cases. In particular, use cases where there
						<emphasis>is</emphasis> no backing class, and instead the <classname>JButton</classname> should invoke, say, an RPC
						call. Implement your own pluggable binding by extending <classname>BaseActionBinding</classname> and use it by calling:
					</para>
					
					<programlisting language="java">myMetawidget.setActionBindingClass( myActionBinding.class );</programlisting>
										
				</section>

				<section id="section-metawidgets-desktop-swing-look">
					<title>Customizing Look and Feel</title>
					
					<para>
	 					Since inception, Swing has had built-in, and extensive, Look and Feel support. Metawidget
						does not overlap this. For layouts, Swing supports a multitude of <classname>LayoutManagers</classname>.
						Metawidget leverages these, but automates them to construct UIs automatically.
					</para>
					
				</section>
				
			</section>
		</section>
		
		<section id="section-metawidgets-web">
			<title>Web Metawidgets</title>
		
			<section id="section-metawidgets-web-hidden">
				<title>Hidden Fields</title>
				
				<para>
					Many Web applications store their data at the <classname>HttpServletRequest</classname> level, not at the
					<classname>HttpSession</classname> level. Using session-level state (or, ideally, a UI framework that supports some
					kind of 'conversation'-level state) is safer than passing variables to and from the client in hidden HTML fields. However, Web
					Metawidgets support that approach for those that need it through <function>setCreateHiddenFields( true )</function>.
				</para>
			</section>
								
			<section id="section-metawidgets-web-gwt">
				<title>GwtMetawidget</title>
	
				<para>
					<classname>GwtMetawidget</classname> is a client-side, JavaScript widget for GWT. Despite the limitations of the
					JavaScript environment, it supports reflection, annotations, pluggable layouts and data binding. For an introduction
					to <classname>GwtMetawidget</classname>, see <xref linkend="section-introduction-part2-web"/> and 
					<xref linkend="section-introduction-part3-gwt-hosted"/>.
				</para>
				
				<section id="section-metawidgets-web-gwt-installation">
					<title>Installation</title>
					
					<para>
						There are five steps to installing Metawidget within a GWT application:
					</para>
					
					<orderedlist>
						<listitem>
							<para>
								Update the application's <filename>.gwt.xml</filename> module to include Metawidet:
							</para>
							<programlisting language="xml">&lt;module&gt;								
	&lt;inherits name="org.metawidget.GwtMetawidget" /&gt;
	...
&lt;/module&gt;</programlisting>
						</listitem>
						<listitem>
							<para>
								Include both <filename>metawidget.jar</filename> <emphasis>and</emphasis> <filename>examples\gwt\metawidget-gwt-client.jar</filename>
								in the <parameter>CLASSPATH</parameter> during the GWTCompiler phase. This provides the <classname>GwtMetawidget</classname> component.
							</para>
						</listitem>
						<listitem>
							<para>
								Add <filename>metawidget.jar</filename> into <filename>WEB-INF/lib</filename>. This provides the <classname>GwtRemoteInspectorImpl</classname> servlet.
							</para>
						</listitem>
						<listitem>						
							<para>
								Update the application's <filename>web.xml</filename> to include <classname>GwtRemoteInspectorImpl</classname>:
							</para>							
							<programlisting language="xml">&lt;web-app&gt;
	...
	&lt;servlet&gt;
		&lt;servlet-name&gt;metawidget-inspector&lt;/servlet-name&gt;
		&lt;servlet-class&gt;
			org.metawidget.inspector.gwt.remote.server.GwtRemoteInspectorImpl
		&lt;/servlet-class&gt;
	&lt;/servlet&gt;

	&lt;servlet-mapping&gt;
		&lt;servlet-name&gt;metawidget-inspector&lt;/servlet-name&gt;
		&lt;url-pattern&gt;/metawidget-inspector&lt;/url-pattern&gt;
	&lt;/servlet-mapping&gt;
&lt;/web-app&gt;</programlisting>
						</listitem>
						<listitem>
							<para>
								Add an <filename>inspector-config.xml</filename> into <filename>WEB-INF</filename>. Or, if you're running under the
								GWT Development Shell, add an <filename>inspector-config.xml</filename> to the root of a <parameter>CLASSPATH</parameter> entry.
							</para>
						</listitem>
					</orderedlist>
					
					<para>
						A working example of all five steps can be found in <filename>addressbook-gwt.war</filename> included in the binary
						distribution. You may also find the <filename>example-gwt-addressbook</filename> Ant task in the source
						distribution's <filename>build.xml</filename> useful.
					</para>
					
				</section>
				
				<section id="section-metawidgets-web-gwt-reflection">
					<title>Reflection and Annotations</title>
					
					<para>
						<classname>GwtMetawidget</classname> leverages Metawidget's separate <classname>Inspector</classname>/renderer
						architecture and AJAX to perform server-side inspection as in <xref linkend="section-metawidgets-web-gwt-inspection"/>. This
						allows <classname>GwtMetawidget</classname> to reflect properties and inspect annotations of business
						objects, even though JavaScript	supports neither.
					</para>
					
					<figure id="section-metawidgets-web-gwt-inspection">
						<title>GwtMetawidget uses AJAX to perform server-side inspection</title>			
						<mediaobject>
							<imageobject>
								<imagedata fileref="../shared/images/metawidget-gwt-inspection.jpg"/>
							</imageobject>
						</mediaobject>
					</figure>
					
					<para>
						The process is:
					</para>

					<orderedlist>
						<listitem>
							<para>
								instantiate the business object on the client-side as normal (ie. as JavaScript)
							</para>
						</listitem>
						<listitem>
							<para>
								give the business object to <classname>GwtMetawidget</classname> (a client-side, JavaScript GWT Widget)
							</para>
						</listitem>
						<listitem>
							<para>
								<classname>GwtMetawidget</classname> uses AJAX to pass the business object to the server
							</para>
						</listitem>
						<listitem>
							<para>
								the server, using Java, runs all the <classname>Inspector</classname>s (including reflection and annotations)
							</para>
						</listitem>
						<listitem>
							<para>
								the server returns the inspection results as an XML document
							</para>
						</listitem>
						<listitem>
							<para>
								<classname>GwtMetawidget</classname> uses JavaScript to render the HTML widgets
							</para>
						</listitem>
					</orderedlist>
					
					<para>
						Note that steps 3 and 5 (the AJAX call to and from the server) are the most costly in terms of performance. Techniques
						to improve GWT performance are discussed in <xref linkend="section-performance-rebind"/>. 
					</para>

				</section>
				
				<section id="section-metawidgets-web-gwt-pluggability">
					<title>Pluggability</title>
					
					<para>
						Like other Metawidgets, <classname>GwtMetawidget</classname> supports pluggable inspectors, layout managers and binding
						implementations. However, the other Metawidgets do this using <function>Class.newInstance</function>, which
						JavaScript does not support.						
					</para>
					
					<para>
						Instead, <classname>GwtMetawidget</classname> supplies GWT <classname>Generators</classname> in the form of
						<classname>org.metawidget.gwt.generator.FactoryGenerator</classname>. At compile-time, each generator scans all the classes included in the
						application and statically generates code to instantiate them. This is transparent to the application code,
						which can simply do:
					</para>
					
					<programlisting language="java">metawidget.setLayoutClass( TableLayout.class )</programlisting>
					
				</section>
				
				<section id="section-metawidgets-web-gwt-propertybinding">
					<title>Property Binding</title>
					
					<para>
						Like most other Metawidgets, <classname>GwtMetawidget</classname> supports property binding. Property binding
						generally requires reflection, and GWT recommends using <classname>Generators</classname> to achieve this. As of GWT
						1.5, however, much of the burden of implementation rests on the developer.
					</para>
					
					<para>
						<classname>GwtMetawidget</classname> automates this burden by supplying a <classname>SimpleBinding</classname>
						implementation. This implementation is pluggable, so may be swapped out as and when later releases of GWT
						more fully support data binding.
					</para>
					
					<para>
						<classname>SimpleBinding</classname> expects every domain object to be wrapped with a <classname>SimpleBindingAdapter</classname>.
						The supplied <classname>SimpleBindingAdapterGenerator</classname> automates this process. To configure it, add the following
						to the <filename>application-name.gwt.xml</filename> file...
					</para>
					
					<programlisting language="xml">&lt;generate-with
	class="org.metawidget.gwt.generator.propertybinding.simple.SimpleBindingAdapterGenerator"&gt;
	&lt;when-type-assignable class="org.metawidget.example.shared.addressbook.model.Contact"/&gt;
&lt;/generate-with&gt;</programlisting>

					<para>
						...and in the application code...
					</para>
					
					<programlisting language="java">metawidget.setPropertyBindingClass(SimpleBinding.class);
SimpleBindingAdapter&lt;Contact&gt; adp = (SimpleBindingAdapter&lt;Contact&gt;) GWT.create(Contact.class);
SimpleBinding.registerAdapter( Contact.class, adp );</programlisting>					
					
				</section>
				
				<section id="section-metawidgets-web-gwt-actionbinding">
					<title>Action Binding</title>
					
					<para>
						GWT supplies <code>com.google.gwt.user.client.ui.ClickListener</code> for binding <classname>Buttons</classname> to backing
						classes. It is futher possible to combine this with a little JSNI trickery to support runtime binding. This is exactly what
						the default action binding, <classname>JsniBinding</classname>, does.
					</para>
					
					<para>
						However, Metawidget makes action bindings pluggable to support other use cases. In particular, use cases where there
						<emphasis>is</emphasis> no backing class, and instead the <classname>Button</classname> should invoke, say, an RPC
						call. Implement your own pluggable binding by extending <classname>BaseActionBinding</classname> and use it by calling...
					</para>
					
					<programlisting language="java">myMetawidget.setActionBindingClass( myActionBinding.class );</programlisting>
					
					<para>
						...which overrides the default <classname>JsniBinding</classname>. Behind the scenes, <classname>GwtMetawidget</classname>
						has a <classname>FactoryGenerator</classname> which takes care of generating JavaScript code to
						instantiate your <classname>ActionBinding</classname>.
					</para>					
										
				</section>
				
				<section id="section-metawidgets-web-gwt-client-side-inspection">
					<title>Client-Side Inspection</title>
					
					<para>
						As noted in <xref linkend="section-metawidgets-web-gwt-reflection"/> by default <classname>GwtMetawidget</classname> uses
						server-side Inspectors. This allows the full power of Java-based reflection but carries the performance cost of an AJAX call.
						This cost can be mitigated by using rebinding (see <xref linkend="section-performance-rebind"/>), but there is
						another way: inspection can be performed <emphasis>client-side</emphasis>, with no AJAX calls.
					</para>
					
					<para>
						Setting up a client-side <classname>Inspector</classname> is very easy. The default <classname>GwtMetawidget</classname>
						<classname>Inspector</classname> is <classname>GwtRemoteInspectorProxy</classname>, which is itself a client-side
						<classname>Inspector</classname> (one that makes a remote call to <classname>GwtRemoteInspectorImpl</classname>). To
						replace this default, simply implement your own <classname>Inspector</classname>:
					</para>
					
					<programlisting language="java">public class MyClientSideInspector
	implements Inspector {
	public String inspect( Object toInspect, String type, String... names )
		throws InspectorException {
		return ...some XML string...
	}
}</programlisting>					

					<para>
						Make sure this <classname>Inspector</classname> is located under the <filename>client</filename> folder of your GWT application
						so that it is compiled by the GWTCompiler into JavaScript. Use this <classname>Inspector</classname> by doing...
					</para>

					<programlisting language="java">myGWTMetawidget.setInspectorClass( MyClientSideInspector.class )</programlisting>
					
					<para>
						...which overrides the default <classname>GwtRemoteInspectorProxy</classname>. Behind the scenes, <classname>GwtMetawidget</classname>
						has a <classname>FactoryGenerator</classname> which takes care of generating JavaScript code to
						instantiate your inspector.
					</para>
					
					<para>
						That's it! Of course, JavaScript-based inspection is severely limited compared to Java-based inspection, but you may
						be able to find tricks that work for your environment. For example, you can try...
					</para>
					
					<programlisting language="java">for( var property in myObject ) { alert( myObject[property] ); }</programlisting>					

					<para>
						...or perhaps you already have the XML you need available somewhere else in your client-side code.
					</para>

				</section>
				
			</section>

			<section id="section-metawidgets-web-faces">
				<title>UIMetawidget (JSF)</title>
	
				<para>
					<classname>UIMetawidget</classname> is a Java Server Faces component. For an introduction
					to <classname>UIMetawidget</classname>, see <xref linkend="section-introduction-part2-web"/> 
					and <xref linkend="section-introduction-part3-seam"/>. 
				</para>
	
				<section id="section-metawidgets-web-faces-installation">
					<title>Installation</title>

					<para>
						There are three steps to installing <classname>UIMetawidget</classname> within a JSF application:
					</para>
					
					<orderedlist>
						<listitem>
							<para>
								Add <filename>metawidget.jar</filename> into <filename>WEB-INF/lib</filename>.
							</para>
						</listitem>
						<listitem>
							<para>
								Add an <filename>inspector-config.xml</filename> into <filename>WEB-INF</filename>.
							</para>
						</listitem>
						<listitem>
							<para>
								Add a tag library descriptor to the top of your JSP page...
							</para>
							<programlisting language="xml">&lt;%@ taglib uri="http://metawidget.org/faces" prefix="m" %&gt;
	...
	&lt;m:metawidget value="#{foo}"/&gt;
	...</programlisting>
							<para>
								...or Facelets page...
							</para>
							<programlisting language="xml">&lt;ui:composition xmlns="http://www.w3.org/1999/xhtml"
	...
	xmlns:m="http://metawidget.org/faces"&gt;
	...
	&lt;m:metawidget value="#{foo}"/&gt;
	...</programlisting>
						</listitem>
					</orderedlist>
					
				</section>

				<section id="section-metawidgets-web-faces-look">
					<title>Customizing Look and Feel</title>
					
					<para>
						One of JSF's most important Look and Feel technologies is CSS.
						Metawidget supports several approaches to suit different needs.
					</para>
					
					<para>
						By convention, JSF's HTML widgets (<classname>HtmlInputText</classname>, <classname>HtmlSelectBooleanCheckbox</classname>, etc) define
						<parameter>style</parameter> and <parameter>styleClass</parameter> attributes for applying CSS styles and classes to their output.
						<classname>HtmlMetawidget</classname> follows this convention. When expanding to a single widget (such as an
						<classname>HtmlInputText</classname>) the CSS styles are applied to it. When expanding to multiple widgets,
						<emphasis>all</emphasis> widgets have the same CSS styles applied to them.
					</para>
					
					<para>
						Another important JSF Look and Feel technology is Renderers. Whilst
						often Renderers are discussed in the context of rendering the same widget to different
						platforms (eg. HTML or WML), they can equally be used to render the same widget to the same
						platform but in different layouts.
					</para>
					
					<para>
						<classname>HtmlTableLayoutRenderer</classname> is the default <classname>LayoutRenderer</classname>. It further
						defines parameters such as <parameter>tableStyle</parameter>,
						<parameter>labelStyle</parameter> and <parameter>columnStyleClasses</parameter> parameters (see the
						JavaDoc for a complete list). The latter is a comma separated list of CSS style classes to be applied to table columns. The first style
						class is the label column, the second the widget column, and the third the 'required' column.
						Further style classes may be used for multi-column layouts. You can	get quite far using, for example:
					</para>
	
					<programlisting language="css">.table-component-column input { width: 100%; }</programlisting>
					
					<para>
						..this approach has the advantage of automatically applying to every widget,
						so overridden widgets do not have to explicitly set styleClass information.
						However, not all Web browsers support fine-grained CSS selectors such as...
					</para>
					
					<programlisting language="css">.table-component-column input[type="button"] { width: auto; }</programlisting>
					
					<para>
						...in which case it may be better to switch to using <parameter>styleClass</parameter> on <classname>HtmlMetawidget</classname> itself.
					</para>
					
					<para>
						Other supplied <classname>LayoutRenderer</classname>s include <parameter>div</parameter> and <parameter>simple</parameter> (see
						the JavaDoc, and the <filename>META-INF/faces-config.xml</filename> in <filename>metawidget.jar</filename> for a
						complete list).
					</para>
					
				</section>
				
				<section id="section-metawidgets-web-faces-validation">
					<title>Validation</title>
					
					<para>
						By default, <classname>UIMetawidget</classname> uses <classname>StandardValidator</classname>, which adds <parameter>required</parameter>,
						<classname>RangeValidator</classname> and <classname>LengthValidator</classname> to all widgets.
					</para>
					
					<para>
						You can implement your own validators by extending <classname>org.metawidget.faces.component.validator.Validator</classname>, or
						disable validation by setting <parameter>validatorClass=""</parameter>.
					</para>
					
				</section>
				
				<section id="section-metawidgets-web-faces-override">
					<title>Overriding Widget Creation</title>
					
					<para>
						<classname>HtmlMetawidget</classname> supports child widgets. If
						the child widgets have the same <parameter>value</parameter>
						attribute binding as #TODO#
					</para>
					
					<para>
						Sometimes you may need to override a widget with one that
						uses a different <parameter>value</parameter> binding. Or, you may need to override a widget but alter its
						metadata (such as its <parameter>label</parameter>) #TODO#
					</para>
					
					<para>
	 					Finally, for advanced use cases, it is straightforward to subclass <classname>HtmlMetawidget</classname> and fine-tune widget
	 					creation and initialization. First, create a class that extends <classname>HtmlMetawidget</classname> and override its
	 					<function>buildActiveWidget</function> method:
					</para>
					
					<programlisting language="java">public class MyMetawidget extends HtmlMetawidget {
	...
	protected UIComponent buildActiveWidget( Map&lt;String, String&gt; attributes,
		Application application ) {
		String type = attributes.get( TYPE );
		...
		Class clazz = ClassUtils.niceForName( type );

		if ( Date.class.isAssignableFrom( clazz ) )
		{
			DateControl control = (DateControl) application.createComponent(
				"my.DateControl" );
			control.setSomeParameters( ... );
			return control;
		}
		...
	}
}</programlisting>
	
					<para>
						Then update <filename>faces-config.xml</filename> to use this class for every Metawidget tag:
					</para>
					
					<programlisting language="xml">&lt;component&gt;
	&lt;component-type&gt;org.metawidget.HtmlMetawidget&lt;/component-type&gt;
	&lt;component-class&gt;com.foo.MyMetawidget&lt;/component-class&gt;
&lt;/component&gt;</programlisting>
	
					<para>
						This will automatically update every screen across the entire application, which is a great way to easily update
						an application to use a new widget library, or to incorporate custom tags (such as Facelets tag files). See
						<classname>RichFacesMetawidget</classname> for an example.
					</para>
					
				</section>

				<section id="section-metawidgets-web-faces-defaults">
					<title>Setting Global Defaults</title>
					
					<para>
						If you find yourself setting the same attributes and parameters on every Metawidget tag, consider subclassing
						<classname>HtmlMetawidget</classname> and setting the defaults there:
					</para>
					
					<programlisting language="java">public class MyDefaultedMetawidget extends HtmlMetawidget {
	...
	public MyDefaultedMetawidget() {
		getAttributes().put( "styleClass", "myStyleClass" );
		setValidatorClass( ... );
	}

	public void encodeBegin( FacesContext context )	{
		if ( FacesUtils.findParameterWithName( this, "tableStyleClass" ) == null ) {
			UIParameter parameter = new UIParameter();
			parameter.setName( "tableStyleClass" );
			parameter.setValue( "table-style" );
			getChildren().add( parameter );
		}
		
		super.encodeBegin( context );
	}
}</programlisting>
					
				</section>
				
			</section>
			
			<section id="section-metawidgets-web-spring">
				<title>SpringMetawidget</title>
	
				<para>
					<classname>SpringMetawidget</classname> is a Spring taglib. For an introduction
					to <classname>SpringMetawidget</classname>, see <xref linkend="section-introduction-part2-web"/>.
				</para>

				<section id="section-metawidgets-web-spring-installation">
					<title>Installation</title>

					<para>
						There are three steps to installing <classname>SpringMetawidget</classname> within a Spring application:
					</para>
					
					<orderedlist>
						<listitem>
							<para>
								Add <filename>metawidget.jar</filename> into <filename>WEB-INF/lib</filename>.
							</para>
						</listitem>
						<listitem>
							<para>
								Add an <filename>inspector-config.xml</filename> into <filename>WEB-INF</filename>.
							</para>
						</listitem>
						<listitem>
							<para>
								Add a tag library descriptor to the top of your JSP page:
							</para>
							<programlisting language="xml">&lt;%@ taglib uri="http://metawidget.org/spring" prefix="m" %&gt;
	...
	&lt;m:metawidget value="#{foo}"/&gt;
	...</programlisting>
						</listitem>
					</orderedlist>
				</section>

				<section id="section-metawidgets-web-spring-look">
					<title>Customizing Look and Feel</title>
					
					<para>
						JSP-based technologies do not distinguish between what a widget is versus how it is rendered.
						Instead, <classname>SpringMetawidget</classname> mimics this by providing loosely coupled <classname>Layout</classname> classes.
						Each layout can further be configured by using specific <parameter>param</parameter> tags.
					</para>
					
				</section>
				
				<section id="section-metawidgets-web-spring-override">
					<title>Overriding Widget Creation</title>				

					<para>
						With regard to overriding widget creation, JSP-based technologies such as Spring lack some component-based features.
						Specifically, whilst it is possible for JSP	tags to reference their <emphasis>parent</emphasis> (using <function>TagSupport.findAncestorWithClass</function>),
						they have no way to enumerate their <emphasis>children</emphasis>. Therefore, it is not possible to
						directly support arbitrary child tags within <classname>SpringMetawidgetTag</classname>. As a next best thing, Metawidget includes
						<classname>StubTag</classname> for wrapping arbitrary tags. It also supports wrapping arbitrary HTML.
					</para>
					
				</section>

			</section>

			<section id="section-metawidgets-web-struts">
				<title>StrutsMetawidget</title>
	
				<para>
					<classname>StrutsMetawidget</classname> is a Struts taglib. For an introduction
					to <classname>StrutsMetawidget</classname>, see <xref linkend="section-introduction-part2-web"/>.
				</para>

				<section id="section-metawidgets-web-struts-installation">
					<title>Installation</title>

					<para>
						There are three steps to installing <classname>StrutsMetawidget</classname> within a Struts application:
					</para>
					
					<orderedlist>
						<listitem>
							<para>
								Add <filename>metawidget.jar</filename> into <filename>WEB-INF/lib</filename>.
							</para>
						</listitem>
						<listitem>
							<para>
								Add an <filename>inspector-config.xml</filename> into <filename>WEB-INF</filename>.
							</para>
						</listitem>
						<listitem>
							<para>
								Add a tag library descriptor to the top of your JSP page:
							</para>
							<programlisting language="xml">&lt;%@ taglib uri="http://metawidget.org/struts" prefix="m" %&gt;
	...
	&lt;m:metawidget value="#{foo}"/&gt;
	...</programlisting>
						</listitem>
					</orderedlist>
				</section>

				<section id="section-metawidgets-web-struts-look">
					<title>Customizing Look and Feel</title>
					
					<para>
						JSP-based technologies do not distinguish between what a widget is versus how it is rendered.
						Instead, <classname>StrutsMetawidget</classname> mimics this by providing loosely coupled <classname>Layout</classname> classes.
						Each layout can further be configured by using specific <parameter>param</parameter> tags.
					</para>
					
				</section>
				
				<section id="section-metawidgets-web-struts-override">
					<title>Overriding Widget Creation</title>				

					<para>
						With regard to overriding widget creation, JSP-based technologies such as Struts lack some component-based features.
						Specifically, whilst it is possible for JSP	tags to reference their <emphasis>parent</emphasis> (using <function>TagSupport.findAncestorWithClass</function>),
						they have no way to enumerate their <emphasis>children</emphasis>. Therefore, it is not possible to
						directly support arbitrary child tags within <classname>SpringMetawidgetTag</classname>. As a next best thing, Metawidget includes
						<classname>StubTag</classname> for wrapping arbitrary tags. It also supports wrapping arbitrary HTML.
					</para>
					
				</section>
				
				<section id="section-metawidgets-web-struts-troubleshooting">
					<title>Troubleshooting</title>				
	
					<section id="section-metawidgets-web-struts-troubleshooting-1">
						<title>I get "Cannot find bean org.apache.struts.taglib.html.BEAN in any scope"</title>
						
						<para>
							<classname>StrutsMetawidget</classname> creates native Struts widgets, such as <parameter>&lt;html:text&gt;</parameter>, but does
							not create the surrounding Struts form. Make sure your Metawidget tag is enclosed in
							a <parameter>&lt;html:form&gt;</parameter> tag and the Struts HTML taglib is included at the top of the page.
						</para>
					</section>
				</section>
			</section>
			
		</section>

		<section id="section-metawidgets-mobile">
			<title>Mobile Metawidgets</title>

			<section id="section-metawidgets-mobile-android">
				<title>AndroidMetawidget</title>
	
				<para>
					<classname>AndroidMetawidget</classname> is an Android widget. For an introduction
					to <classname>AndroidMetawidget</classname>, see <xref linkend="section-introduction-part2-mobile"/>.
				</para>

			</section>
			
		</section>

		<section id="section-metawidgets-implementing-your-own">
			<title>Implementing Your Own Metawidget</title>

			<para>
				Metawidget creates widgets native to a particular UI framework. If your chosen UI
				framework is not supported 'out of the box', you may need to implement your own. 
			</para>
			
			<para>
				Metawidgets are not required to extend any base class or implement
				any interface. However, it is recommended developers familiarize themselves with existing
				Metawidgets (such as <classname>UIMetawidget</classname>) to make their API similar. In particular,
				it is recommended Metawidget APIs use the 'direction of inheritance' for 'overriding choice of widget'
				with other concerns (such as layout and binding) implemented orthogonally as
				in <xref linkend="section-metawidgets-implementing-your-own-orthogonal-figure"/>.
			</para>
				
			<figure id="section-metawidgets-implementing-your-own-orthogonal-figure">
				<title>Recommended Metawidget API Design</title>
				<mediaobject>
					<imageobject>
						<imagedata fileref="../shared/images/metawidget-api.jpg" format="jpg"/>
					</imageobject>
				</mediaobject>
			</figure>			
			
			<para>
				Whilst there is no one Metawidget base class, a number of convenience classes are provided:
			</para>
					
			<section id="section-metawidgets-implementing-your-own-mixin">
				<title>MetawidgetMixin</title>
				
				<para>
					Mixins are a frequently used workaround for multiple inheritance in Java. Classes extend the
					mixin as an inner class and override its methods as needed.
				</para>
					
				<para>
					All the built-in Metawidgets use <classname>MetawidgetMixin</classname> to ease their implementation. The
					mixin provides pre-built functionality such as deciding when to use single versus compound widgets, support
					for overriding widgets, incorporating stubs, and changing between read-only and active modes.
				</para>
				
			</section>

			<section id="section-metawidgets-implementing-your-own-android">
				<title>Android</title>
				
				<para>
					For frameworks based on Android, <classname>org.metawidget.android.widget.AndroidMetawidget</classname> provides
					many hooks to override widget creation, most notably <function>AndroidMetawidget.buildActiveWidget</function>.
				</para>
				
				<para>
					Android already defines a separation between <classname>Views</classname> and <classname>ViewGroups</classname>.
					<classname>org.metawidget.android.widget.layout.Layout</classname> and its subclasses automate the use
					of existing Android <classname>ViewGroups</classname>.					
				</para>
				
			</section>

			<section id="section-metawidgets-implementing-your-own-gwt">
				<title>GWT</title>
				
				<para>
					For frameworks based on GWT, <classname>org.metawidget.gwt.client.ui.GwtMetawidget</classname> provides
					many hooks to override widget creation, most notably <function>GwtMetawidget.buildActiveWidget</function>.
				</para>
				
			</section>

			<section id="section-metawidgets-implementing-your-own-faces">
				<title>Java Server Faces</title>
				
				<para>
					For frameworks based on JSF, <classname>org.metawidget.faces.component.UIMetawidget</classname>
					provides base widget functionality. See <classname>org.metawidget.faces.component.html.HtmlMetawidget</classname> for example usage.
				</para>
				
				<para>
					JSF already defines a clean separation between widgets and their renderers.
					<classname>org.metawidget.faces.renderkit.LayoutRenderer</classname> and its subclasses leverage this to
					support different layouts.
				</para>
			</section>
			
			<section id="section-metawidgets-implementing-your-own-jsp">
				<title>Java Server Pages</title>
				
				<para>
					For frameworks based on JSP, <classname>org.metawidget.jsp.tagext.MetawidgetTag</classname> and the more
					commonly used <classname>org.metawidget.jsp.tagext.html.BaseHtmlMetawidgetTag</classname> provide base
					taglib functionality. See <classname>StrutsMetawidgetTag</classname> for example usage.
				</para>
				
				<para>
					<classname>MetawidgetTag</classname> also defines a clean separation between choosing widgets and laying them out.
					<classname>org.metawidget.jsp.tagext.Layout</classname> and its subclasses can perform the layout for
					<emphasis>all</emphasis> JSP-based frameworks.
				</para>
			</section>

			<section id="section-metawidgets-implementing-your-own-swing">
				<title>Swing</title>
				
				<para>
					For frameworks based on Swing, <classname>org.metawidget.swing.SwingMetawidget</classname> provides
					many hooks to override widget creation, most notably <function>SwingMetawidget.buildActiveWidget</function>.
				</para>
				
				<para>
					Swing already defines a clean separation between widgets and layout managers.
					<classname>org.metawidget.swing.layout.Layout</classname> and its subclasses automate the use
					of existing Swing <classname>LayoutManagers</classname>.
				</para>
			</section>

		</section>

	</chapter>

	<chapter id="chapter-inspectors">
		<title>Inspectors</title>
		
		<section id="section-inspectors-preface">
			<title>Preface</title>

			<para>
				Metawidget ships with inspectors to cover different aspects of back-end architecture. Whilst all inspectors
				conform to a common interface, they have different ways of collecting their results. This chapter examines
				each Inspector in detail.
			</para>
			
		</section>

		<section id="section-inspectors-property">
			<title>Property Inspectors</title>

			<section id="section-inspectors-base-object">
				<title>BaseObjectInspector</title>
				
				<para>
					<classname>BaseObjectInspector</classname> underlies many of the Inspectors that inspect objects (as opposed to, say,
					config files). It supports pluggable PropertyStyles and ActionStyles.
				</para>
				
				<section id="section-inspectors-base-object-propertystyle">
					<title>PropertyStyle</title>
					
					<para>
						The <classname>PropertyStyle</classname> interface allows pluggable, fine-grained control over what is considered a 'property'					
					</para>
					
					<para>
						Different environments may have different approaches to defining what constitutes a property. For
						example, JavaBean-properties are convention-based, whereas Groovy has explicit property support.
 						Equally, some environments may have framework-specific, base class properties that should be filtered out
 						and excluded from the list of 'real' business model properties.					
					</para>
					
					<para>
						The default property style is <classname>JavaBeanPropertyStyle</classname>. To change it within <filename>inspector-config.xml</filename>:
					</para>
					
					<programlisting language="xml">&lt;propertyTypeInspector xmlns="java:org.metawidget.inspector.propertytype"
	config="org.metawidget.inspector.impl.BaseObjectInspectorConfig"&gt;
	&lt;propertyStyle&gt;
	org.metawidget.inspector.impl.propertystyle.struts.StrutsActionFormPropertyStyle
	&lt;/propertyStyle&gt;
&lt;/propertyTypeInspector&gt;</programlisting>
					
					<para>
						To change it programmatically:
					</para>
					
					<programlisting language="java">BaseObjectInspectorConfig config = new BaseObjectInspectorConfig();
config.setPropertyStyle( StrutsActionFormPropertyStyle.class );
metawidget.setInspector( new PropertyTypeInspector( config ) );</programlisting>
				</section>

				<section id="section-inspectors-base-object-javabean">
					<title>JavaBeanPropertyStyle</title>
				
					<para>
						The <classname>JavaBeanPropertyStyle</classname> is the default property style used by all <classname>BaseObjectInspector</classname>
						subclasses (which includes all annotation inspectors).
					</para>
					
					<para>
						This property style recognizes JavaBean-convention <function>getXXX</function>, <function>setXXX</function> and <function>isXXX</function>
						methods, as well as public member variables. In addition, it maintains a cache of reflected classes for performance. 
					</para>
					
					<tip>
						<title>Note</title>
						When using getter methods and private members, make sure you annotate the getter <emphasis>not the private
						member</emphasis>. <classname>JavaBeanPropertyStyle</classname> cannot find annotations on private members, because
						the JavaBean specification does not define a way to determine which private members belong to which getters.
					</tip>

				</section>
				
				<section id="section-inspectors-base-object-struts">
					<title>StrutsActionFormPropertyStyle</title>
				
					<para>
						The <classname>StrutsActionFormPropertyStyle</classname> provides special handling for Struts <classname>ActionForms</classname>.
					</para>
					
					<para>
						<classname>ActionForm</classname> properties essentially follow JavaBean-convention (this class extends <classname>JavaBeanPropertyStyle</classname>),
						but should not include properties from the Struts classes, (eg. <function>getServlet</function>, <function>getServletWrapper</function> and
 						<function>getMultipartRequestHandler</function> in <classname>ActionForm</classname> and <function>getDynaClass</function> in
 						<classname>DynaActionForm</classname>). 						
					</para>
					
				</section>

				<section id="section-inspectors-base-object-groovy">
					<title>GroovyPropertyStyle</title>
				
					<para>
						The <classname>GroovyPropertyStyle</classname> recognizes GroovyBean properties.
					</para>
					
					<para>
						Groovy tries hard to make its GroovyBean properties compatible with JavaBean getters/setters, and indeed
						one can almost use <classname>JavaBeanPropertyStyle</classname> to read them. Unfortunately, GroovyBeans
						differ in that:
					</para>
					
					<itemizedlist>
						<listitem>
							<para>
								annotations defined on properties are only attached to the (generated) private member
								variable, not the (generated) getter/setter methods.
							</para>
						</listitem>
						<listitem>
							<para>
								GroovyBeans define an implicit <function>getMetaClass</function> method which, although matching
								the JavaBean signature, should not be treated as a business model property.
							</para>
						</listitem>
					</itemizedlist>

				</section>
				
				<section id="section-inspectors-base-object-javassist">
					<title>JavassistPropertyStyle</title>
						
					<para>
						The <classname>JavassistPropertyStyle</classname> extends
						<classname>JavaBeanPropertyStyle</classname> and makes use of Javassist for those environments
						that have it available.
					</para>
					
					<para>
						Javassist is used to inspect the debug line numbering information embedded in JVM bytecode
						to sort getters/setters according to their original declaration order in the source code. This saves business objects
						having to use <classname>@UiComesAfter</classname> (or an XML file, or some other method) to impose an ordering.
					</para>
					
					<para>
						However, a danger of this approach is that if the business objects are ever recompiled <emphasis>without</emphasis> debug
						line numbering information (eg. when moving from development to production) the UI fields will lose their
						ordering. Such a subtle bug may not be picked up, so as a safeguard <classname>JavassistPropertyStyle</classname>
						'fails hard' with an <classname>InspectorException</classname> if line numbers are not available.
					</para>
					
					<para>
						<classname>JavassistPropertyStyle</classname> uses the following sorting algorithm:
					</para>
					
					<itemizedlist>
						<listitem>
							<para>
								superclass public fields come first, sorted by name.
							</para>
						</listitem>
						<listitem>
							<para>
								superclass methods come next, sorted by getter line number (or, if no getter, setter line number).
							</para>
						</listitem>
						<listitem>
							<para>
								public fields come next, sorted by name.
							</para>
						</listitem>
						<listitem>
							<para>
								methods come last, sorted by getter line number (or, if no getter, setter line number).
							</para>
						</listitem>
					</itemizedlist>
					
					<para>
						Note this algorithm is less flexible than <classname>@UiComesAfter</classname>, which can
						interleave superclass and subclass properties. However, it is possible to use both
						<classname>@UiComesAfter</classname> and <classname>JavassistPropertyStyle</classname> together to get the best of
						both worlds.						
					</para>
						
				</section>

				<section id="section-inspectors-base-object-actionstyle">
					<title>ActionStyle</title>
					
					<para>
						The <classname>ActionStyle</classname> interface allows pluggable, fine-grained control over what is considered an 'action'.					
					</para>
					
					<para>
						Different environments may have different approaches to defining what constitutes an action. For
						example, the Swing AppFramework uses an <classname>@org.jdesktop.application.Action</classname> annotation.
					</para>
					
					<para>
						The default property style is <classname>MetawidgetActionStyle</classname>. To change it within <filename>inspector-config.xml</filename>:
					</para>
					
				<programlisting language="xml">&lt;metawidgetAnnotationInspector config="org.metawidget.inspector.impl.BaseObjectInspectorConfig"&gt;
	&lt;actionStyle&gt;
		org.metawidget.inspector.impl.actionstyle.swing.SwingAppFrameworkActionStyle
	&lt;/actionStyle&gt;
&lt;/metawidgetAnnotationInspector&gt;</programlisting>
					
					<para>
						To change it programmatically:
					</para>
					
					<programlisting language="java">BaseObjectInspectorConfig config = new BaseObjectInspectorConfig();
config.setActionStyle( SwingAppFrameworkActionStyle.class );
metawidget.setInspector( new MetawidgetAnnotationInspector( config ) );</programlisting>

					<para>
						Note these action styles only apply to <classname>BaseObjectInspector</classname> and its subclasses. This covers
						most annotation-recognising Inspectors (eg. <classname>JpaInspector</classname>, <classname>HibernateValidatorInspector</classname>)
						but <emphasis>not</emphasis> XML-based Inspectors. For example, <classname>JbpmInspector</classname> recognizes actions in
						JBoss jBPM files without any concept of an 'action style'.
					</para>
					
				</section>
				
				<section id="section-inspectors-base-object-metawidget">
					<title>MetawidgetActionStyle</title>
				
					<para>
						The default Metawidget action style recognizes any method annotated with <classname>@UiAction</classname>. Action methods
						must not accept any parameters in their signature. 
					</para>
					
				</section>
				
				<section id="section-inspectors-base-object-appframework">
					<title>SwingAppFrameworkActionStyle</title>
				
					<para>
						The <classname>SwingAppFrameworkActionStyle</classname> recognises Swing AppFramework's <classname>@Action</classname>
						annotation as denoting an action.
					</para>

				</section>

			</section>
			
			<section id="section-inspectors-property-type">
				<title>PropertyTypeInspector</title>
				
				<para>
					<classname>PropertyTypeInspector</classname> extends <classname>BaseObjectInspector</classname>, and so inherits its features. In addition, its own
					notable features include:
				</para>
				
				<itemizedlist>
					<listitem>
						<para>
							it inspects the declared type of properties. Provided the type
							is not primitive or <parameter>final</parameter>, it further inspects the actual type of the object. If
							it differs from the declared type (eg. it is a subclass), it returns the actual type together
							with the declared type.
						</para>
					</listitem>
				</itemizedlist>
				
			</section>
			
		</section>

		<section id="section-inspectors-annotation">
			<title>Annotation Inspectors</title>

			<section id="section-inspectors-annotation-troubleshooting">
				<title>Troubleshooting</title>				

				<section id="section-inspectors-annotation-troubleshooting-1">
					<title>I get "java.lang.TypeNotPresentException"</title>
					
					<para>
						If you are using Sun's implementation of Java, Metawidget's annotation support requires
						Java 5.0u6 or later, which includes a fix for this bug (Bug Parade ID: 6322301).
					</para>
				</section>

				<section id="section-inspectors-annotation-troubleshooting-2">
					<title>My inspector is not finding my annotations</title>
					
					<para>
						Annotations are designed to 'silently fall away' in environments that do not
						support them: they never throw <classname>ClassDefNotFoundError</classname>. For example,
						if a JPA-annotated class is transferred to an application tier without <filename>ejb3-persistence.jar</filename>
						(or equivalent) in its classpath, the JPA annotations will disappear.
					</para>
					
					<para>
						If this is the cause, either add the appropriate JAR to the tier, or consider implementing a remote Inspector
						(see <xref linkend="section-howto-order"/>).
					</para>
				</section>
			</section>
			
			<section id="section-inspectors-metawidget-annotation">
				<title>MetawidgetAnnotationInspector</title>
				
				<para>
					As much as possible, Metawidget tries to inspect metadata from existing sources, without
					introducing new concepts. Where that is not sufficient, <classname>MetawidgetAnnotationInspector</classname> adds
					a handful of annotations:
				</para>
				
				<itemizedlist>
					<listitem>
						<para><classname>@UiComesAfter</classname> - denotes the ordering of properties and fields in the UI</para>
					</listitem>
					<listitem>
						<para><classname>@UiSection</classname> - denotes the start of a logical grouping in the UI</para>
					</listitem>
					<listitem>
						<para><classname>@UiLabel</classname> - denotes the label to use in the UI. Can be a resource key if the UI is using resource bundles</para>
					</listitem>
					<listitem>
						<para><classname>@UiLarge</classname> - denotes the field should be 'large' in the UI (eg. a multi-line textbox)</para>
					</listitem>
					<listitem>
						<para><classname>@UiHidden</classname> - denotes a value should be hidden in the UI. The value may
						still be rendered on the client, depending on the Metawidget (eg. for Web clients,
						may use a HTML hidden field)</para>
					</listitem>
					<listitem>
						<para><classname>@UiReadOnly</classname> - denotes a value should be read-only in the UI.</para>
					</listitem>
					<listitem>
						<para><classname>@UiMasked</classname> - denotes a value should be masked in the UI (eg. a password field)</para>
					</listitem>
					<listitem>
						<para><classname>@UiAttributes</classname> and <classname>@UiAttribute</classname> - a 'catch all' for denoting arbitrary UI metadata</para>
					</listitem>
				</itemizedlist>
				
			</section>
			
		</section>

		<section id="section-inspectors-xml">
			<title>XML Inspectors</title>
			
			<para>
				Whilst we don't necessarily encourage the use of XML-based metadata, if you <emphasis>already</emphasis> have XML configuration
				files in your architecture Metawidget will take advantage of them.
			</para>
			
			<para>
				Once nice feature of XML is that ordering of child elements (such as <parameter>&lt;property name=""&gt;</parameter>) is
				explicit, so XML-based Inspectors make great 'first Inspectors' for use within <classname>CompositeInspector</classname> (eg. you
				don't need to also use <classname>@UiComesAfter</classname>).
			</para>
			
			<section id="section-inspectors-xml-xmlinspector">
				<title>XmlInspector</title>
				
				<para>
					<classname>XmlInspector</classname> inspects config files in <filename>inspection-result-1.0.xsd</filename> format. It can
					be used when no other Inspector is available for the given attribute.
				</para>
				
				<para>
					Some attributes accept multiple values, such as <parameter>lookup</parameter>. These can be supplied as a comma-separated
					string. The values will be trimmed for whitespace. If the values themselves contain commas, they can be escaped with the
					<parameter>\</parameter> character.
				</para>
				
			</section>
		</section>

		<section id="section-inspectors-implementing-your-own">
			<title>Implementing Your Own Inspector</title>

			<para>
				Metawidget inspects a wide variety of back-end architectures. If your chosen back-end
				architecture is not supported 'out of the box', you may need to implement your own Inspector. 
			</para>
			
			<para>
				All Inspectors must implement the <classname>org.metawidget.inspector.Inspector</classname> interface:
			</para>
			
			<programlisting language="java">public interface Inspector {
	String inspect( Object toInspect, String type, String... names )
		throws InspectionException;
}</programlisting>
			
			<para>
				The interface has only one method: <function>inspect</function>. Its parameters are:
			</para>
			
			<itemizedlist>
				<listitem>
					<para>
						an <classname>Object</classname> to inspect. This may be <parameter>null</parameter>, or can be ignored for Inspectors working off static metadata (such as config files)
					</para>
				</listitem>
				<listitem>
					<para>
						a <parameter>type</parameter>. This must match the given <classname>Object</classname>, or some attribute in the inspected config file
					</para>
				</listitem>
				<listitem>
					<para>
						a list of <parameter>names</parameter> to be traversed beneath the type
					</para>
				</listitem>
			</itemizedlist>				

			<para>
				At a high level, the inspect parameters can be thought of as an XPath <filename>type/name/name</filename>
				into the object graph of the given <classname>Object</classname> (Metawidget doesn't use <emphasis>actual</emphasis> XPaths, though, for reasons
				discussed in the developer blogs).
			</para>
			
			<para>
				The returned String must be an XML document conforming to <filename>inspection-result-1.0.xsd</filename>. To assist
				development, deploy your Inspector within <classname>CompositeInspector</classname> and use <function>CompositeInspectorConfig.setValidating(true)</function> to
				automatically validate the returned DOM during testing.
			</para>
			
			<para>
				A number of convenience base classes are provided for different Inspectors: 
			</para>
			
			<itemizedlist>
				<listitem>
					<para>
						For inspecting annotations and properties, <classname>BaseObjectInspector</classname> assists
						in iterating over public member variables, getter/setter methods and GroovyBean properties. See
						<classname>PropertyTypeInspector</classname> or <classname>JpaInspector</classname> for example usage.
					</para>				
					<para>
						For inspecting XML files, <classname>BaseXmlInspector</classname> assists
						in opening and traversing through XML. See
						<classname>StrutsInspector</classname> for example usage.
					</para>
				</listitem>
			</itemizedlist>

			<para>
				When implementing your own Inspector, try to avoid technology-specific XML attribute names. For example, <classname>FacesInspector</classname>
				has an annotation <classname>@UiFacesNumberConverter</classname>. This annotation certainly has technology-specific parts to it, as
				it names a JSF <classname>Converter</classname> that only applies in JSF environments, so
				it is reasonable to name the XML attribute <code>faces-converter-class</code>. However, <classname>NumberConverter</classname>s also
				use other properties about the field, such as the maximum number of integer digits. Such properties are not JSF-specific (eg. we can
				source the same property from Hibernate Validator's <classname>@Digits</classname> annotation), so are better named 'neutrally'
				(eg. <classname>maximum-integer-digits</classname>). 
			</para>
			
		</section>

	</chapter>

	<chapter id="chapter-howto">
		<title>How To's</title>
		
		<section id="section-howto-preface">
			<title>Preface</title>
			
			<para>
				This section contains 'How To's' (or 'Recipes') for various scenarios you may encounter when using Metawidget.
			</para>
			
		</section>
		
		<section id="section-howto-order">
			<title>Order Fields</title>
			
			<para>
				Metawidget supports several ways to control the order of fields in the UI, depending on your architecture and your
				preference:
			</para>
			
			<itemizedlist>
				<listitem>
					<para>
						Annotate the fields with <classname>@UiComesAfter</classname> and use <classname>MetawidgetAnnotationInspector</classname>
						as the first inspector in your <classname>CompositeInspector</classname> chain.
					</para>
				</listitem>
				<listitem>
					<para>
						Use one of the XML-based inspectors (such as <classname>XmlInspector</classname> or <classname>HibernateInspector</classname>)
						as the first inspector in your <classname>CompositeInspector</classname> chain. XML nodes are inherently ordered.
					</para>
				</listitem>
				<listitem>
					<para>
						Compile your business model with debug information turned on, and use <classname>JavassistPropertyStyle</classname>. This
						approach uses Javassist to extract line numbering information, and order the fields in source file order.
					</para>
				</listitem>
				<listitem>
					<para>
						Write your own <classname>Inspector</classname>. 
					</para>
				</listitem>
				<listitem>
					<para>
						Write your own <classname>PropertyStyle</classname>. For example, <classname>JavassistPropertyStyle</classname> extends
						<classname>JavaBeanPropertyStyle</classname> and reorders the fields using debug information.
					</para>
				</listitem>
			</itemizedlist>
			
		</section>

		<section id="section-howto-remote">
			<title>Remote Inspection</title>
			
			<para>
				Metawidget inspects back-end metadata and creates front-end UI widgets. If your application is split over multiple
				tiers, however, sometimes the back-end metadata is not accessible from the front-end. For example, annotations
				(such as JPA ones) are designed to 'fall away' if the class is transferred to a tier without JPA in its classpath.
				Equally, configuration files may not be accessible across tiers.
			</para>
			
			<para>
				Metawidget supports these situations. Because each remoting environment is different, however, you will
				need to add a little code yourself. Every Inspector returns an XML string, which are inherently serializable and safe
				to pass across tiers. Therefore, to run inspection remotely:
			</para>
			
			<itemizedlist>
				<listitem>
					<para>
						create a back-end class suited to your environment, such as an EJB Session Bean. Have the back-end class instantiate
						an Inspector - either programmatically:
					</para>
					
					<programlisting language="java">XmlInspectorConfig config = new XmlInspectorConfig();
config.setFile( "metawidget-backend-metadata.xml" );
Inspector inspector = new XmlInspector( config );</programlisting>

					<para>
						Or by using an <filename>inspector-config.xml</filename> file and the <classname>ConfigReader</classname> helper class:
					</para>
					
					<programlisting language="java">inspector = ConfigReader.read( "backend-inspector-config.xml" );</programlisting>
				</listitem>
				<listitem>
					<para>
						have the back-end class declare the <classname>Inspector</classname> interface. Implement the interface by
						delegating to the inspector you just instantiated.
					</para>
				</listitem>
				<listitem>
					<para>
						depending on your environment, it may futher be necessary to create a front-end class (a proxy). Have it declare
						the <classname>Inspector</classname> interface. Implement the interface by remoting to the back-end class and
						returning the XML string.
					</para>
				</listitem>
				<listitem>
					<para>
						set the inspector on the Metawidget by using the <function>setInspector</function> method (rather than
						the <function>setInspectorConfig</function> method).
					</para>
				</listitem>
			</itemizedlist>
			
			<para>
				An example of this technique can be seen in <classname>GwtRemoteInspectorProxy</classname> and <classname>GwtRemoteInspectorImpl</classname>.
			</para>
			
			<tip>
				All Inspectors are both thread-safe and immutable. Therefore you only need one Inspector for your
				<emphasis>entire</emphasis> application. Some remoting architectures support 'singletons' or 'service beans' well suited
				to this.
			</tip>
						
		</section>
				
		<section id="section-howto-combine-remote">
			<title>Combine Remote Inspections</title>
			
			<para>
				If your architecture is strongly separated, some metadata may only be available in one tier (eg. JPA annotations
				in the back-end) and some only available in another tier (eg. <filename>struts-config.xml</filename> in the
				front-end).
			</para>
			
			<para>
				For this, <classname>CompositeInspector</classname> supplies an overloaded method outside the normal <classname>Inspector</classname>
				interface. The overloaded <function>CompositeInspector.inspect</function> method takes an additional XML string
				parameter, which it uses as a starting point for meta-inspection.
			</para>
			
			<para>
				Therefore, to combine metadata from different tiers:
			</para>
			
			<itemizedlist>
				<listitem>
					<para>
						create a front-end class that implements the <classname>Inspector</classname> interface
					</para>
				</listitem>
				<listitem>
					<para>
						implement the interface by first remoting to the back-end class and returning the XML string, as before
					</para>
				</listitem>
				<listitem>
					<para>
						next, delegate to a <classname>CompositeInspector</classname> to inspect the front-end, passing it the XML
						string from the back-end as a starting point
					</para>
				</listitem>
			</itemizedlist>			
		</section>

	</chapter>
	
	<chapter id="chapter-performance">
		<title>Performance</title>
		
		<section id="section-performance-preface">
			<title>Preface</title>
			
			<para>
				Performance is very important to Metawidget. Whilst generating a UI dynamically - as opposed to hard coding it
				statically - is always likely to involve a performance tradeoff, Metawidget supports a number of techniques
				to help minimize this.
			</para>
			
		</section>
		
		<section id="section-performance-jar">
			<title>JAR Size</title>

			<para>
				Metawidget has no mandatory third-party JAR dependencies, and is also highly modular. This
				allows the standard <filename>metawidget.jar</filename> to be repackaged for different environments to save JAR size.
			</para>
			
			<para>		
				For example, the <filename>example-swing-addressbook-applet</filename> Ant task	builds
				<filename>examples\swing\applet\addressbook\metawidget-applet.jar</filename>. This JAR includes only the
				<classname>SwingMetawidget</classname> and those <classname>Inspectors</classname> necessary for the Address Book
				example application. After further compression using <filename>pack200</filename>, it comes to around 45KB.
			</para>
			
		</section>

		<section id="section-performance-rebind">
			<title>Rebinding</title>
			
			<para>
				For Metawidgets that do not use automatic binding, the general approach is to call <function>setToInspect</function>
				and then <function>setValue</function> to populate the generated widgets with values. This technique has an implicit side
				effect: the values can also be <emphasis>re</emphasis>populated as many times as required with new source objects, without re-calling
				<function>setToInspect</function>. This allows the Metawidget to be generated once and reused many times, mitigating the
				performance cost of generation.
			</para>
			
			<para>
				For Metawidgets that <emphasis>do</emphasis> use automatic binding, however, <function>setValue</function> is never used. Setting
				new values requires re-calling <code>setToInspect</code> (and re-running generation) for every new source object. 
			</para>
			
			<para>
				To avoid this Metawidget supports a second, lightweight version of <function>setToInspect</function> called <function>rebind</function>.
				This function is only relevant when using automatic binding. Using <function>rebind</function>, a Metawidget can update the values in
				its generated widgets <emphasis>without</emphasis> re-running generation. This allows the Metawidget to be generated once and reused
				many times.
			</para>
			
			<para>
				The downside of <function>rebind</function> is that the rebound source object must have exactly the same set of field names
				as the original object, else the call will fail. It becomes the responsibility of the caller to ensure this consistency.
			</para>
			
			<para>
				For an example of rebinding, see the GWT Address Book sample application.
			</para>
			
		</section>
	</chapter>
	
	<chapter id="chapter-epilogue">
		<title>Epilogue</title>
		
		<para>
			That concludes the Metawidget Reference Documentation.
		</para>
		
		<para>
			For further documentation - including forums, bug reports, a Wiki community area
			and information on how to contribute - please visit <uri>http://www.metawidget.org</uri>.			
		</para>
		
		<para>
			Thank you for using Metawidget!
		</para>

	</chapter>

</book>
