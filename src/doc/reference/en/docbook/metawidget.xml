<?xml version="1.0" encoding="UTF-8"?>
<book lang="en">
	<title>Metawidget User Guide and Reference Documentation</title>

	<bookinfo>
		<productname>Metawidget</productname>
		<releaseinfo>V 0.95</releaseinfo>

		<mediaobject>
			<imageobject>
				<imagedata fileref="images/logo.gif" />
			</imageobject>
		</mediaobject>
	</bookinfo>

	<toc />

	<preface id="preface">
		<title>Preface</title>

		<para>
			Metawidget is an object/user interface mapping tool for Java
			environments. The term object/user interface mapping (OIM) refers to
			the technique of inspecting objects, at runtime, and creating
			User Interface (UI) widgets.
		</para>

		<para>
			As much as possible, Metawidget does this without introducing new technologies. As shown in
			<xref linkend="preface-diagram" />, Metawidget inspects an application's
			<emphasis>existing</emphasis> back-end architecture (such as JavaBeans, XML configuration files,
			annotations) and creates widgets native to its <emphasis>existing</emphasis>
			front-end framework (such as Swing, Java Server Faces, Struts or Android).
		</para>

		<figure id="preface-diagram">
			<title>Metawidget inspects existing back-ends and creates widgets native to existing front-ends</title>
			<screenshot>
				<graphic fileref="images/overview.png" width="175mm" />
			</screenshot>
		</figure>

		<para>
			Building great UIs is both art and science. Metawidget does not attempt to address the
			<emphasis>art</emphasis>, it only automates the	<emphasis>science</emphasis>. That is to
			say, it does not overlap with those areas of
			UI design involving creativity and subjectivity - its goal is
			only to ease the creation of areas that are already rigidly
			defined. Typically, this means those areas that display data and
			those that collect data - these tend to be both commonplace and
			consistent (indeed, consistency is a desirable trait) so there
			is good opportunity for automation.
		</para>

		<tip>
			<title>Note</title>
			This User Guide and Reference Documentation is included in the distribution as a PDF, a single HTML page or as multiple
			HTML pages, depending on your reading preference.
		</tip>

	</preface>

	<preface id="preface-supported-technologies">
		<title>Supported Technologies</title>

		<para>
			A primary goal of Metawidget is to work with your
			<emphasis>existing</emphasis>
			front-end and back-end architecture. Out of the box, Metawidget supports a broad range of both
			front-end and back-end technologies, and makes it easy to add your own.
		</para>

		<para>
			Metawidget comes with a native UI component for each supported front-end.
			This support includes: Android, Google Web Toolkit (including
			extensions such as ExtGWT), Java Server
			Faces (including extensions such as Facelets, ICEfaces, RichFaces and Tomahawk),
			'plain' Java Server Pages (including extensions such as DisplayTag),
			Spring Web MVC, Struts, Swing (including extensions such as Beans Binding,
			JGoodies, MigLayout and SwingX) and SWT.
		</para>

		<para>
			Metawidget can read business object information from any combination of supported
			back-end technologies. This support includes: annotations, Bean Validation (JSR 303), Commons
			JEXL, Commons Validator, Groovy, Hibernate, Hibernate Validator, JavaBeans, Java Persistence
			Architecture (JPA), Javassist, JBoss jBPM, OVal, Scala, Seam and the Swing AppFramework. 
		</para>

		<tip>
			<title>Note</title>
			It is <emphasis>not</emphasis> a goal of Metawidget that all widgets look the same on
			every front-end framework, or that all back-end technologies conform to some 'lowest common
			denominator': every technology has different features, and Metawidget takes full advantage of this.
		</tip>

		<para>
			The next chapter presents a tutorial covering using Metawidget with a variety of front-ends and
			back-ends. Chapter 2 then follows with a more in-depth architectual overview. Chapters 3-8
			explore each supported front-end and back-end technology in detail. Finally, chapters
			9 and 10 offer general advice and performance tips.
		</para>

	</preface>

	<chapter id="chapter-introduction">
		<title>Introduction to Metawidget</title>

		<para>
			This chapter is an introductory tutorial for new users of
			Metawidget. Before you begin, you need to download at least the binary distribution, and
			preferrably the source code distribution as well, from
			<ulink url="http://www.metawidget.org/download.html">http://www.metawidget.org/download.html</ulink>.
		</para>

		<section id="section-introduction-part1">
			<title>Part 1 - The First Metawidget Application</title>

			<para>
				Part 1 starts with a simple Swing application and develops it in easy to understand steps.
				Metawidget supports many UI frameworks, not just Swing, but we start with Swing because it
				ships with Java SE and requires minimal setup.
			</para>

			<para>
				This tutorial should take around 20 minutes. We recommend you use your preferred Java
				development environment. If you use an Integrated Development Environment (IDE), you will
				need to start a new Java project and add <filename>metawidget.jar</filename> to it. Otherwise,
				you just need to ensure <filename>metawidget.jar</filename> is on your <parameter>CLASSPATH</parameter>
				.
			</para>

			<section id="section-introduction-part1-object">
				<title>The Object</title>

				<para>
					Metawidget is an object/user interface mapping tool (OIM), so first we need an object to map from - the
					<emphasis>O</emphasis> in OIM. Create a class in your project called <classname>Person</classname>
					with the following code:
				</para>

				<programlisting language="java">package com.myapp;

public class Person {
	public String name; <co id="co-introduction-part1-members" linkends="ca-introduction-part1-members" />
	public int age;
	public boolean retired;
}</programlisting>

				<calloutlist>
					<callout arearefs="co-introduction-part1-members" id="ca-introduction-part1-members">
						<para>
							This tutorial uses public member variables for brevity. The
							recommended design is to use JavaBean property getter and setter methods.
							Metawidget supports both approaches.
						</para>
					</callout>
				</calloutlist>

			</section>

			<section id="section-introduction-part1-interface">
				<title>The Interface</title>

				<para>
					Next we need a User Interface framework - the <emphasis>I</emphasis>
					in OIM. Create a class in your project called <classname>Main</classname>
					with the following code:
				</para>

				<programlisting language="java">package com.myapp;

import javax.swing.*;
import org.metawidget.swing.*;

public class Main {

	public static void main( String[] args ) {
		Person person = new Person();
		
		SwingMetawidget metawidget = new SwingMetawidget();
		metawidget.setToInspect( person );
		
		JFrame frame = new JFrame( "Metawidget Tutorial" );
		frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
		frame.getContentPane().add( metawidget );
		frame.setSize( 400, 250 );
		frame.setVisible( true );
	}
}</programlisting>

				<tip>
					<title>Note</title>
					Many IDEs include visual UI builders
					for dragging and dropping widgets. Metawidget integrates
					with these tools and Metawidget widgets can be dragged and
					dropped like any other. As we shall see, however, Metawidget
					widgets automatically fill themselves with child widgets at runtime,
					saving significant development time.
				</tip>

			</section>

			<section id="section-introduction-part1-output">
				<title>The Output</title>

				<para>
					If you're using an IDE, such as	<ulink url="http://netbeans.org">NetBeans</ulink>, your project should
					look something like pictured in	<xref linkend="section-introduction-part1-screenshot-ide" />.
				</para>

				<figure id="section-introduction-part1-screenshot-ide">
					<title>Metawidget tutorial in NetBeans IDE</title>
					<screenshot>
						<graphic fileref="images/screenshots/swing-tutorial-ide.jpg" width="170mm" />
					</screenshot>
				</figure>

				<para>
					Run the code. You should see the screen in <xref linkend="section-introduction-part1-screenshot1" />.
				</para>

				<figure id="section-introduction-part1-screenshot1">
					<title>SwingMetawidget rendering of Person class</title>
					<screenshot>
						<graphic fileref="images/screenshots/swing-tutorial1.jpg" width="100mm" />
					</screenshot>
				</figure>

				<para>
					The <classname>SwingMetawidget</classname> has automatically populated itself with child widgets at
					runtime. It has chosen <classname>JSpinner</classname>,	<classname>JTextField</classname> and
					<classname>JCheckBox</classname> widgets based on the types of the properties of the
					<classname>Person</classname> class. This is the First Goal Of Metawidget:
				</para>

				<important>
					<title>First Goal Of Metawidget</title>
					Metawidget creates UI widgets by inspecting existing back-end architectures
				</important>

				<para>
					By default, <classname>SwingMetawidget</classname> has laid out the	<classname>JComponents</classname>
					using <classname>java.awt.GridBagLayout</classname>. Try resizing the window, and the
					<classname>JComponents</classname> will resize with it. If you've ever tried using
					<classname>java.awt.GridBagLayout</classname> yourself, either
					through code or a visual UI builder, you'll know how fiddly it can be. Having Metawidget do it for you is a real time-saver.
				</para>

				<para>
					Clearly this is not a complete UI. There are no Save or Cancel buttons, for example,
					and the	<classname>JComponents</classname> appear uncomfortably tight to the left, top and right edges of the
					<classname>JFrame</classname>. This is explained by the Second Goal Of Metawidget:
				</para>

				<important>
					<title>Second Goal Of Metawidget</title>
					Metawidget does not try to 'own' the entire UI - it focusses on
					creating native sub-widgets for slotting into existing UIs
				</important>

				<para>
					You slot Metawidget alongside your standard UI components, often combining several Metawidgets on the same screen. We'll
					see how this works later.
				</para>

			</section>

			<section id="section-introduction-part1-ordering">
				<title>Ordering The Fields</title>

				<para>
					Currently the <parameter>name</parameter>, <parameter>age</parameter>
					and	<parameter>retired</parameter> fields are arranged alphabetically in the UI - their order does not match
					the way they are defined in the	<classname>Person</classname>
					class. This is because field ordering information is not retained within Java class files
					(as per the Java Language Specification).
				</para>

				<para>
					To correct this, Metawidget needs to gather additional information. There are several ways to
					do this (ie. you don't have to use annotations), but the simplest for now is to use the built-in
					Metawidget annotation <classname>@UiComesAfter</classname>.
				</para>

				<tip>
					<title>Note</title>
					The following code uses annotations, so you'll need Java SE 5 or higher. Metawidget itself can run
					on J2SE 1.4, but you'll need to gather the ordering information from a different source
					(see <xref linkend="section-introduction-part1-xmlinspector" />)
				</tip>

				<para>
					Annotate the <classname>Person</classname>
					class as shown below (lines to add are highlighted):
				</para>

				<programlisting language="java">package com.myapp;

<symbol>import org.metawidget.inspector.annotation.*;</symbol>

public class Person {
	public String name;
	
	<symbol>@UiComesAfter( "name" )</symbol> <co id="co-introduction-part1-annotations" linkends="ca-introduction-part1-annotations" />
	public int age;
	
	<symbol>@UiComesAfter( "age" )</symbol>
	public boolean retired;
}</programlisting>

				<calloutlist>
					<callout arearefs="co-introduction-part1-annotations" id="ca-introduction-part1-annotations">
						<para>
							Such annotations can (and should) be applied to getter methods, but for brevity here they
							are applied directly to the member variable.
						</para>
					</callout>
				</calloutlist>

				<para>
					Run the code again. This time the fields appear in the correct order:
				</para>

				<figure id="section-introduction-part1-ordered-screenshot2">
					<title>Fields in correct order</title>
					<screenshot>
						<graphic fileref="images/screenshots/swing-tutorial2.jpg" width="100mm" />
					</screenshot>
				</figure>
			</section>

			<section id="section-introduction-part1-inspectors">
				<title>Inspectors</title>

				<para>
					Introducing new annotations to improve the UI is not really in the spirit of
					the First Goal Of Metawidget. We'd much rather improve it by gathering
					information from <emphasis>existing</emphasis> sources. To demonstrate how Metawidget
					can adapt to different sources of metadata, add the following lines to
					<classname>Person</classname> (lines to add are highlighted):
				</para>

				<programlisting language="java">package com.myapp;

import org.metawidget.inspector.annotation.*;

public class Person {
	public String name;
	
	@UiComesAfter( "name" )
	public int age;
	
	@UiComesAfter( "age" )
	public boolean retired;

	<symbol>@UiComesAfter( "retired" )
	public Gender gender;

	public enum Gender { Male, Female }</symbol>
}</programlisting>

				<para>
					Run the code again:
				</para>

				<figure id="section-introduction-part1-screenshot3">
					<title>New Gender field, but missing a component</title>
					<screenshot>
						<graphic fileref="images/screenshots/swing-tutorial3.jpg" width="100mm" />
					</screenshot>
				</figure>

				<para>
					Metawidget finds the new <function>gender</function> property, and renders a <classname>JLabel</classname>
					for it on the left, but doesn't know what <classname>JComponent</classname>
					to put on the right. This is because, by default, Metawidget does not inspect Java 5 language features
					such as enums and generics.
				</para>

				<para>
					To recognise the enum, Metawidget needs to use a different <emphasis>Inspector</emphasis>.
					Metawidget comes with multiple <classname>Inspector</classname>s, each
					targeting different sources of information. Change the Main class to use a
					<classname>Java5Inspector</classname> (lines to add are highlighted):
				</para>

				<programlisting language="java">package com.myapp;

import javax.swing.*;
<symbol>import org.metawidget.inspector.java5.*;</symbol>
import org.metawidget.swing.*;

public class Main {

	public static void main( String[] args ) {
		Person person = new Person();
		
		SwingMetawidget metawidget = new SwingMetawidget();
		<symbol>metawidget.setInspector( new Java5Inspector() );</symbol>
		metawidget.setToInspect( person );
		
		JFrame frame = new JFrame( "Metawidget Tutorial" );
		frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
		frame.getContentPane().add( metawidget );
		frame.setSize( 400, 250 );
		frame.setVisible( true );
	}
}</programlisting>

				<para>
					Run the code again. It does not yield the correct result - the
					<function>gender</function> enum appears correctly as a
					<classname>JComboBox</classname> but all the other fields have
					disappeared! What happened?
				</para>

				<figure id="section-introduction-part1-screenshot4">
					<title>Correct Gender field, but missing other fields</title>
					<screenshot>
						<graphic fileref="images/screenshots/swing-tutorial4.jpg" width="100mm" />
					</screenshot>
				</figure>

				<para>
					Metawidget <classname>Inspector</classname>s are very targeted in what they inspect.
					<classname>Java5Inspector</classname> looks for Java 5 language features - such as enums - but it does
					<emphasis>not</emphasis> look for anything else - such as JavaBean properties. Before we explicitly specified a
					<classname>Java5Inspector</classname>, Metawidget had been implictly using two
					<classname>Inspector</classname>s for us, called <classname>PropertyTypeInspector</classname>
					and	<classname>MetawidgetAnnotationInspector</classname>.
				</para>

			</section>

			<section id="section-introduction-part1-compositeinspector">
				<title>Combining Multiple Inspection Results</title>

				<para>
					What we need is to <emphasis>combine</emphasis> the results of
					<classname>PropertyTypeInspector</classname>, <classname>MetawidgetAnnotationInspector</classname>
					and	<classname>Java5Inspector</classname> before returning them to
					<classname>SwingMetawidget</classname>. We do this using <classname>CompositeInspector</classname>:
				</para>

				<programlisting language="java">package com.myapp;

import javax.swing.*;
<symbol>import org.metawidget.inspector.annotation.*;
import org.metawidget.inspector.composite.*;</symbol>
import org.metawidget.inspector.java5.*;
<symbol>import org.metawidget.inspector.propertytype.*;</symbol>
import org.metawidget.swing.*;

public class Main {

	public static void main( String[] args ) {
		Person person = new Person();
		
		SwingMetawidget metawidget = new SwingMetawidget();
		<symbol>CompositeInspectorConfig inspectorConfig = new CompositeInspectorConfig().setInspectors(
			new PropertyTypeInspector(),
			new MetawidgetAnnotationInspector(),
			new Java5Inspector() );
		metawidget.setInspector( new CompositeInspector( inspectorConfig ) );</symbol>
		metawidget.setToInspect( person );
		
		JFrame frame = new JFrame( "Metawidget Tutorial" );
		frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
		frame.getContentPane().add( metawidget );
		frame.setSize( 400, 250 );
		frame.setVisible( true );
	}
}</programlisting>

				<para>
					Run the code again. This time both the original fields and the new
					<function>gender</function>	<classname>JComboBox</classname> appear:
				</para>

				<figure id="section-introduction-part1-screenshot5">
					<title>Using multiple inspectors</title>
					<screenshot>
						<graphic fileref="images/screenshots/swing-tutorial5.jpg" width="100mm" />
					</screenshot>
				</figure>

				<para>
					This idea of combining multiple <classname>Inspector</classname>s to inspect different characteristics of your
					existing architecture is very powerful. Metawidget comes with many pre-written
					<classname>Inspector</classname>s for many different architectures - from JPA and Hibernate Validator annotations,
					to <filename>struts-config.xml</filename> configuration files, to Groovy and Scala properties - Metawidget
					will gather and combine UI information from wherever it can find it.
				</para>

			</section>

			<section id="section-introduction-part1-layout">
				<title>Controlling The Layout</title>

				<para>
					There are several ways to control the layout of the components. To demonstrate, Try adding the following
					fields to the Person class:
				</para>

				<programlisting language="java">package com.myapp;

import org.metawidget.inspector.annotation.*;

public class Person {
	public String name;
	
	@UiComesAfter( "name" )
	public int age;
	
	@UiComesAfter( "age" )
	public boolean retired;
	
	@UiComesAfter( "retired" )
	public Gender gender;
	
	public enum Gender { Male, Female }

	<symbol>@UiComesAfter( "gender" )
	@UiLarge
	public String notes;

	@UiComesAfter( "notes" )
	@UiSection( "Work" )
	public String employer;

	@UiComesAfter( "employer" )
	public String department;</symbol>
}</programlisting>

				<para>
					This code produces the screen in <xref linkend="section-introduction-part1-screenshot6" />. Annotations
					have been used to define section headings and 'large' fields (ie. a	<classname>JTextArea</classname>).
				</para>

				<figure id="section-introduction-part1-screenshot6">
					<title>Additional fields and a section heading</title>
					<screenshot>
						<graphic fileref="images/screenshots/swing-tutorial6.jpg" width="100mm" />
					</screenshot>
				</figure>

				<tip>
					<title>Note</title>
					For a list of all the annotations <classname>MetawidgetAnnotationInspector</classname> recognises,
					see	<xref linkend="section-inspectors-metawidgetannotation" />.
				</tip>

				<para>
					By default,	<classname>SwingMetawidget</classname> lays out
					<classname>JComponents</classname> using <classname>org.metawidget.swing.layout.GridBagLayout</classname>.
					You can configure this layout, or swap it for a different layout, using
					<function>SwingMetawidget.setMetawidgetLayout</function>. Modify the code to use a
					<classname>GridBagLayout</classname> with 2 columns.
				</para>

				<programlisting language="java">package com.myapp;

import javax.swing.*;
import org.metawidget.inspector.annotation.*;
import org.metawidget.inspector.composite.*;
import org.metawidget.inspector.java5.*;
import org.metawidget.inspector.propertytype.*;
import org.metawidget.swing.*;
<symbol>import org.metawidget.swing.layout.*;</symbol>

public class Main {

	public static void main( String[] args ) {
		Person person = new Person();
		
		SwingMetawidget metawidget = new SwingMetawidget();
		CompositeInspectorConfig inspectorConfig = new CompositeInspectorConfig().setInspectors(
			new PropertyTypeInspector(),
			new MetawidgetAnnotationInspector(),
			new Java5Inspector() );
		metawidget.setInspector( new CompositeInspector( inspectorConfig ) );
		<symbol>GridBagLayoutConfig nestedLayoutConfig = new GridBagLayoutConfig().setNumberOfColumns( 2 ); 
		SeparatorLayoutDecoratorConfig layoutConfig = new SeparatorLayoutDecoratorConfig().setLayout(
			new org.metawidget.swing.layout.GridBagLayout( nestedLayoutConfig ));
		metawidget.setMetawidgetLayout( new SeparatorLayoutDecorator( layoutConfig ));</symbol>
		metawidget.setToInspect( person );
		
		JFrame frame = new JFrame( "Metawidget Tutorial" );
		frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
		frame.getContentPane().add( metawidget );
		frame.setSize( 400, 250 );
		frame.setVisible( true );
	}
}</programlisting>

				<para>
					Run the code. The <classname>JComponents</classname> are now arranged across two columns as in
					<xref linkend="section-introduction-part1-screenshot7" />.
				</para>

				<figure id="section-introduction-part1-screenshot7">
					<title>A two-column layout</title>
					<screenshot>
						<graphic fileref="images/screenshots/swing-tutorial7.jpg" width="100mm" />
					</screenshot>
				</figure>

				<para>
					You may have noticed the <classname>GridBagLayout</classname> is nested inside a <classname>SeparatorLayoutDecorator</classname>. This
					is responsible for separating widgets in different sections using <classname>JSeparator</classname>s. However there are other choices for
					separating widgets. Modify the code to use <classname>TabbedPaneLayoutDecorator</classname> instead:
				</para>
				
				<programlisting language="java">package com.myapp;

import javax.swing.*;
import org.metawidget.inspector.annotation.*;
import org.metawidget.inspector.composite.*;
import org.metawidget.inspector.java5.*;
import org.metawidget.inspector.propertytype.*;
import org.metawidget.swing.*;
import org.metawidget.swing.layout.*;

public class Main {

	public static void main( String[] args ) {
		Person person = new Person();
		
		SwingMetawidget metawidget = new SwingMetawidget();
		CompositeInspectorConfig inspectorConfig = new CompositeInspectorConfig().setInspectors(
			new PropertyTypeInspector(),
			new MetawidgetAnnotationInspector(),
			new Java5Inspector() );
		metawidget.setInspector( new CompositeInspector( inspectorConfig ) );
		GridBagLayoutConfig nestedLayoutConfig = new GridBagLayoutConfig().setNumberOfColumns( 2 ); 
		<symbol>TabbedPaneLayoutDecoratorConfig layoutConfig = new TabbedPaneLayoutDecoratorConfig().setLayout(
			new org.metawidget.swing.layout.GridBagLayout( nestedLayoutConfig ));
		metawidget.setMetawidgetLayout( new TabbedPaneLayoutDecorator( layoutConfig ));</symbol>
		metawidget.setToInspect( person );
		
		JFrame frame = new JFrame( "Metawidget Tutorial" );
		frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
		frame.getContentPane().add( metawidget );
		frame.setSize( 400, 250 );
		frame.setVisible( true );
	}
}</programlisting>

				<para>
					Run the code. The section heading is now a <classname>JTabbedPane</classname> as in
					<xref linkend="section-introduction-part1-screenshot8" />.
				</para>

				<figure id="section-introduction-part1-screenshot8">
					<title>Two-column layout with a JTabbedPane</title>
					<screenshot>
						<graphic fileref="images/screenshots/swing-tutorial8.jpg" width="100mm" />
					</screenshot>
				</figure>

				<para>
					Again, if you've ever used <classname>java.awt.GridBagLayout</classname> by hand, you'll appreciate how much easier
					Metawidget makes all this.
				</para>
			</section>

			<section id="section-introduction-part1-creation">
				<title>Controlling Widget Creation</title>

				<para>
					There are several ways to control widget creation. One way is to drop child controls inside the
					<classname>SwingMetawidget</classname>. This approach works well both within code and within visual UI builders.
				</para>

				<para>
					Modify the code to add a <classname>JComboBox</classname> to the Metawidget:
				</para>

				<programlisting language="java">package com.myapp;

import javax.swing.*;
import org.metawidget.inspector.annotation.*;
import org.metawidget.inspector.composite.*;
import org.metawidget.inspector.java5.*;
import org.metawidget.inspector.propertytype.*;
import org.metawidget.swing.*;
import org.metawidget.swing.layout.*;

public class Main {

	public static void main( String[] args ) {
		Person person = new Person();
		
		SwingMetawidget metawidget = new SwingMetawidget();
		CompositeInspectorConfig inspectorConfig = new CompositeInspectorConfig().setInspectors(
			new PropertyTypeInspector(),
			new MetawidgetAnnotationInspector(),
			new Java5Inspector() );
		metawidget.setInspector( new CompositeInspector( inspectorConfig ) );
		GridBagLayoutConfig nestedLayoutConfig = new GridBagLayoutConfig().setNumberOfColumns( 2 ); 
		TabbedPaneLayoutDecoratorConfig layoutConfig = new TabbedPaneLayoutDecoratorConfig().setLayout(
			new org.metawidget.swing.layout.GridBagLayout( nestedLayoutConfig ));
		metawidget.setMetawidgetLayout( new TabbedPaneLayoutDecorator( layoutConfig ));
		metawidget.setToInspect( person );
		<symbol>JComboBox combo = new JComboBox();
		combo.setName( "retired" );
		metawidget.add( combo );</symbol>
		
		JFrame frame = new JFrame( "Metawidget Tutorial" );
		frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
		frame.getContentPane().add( metawidget );
		frame.setSize( 400, 250 );
		frame.setVisible( true );
	}
}</programlisting>

				<para>
					Run the code. The <classname>JComboBox</classname> appears in place of the
					<parameter>retired</parameter> <classname>JCheckBox</classname>, because it has the same name (ie. 'retired') as Metawidget would have given the
					<classname>JCheckbox</classname>:
				</para>

				<figure id="section-introduction-part1-screenshot9">
					<title>The 'retired' field has been overridden</title>
					<screenshot>
						<graphic fileref="images/screenshots/swing-tutorial9.jpg" width="100mm" />
					</screenshot>
				</figure>

				<tip>
					<title>Note</title>
					The default algorithm looks for child controls with the same name, but you can plug in your own implementation
					if you need to. See <xref linkend="section-architecture-overriddenwidgetbuilder"/>.
				</tip>
				
				<para>
					To suppress a widget's creation entirely, simply supplying an empty
					<classname>JPanel</classname> named 'retired' will not work as Metawidget
					will still create an accompanying label in the left hand column. Instead, Metawidget includes special
					<classname>Stub</classname> widgets	for this purpose:
				</para>

				<programlisting language="java">package com.myapp;

import javax.swing.*;
import org.metawidget.inspector.annotation.*;
import org.metawidget.inspector.composite.*;
import org.metawidget.inspector.java5.*;
import org.metawidget.inspector.propertytype.*;
import org.metawidget.swing.*;

public class Main {

	public static void main( String[] args ) {
		Person person = new Person();
		
		SwingMetawidget metawidget = new SwingMetawidget();
		CompositeInspectorConfig inspectorConfig = new CompositeInspectorConfig().setInspectors(
			new PropertyTypeInspector(),
			new MetawidgetAnnotationInspector(),
			new Java5Inspector() );
		metawidget.setInspector( new CompositeInspector( inspectorConfig ) );
		GridBagLayoutConfig nestedLayoutConfig = new GridBagLayoutConfig().setNumberOfColumns( 2 ); 
		TabbedPaneLayoutDecoratorConfig layoutConfig = new TabbedPaneLayoutDecoratorConfig().setLayout(
			new org.metawidget.swing.layout.GridBagLayout( nestedLayoutConfig ));
		metawidget.setMetawidgetLayout( new TabbedPaneLayoutDecorator( layoutConfig ));
		metawidget.setToInspect( person );
		<symbol>metawidget.add( new Stub( "retired" ));</symbol>
		
		JFrame frame = new JFrame( "Metawidget Tutorial" );
		frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
		frame.getContentPane().add( metawidget );
		frame.setSize( 400, 250 );
		frame.setVisible( true );
	}
}</programlisting>

				<para>
					Run the code. The <parameter>retired</parameter> field and its label will not appear,
					as in <xref linkend="section-introduction-part1-screenshot10" />.
				</para>

				<figure id="section-introduction-part1-screenshot10">
					<title>The 'retired' field has been suppressed</title>
					<screenshot>
						<graphic fileref="images/screenshots/swing-tutorial10.jpg" width="100mm" />
					</screenshot>
				</figure>

				<para>
					Another way is to use a <classname>@UiHidden</classname> annotation on the business class:
				</para>

				<programlisting language="java">package com.myapp;

import org.metawidget.inspector.annotation.*;

public class Person {
	public String name;
	
	@UiComesAfter( "name" )
	public int age;
	
	@UiComesAfter( "age" )
	<symbol>@UiHidden</symbol>
	public boolean retired;
	
	@UiComesAfter( "retired" )
	public Gender gender;
	
	public enum Gender { Male, Female }
	
	@UiComesAfter( "gender" )
	@UiLarge
	public String notes;
	
	@UiComesAfter( "notes" )
	@UiSection( "Work" )
	public String employer;
	
	@UiComesAfter( "employer" )
	public String department;
}</programlisting>

				<para>
					In both cases, <classname>org.metawidget.swing.layout.GridBagLayout</classname>
					is smart enough to always give large <classname>JComponents</classname>
					like <parameter>notes</parameter> the full width of the
					<classname>JFrame</classname>.
				</para>

			</section>

			<section id="section-introduction-part1-metawidget-config">
				<title>Configuring Metawidget Externally</title>

				<para>
					So far we have been instantiating our <classname>Inspector</classname>s and
					<classname>Layout</classname>s in Java code. Whilst this approach is possible for all
					<classname>Inspector</classname>s and <classname>Layout</classname>s, many UI frameworks employ
					visual UI builders or intermediate languages (such as JSP) that make getting to the Java code cumbersome (ie. you have to derive
					custom widgets).
				</para>

				<para>
					As an alternative, Metawidget supports external XML configuration. Create a file called
					<filename>metawidget.xml</filename> in the same folder as your <classname>Main</classname>
					class:
				</para>

				<programlisting language="xml">&lt;metawidget xmlns="http://metawidget.org"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	version="1.0"
	xsi:schemaLocation="http://metawidget.org http://metawidget.org/xsd/metawidget-1.0.xsd"&gt;

	&lt;swingMetawidget xmlns="java:org.metawidget.swing"&gt;		
		&lt;inspector&gt;
			&lt;compositeInspector xmlns="java:org.metawidget.inspector.composite"
				config="CompositeInspectorConfig"&gt;
				&lt;inspectors&gt;
					&lt;array&gt;
						&lt;propertyTypeInspector xmlns="java:org.metawidget.inspector.propertytype"/&gt;
						&lt;metawidgetAnnotationInspector xmlns="java:org.metawidget.inspector.annotation" /&gt;
						&lt;java5Inspector xmlns="java:org.metawidget.inspector.java5"/&gt;
					&lt;/array&gt;
				&lt;/inspectors&gt;
			&lt;/compositeInspector&gt;
		&lt;/inspector&gt;
		&lt;metawidgetLayout&gt;
			&lt;tabbedPaneLayoutDecorator xmlns="java:org.metawidget.swing.layout"
				config="TabbedPaneLayoutDecoratorConfig"&gt;
				&lt;layout&gt;
					&lt;gridBagLayout config="GridBagLayoutConfig"&gt;
						&lt;numberOfColumns&gt;
							&lt;int&gt;2&lt;/int&gt;
						&lt;/numberOfColumns&gt;
					&lt;/gridBagLayout&gt;
				&lt;/layout&gt;
			&lt;/tabbedPaneLayoutDecorator&gt;
		&lt;/metawidgetLayout&gt;	
	&lt;/swingMetawidget&gt;

&lt;/metawidget&gt;</programlisting>			
				
				<para>
					Now update your <classname>Main</classname> class to use this file:
				</para>
					
				<programlisting language="java">package com.myapp;

<symbol>import javax.swing.*;
import org.metawidget.swing.*;</symbol>

public class Main {

	public static void main( String[] args ) {
		Person person = new Person();

		SwingMetawidget metawidget = new SwingMetawidget();
		<symbol>metawidget.setConfig( "com/myapp/metawidget.xml" );</symbol>
		metawidget.setToInspect( person );

		JFrame frame = new JFrame( "Metawidget Tutorial" );
		frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
		frame.getContentPane().add( metawidget );
		frame.setSize( 400, 250 );
		frame.setVisible( true );
	}
}</programlisting>

				<para>
					Run the code. The output is the same as before, but this time we are configuring our Metawidget via external XML.
				</para>
				
				<para>
					Visual UI builders can call <function>SwingMetawidget.setConfig</function> from the builder, with no coding required. Other
					UI frameworks (eg. JSPs, Android) have similar 'code free' approaches (eg. setting an attribute on a JSP tag, setting an
					attribute in an Android layout file) to setting the XML file.
				</para>
				
			</section>
			
			<section id="section-introduction-part1-xmlinspector">
				<title>Inspecting Different Sources</title>
	
				<para>
					It could be argued UI-oriented annotations such as <classname>@UiComesAfter</classname> sit
					uncomfortably on a business class from a 'separation of concerns' perspective. It has advantages
					in that it keeps the metadata close to the data it refers to. It
					is also sufficiently abstract that it does not tie the code to any particular UI framework.			
				</para>
				
				<para>
					However, for those needing a different approach Metawidget can use
					different <classname>Inspector</classname>s to gather information from almost any source. One example is to
					use <classname>XmlInspector</classname>. Create a file called <filename>metawidget-metadata.xml</filename> in the same
					folder as your <classname>Main</classname> class:
				</para>
	
				<programlisting language="xml">&lt;inspection-result xmlns="http://metawidget.org/inspection-result"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	version="1.0"	
	xsi:schemaLocation="http://metawidget.org/inspection-result
		http://metawidget.org/xsd/inspection-result-1.0.xsd"&gt;

	&lt;entity type="com.myapp.Person"&gt;
		&lt;property name="name"/&gt;
		&lt;property name="age"/&gt;
		&lt;property name="retired" hidden="true"/&gt;
		&lt;property name="gender"/&gt;
		&lt;property name="notes" large="true"/&gt;
		&lt;property name="employer" section="Work"/&gt;
		&lt;property name="department"/&gt;
	&lt;/entity&gt;

&lt;/inspection-result&gt;</programlisting>
	
				<tip>
					<title>Note</title>
					In XML, the <parameter>comes-after</parameter> attribute is optional: XML nodes are
					inherently ordered, and <classname>CompositeInspector</classname> combines inspection results so that later results
					respect the ordering of earlier results.
				</tip>
	
				<tip>
					<title>Note</title>
					The XML does not need to specify a <parameter>type</parameter>
					attribute: we will still be using <classname>PropertyTypeInspector</classname> to look up the type. It also
					does not need to specify a <parameter>lookup</parameter> attribute: we will still be using
					<classname>Java5Inspector</classname> to determine possible enum values.
				</tip>

				<para>
					Update your <filename>metawidget.xml</filename> to use <classname>XmlInspector</classname> instead of
					<classname>MetawidgetAnnotationInspector</classname>:
				</para>
	
				<programlisting language="xml">&lt;metawidget xmlns="http://metawidget.org"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	version="1.0"
	xsi:schemaLocation="http://metawidget.org http://metawidget.org/xsd/metawidget-1.0.xsd"&gt;

	&lt;swingMetawidget xmlns="java:org.metawidget.swing"&gt;		
		&lt;inspector&gt;
			&lt;compositeInspector xmlns="java:org.metawidget.inspector.composite"
				config="CompositeInspectorConfig"&gt;
				&lt;inspectors&gt;
				&lt;array&gt;
					<symbol>&lt;xmlInspector xmlns="java:org.metawidget.inspector.xml"
						config="XmlInspectorConfig"&gt;
						&lt;inputStream&gt;
							&lt;resource&gt;com/myapp/metawidget-metadata.xml&lt;/resource&gt;
						&lt;/inputStream&gt;						
					&lt;/xmlInspector&gt;</symbol>
					&lt;propertyTypeInspector xmlns="java:org.metawidget.inspector.propertytype"/&gt;
					&lt;java5Inspector xmlns="java:org.metawidget.inspector.java5"/&gt;
				&lt;/array&gt;
				&lt;/inspectors&gt;
			&lt;/compositeInspector&gt;
		&lt;/inspector&gt;
		&lt;metawidgetLayout&gt;
		&lt;tabbedPaneLayoutDecorator xmlns="java:org.metawidget.swing.layout"
			config="TabbedPaneLayoutDecoratorConfig"&gt;
			&lt;layout&gt;
				&lt;gridBagLayout config="GridBagLayoutConfig"&gt;
					&lt;numberOfColumns&gt;
						&lt;int&gt;2&lt;/int&gt;
					&lt;/numberOfColumns&gt;
				&lt;/gridBagLayout&gt;
			&lt;/layout&gt;
		&lt;/tabbedPaneLayoutDecorator&gt;
		&lt;/metawidgetLayout&gt;	
	&lt;/swingMetawidget&gt;

&lt;/metawidget&gt;</programlisting>			

				<para>
					Remove all the annotations from the <classname>Person</classname> class and run the code again.
					The ordering is still correct, and there is still a section heading, but this time it is being
					dictated by <classname>XmlInspector</classname>.
				</para>
				
				<para>
					This idea of UI characteristics being derivable from different back-end sources
					is fundamental to Metawidget. There is a lot of metadata already lurking in back-end
					systems - it just needs extracting. For example, <classname>JpaInspector</classname> understands this...
				</para>
				
				<programlisting language="java">import javax.persistence.Column;

public class Person {
	@Column( nullable = false )
	public String name;
}</programlisting>
	
				<para>
					...denotes <parameter>name</parameter> is a required field (could be rendered with a star after it in the UI). Equally,
					<classname>PropertyTypeInspector</classname> understands that...
				</para>
				
				<programlisting language="java">public class Person {
	private String name;
	
	public String getName() {
		return this.name;
	}
	
	// No setter
}</programlisting>
	
				<para>
					...signifies <parameter>name</parameter> is a read-only field (could be rendered as a label in the UI).
				</para>
				
				<para>
					Metawidget comes with a range of <classname>Inspector</classname>s, and it is straightforward
					to write your own to inspect anything from XML configuration files to database schemas
					to annotations. The inspection process is decoupled from the
					widget creation process, so the same inspector can supply information to multiple
					UI frameworks.
				</para>
				
			</section>
			
		</section>

		<section id="section-introduction-part2">
			<title>Part 2 - The Address Book Application</title>
			
			<para>
				Part 2 explores a more substantial application, and shows how Metawidget can be used to map the <emphasis>same</emphasis> back-end
				to <emphasis>multiple</emphasis> front-ends. We will develop an Address Book application with
				desktop-based, Web-based and mobile-based UIs.
			</para>
			
			<para>
				This tutorial should take around 45 minutes. To save time, we use the pre-built example
				applications located in the <filename>examples</filename> folder. Also to save time, we will not
				focus on any one front-end framework in detail. For detailed framework-specific instructions, please see 
				<xref linkend="chapter-metawidgets"/>.
			</para>
			
			<section id="section-introduction-part2-desktop">
				<title>Desktop Address Book</title>
				
				<para>
					The Desktop Address Book is essentially a larger version of the Swing application developed in
					Part 1 - it just has more business objects and more Swing widgets.
				</para>
				
				<para>
					The application is pre-built for you in <filename>examples\swing\addressbook-swing.jar</filename> or, if you've downloaded
					the source code distribution, you can build it yourself by changing to the <filename>examples</filename> folder of the
					source distribution and typing:
				</para>
				
				<programlisting language="shell">ant example-swing-addressbook</programlisting>
				
				<para>
					This is a self-executing JAR. For convenience, it has <filename>MAINFEST.MF</filename> dependencies hard-wired into it to <filename>..\..\metawidget.jar</filename> and
					<filename>lib\beansbinding.jar</filename> among others, so it's best not to move it to a different folder (if you do, you'll need to
					manually put <filename>metawidget.jar</filename> and <filename>beansbinding.jar</filename> on your classpath).
				</para>
				
				<para> 
					Run the code by navigating to the <filename>examples\swing</filename> folder and typing:
				</para>				
				
				<programlisting language="shell">java -jar addressbook-swing.jar</programlisting>
				
				<para>
					The opening screen displays a search filter (at the top) and lists
					existing Address Book entries (at the bottom) as in <xref linkend="section-introduction-part2-desktop-opening-screenshot"/>.
				</para>
				
				<figure id="section-introduction-part2-desktop-opening-screenshot">
					<title>Desktop Address Book opening screen</title>
					<screenshot>
						<graphic fileref="images/screenshots/desktop-addressbook1.jpg" width="100mm" />
					</screenshot>
				</figure>				
				
				<para>
					The three search filter fields (<parameter>Firstname</parameter>, <parameter>Surname</parameter> and <parameter>Type</parameter>)
					are created by <classname>SwingMetawidget</classname>
					based on the <classname>ContactSearch</classname> business class. This includes populating the <parameter>Type</parameter> dropdown based
					on the <classname>ContactType</classname>
					enum. The <guibutton>Search</guibutton>, <guibutton>Add Personal Contact</guibutton> and <guibutton>Add Business Contact</guibutton> buttons
					are created by <classname>SwingMetawidget</classname> based on annotated methods in the <classname>ContactDialog</classname> class.
				</para>
				
				<tip>
					<title>Note</title>
					To view the source code for the examples, such as the code for the <classname>ContactSearch</classname>,
					<classname>ContactType</classname> and <classname>ContactDialog</classname> classes, download the Metawidget
					source code distribution or browse it online at
					<ulink url="http://metawidget.svn.sourceforge.net/viewvc/metawidget/trunk/examples/src">http://metawidget.svn.sourceforge.net/viewvc/metawidget/trunk/examples/src</ulink>. 
				</tip>				

				<para>
					Click <guibutton>Add Personal Contact</guibutton>. The screen displays a form for filling out Personal Contact information
					as in <xref linkend="section-introduction-part2-desktop-add-screenshot"/>.
				</para>
				
				<figure id="section-introduction-part2-desktop-add-screenshot">
					<title>Desktop Address Book 'Add Personal Contact' screen</title>
					<screenshot>
						<graphic fileref="images/screenshots/desktop-addressbook2.jpg" width="100mm" />
					</screenshot>
				</figure>				

				<para>
					All the form fields are created by <classname>SwingMetawidget</classname> based on the <classname>PersonalContact</classname> business class.
					This class is itself derived from the <classname>Contact</classname> business class. It includes some Metawidget annotations
					for dropdown values and section headings.
				</para>
				
				<para>
					Note the code only has one <classname>JDialog</classname> class (<classname>ContactDialog</classname>), but is capable of supporting both
					<classname>PersonalContact</classname> and <classname>BusinessContact</classname> UIs. The fields in the UI change depending on
					the object passed to <classname>ContactDialog</classname> at runtime. This is the Third Goal Of Metawidget:
				</para>
				
			<important>
				<title>Third Goal Of Metawidget</title>			
					Metawidget performs inspection <emphasis>at runtime</emphasis>, detecting types and subtypes dynamically				
				</important>
				
				<para>
					The <parameter>Address</parameter> field is created as a nested <classname>SwingMetawidget</classname>. This is the default behaviour when Metawidget
					encounters datatypes it does not know how to represent with any other UI widget. The <parameter>Communications</parameter> field
					has been overridden with a manually specified <classname>JTable</classname>.
				</para>
				
				<para>
					In addition, <function>JTable.setCellEditor</function> uses <classname>SwingMetawidget</classname> to render single
					<classname>JComponents</classname> as <classname>CellEditors</classname>. This includes automatically populating dropdown values.
				</para>
				
				<section id="section-introduction-part2-desktop-readonly">
					<title>Read-Only Mode</title>

					<para>
						The Desktop Address Book uses Metawidget's <function>setReadOnly(true)</function> method to display
						read-only screens. Return to the main screen, and double-click on an existing contact (such as
						Homer Simpson). The same <classname>ContactDialog</classname> is used, but this time
						all the widgets are read-only labels as in <xref linkend="section-introduction-part2-desktop-readonly-screenshot"/>.
					</para>
					
					<figure id="section-introduction-part2-desktop-readonly-screenshot">
						<title>Desktop Address Book read-only mode</title>
						<screenshot>
							<graphic fileref="images/screenshots/desktop-addressbook3.jpg" width="100mm" />
						</screenshot>
					</figure>

					<para>
						Click <guibutton>Edit</guibutton>. The labels are transformed into editable widgets by using
						Metawidget's <function>setReadOnly(false)</function>, as in <xref linkend="section-introduction-part2-desktop-editable-screenshot"/>.
					</para>
					
					<figure id="section-introduction-part2-desktop-editable-screenshot">
						<title>Desktop Address Book edit mode</title>
						<screenshot>
							<graphic fileref="images/screenshots/desktop-addressbook4.jpg" width="100mm" />
						</screenshot>
					</figure>
					
				</section>
				
				<section id="section-introduction-part2-desktop-binding">
					<title>Binding</title>

					<para>
						The data from the <classname>PersonalContact</classname> object is automatically inserted into the
						<classname>JComponents</classname>. It is also automatically saved back when clicking <guibutton>Save</guibutton>.
					</para>
					
					<para>					
						Swing does not define a <classname>JComponent</classname> to <classname>Object</classname> mapping mechanism, so by default
						<classname>SwingMetawidget</classname> only supplies
						<function>setValue</function> and <function>getValue</function> methods for manually fetching values. This situation is no
						worse than a normal Swing application, but Metawidget can do better.
					</para>
				
					<para> 					
						<classname>SwingMetawidget</classname> directly supports third-party binding alternatives such as
						<ulink url="http://commons.apache.org/beanutils">Apache BeanUtils</ulink> and
						<ulink url="https://beansbinding.dev.java.net">Beans Binding (JSR 295)</ulink>
						via <function>SwingMetawidget.addWidgetProcessor</function>. These
						binding implementations automatically map <classname>JComponent</classname> values to <classname>Object</classname> values,
						including performing the necessary conversions, further reducing the amount of boilerplate code required.
					</para>
					
				</section>
				
				<section id="section-introduction-part2-desktop-i18n">
					<title>Localization</title>

					<para>
						All text within the application has been localized to the <classname>org.metawidget.example.shared.addressbook.resource.Resources</classname>
						resource bundle. Text created manually (such as the buttons) uses typical Swing localization code (eg. <function>bundle.getString</function>). Text created by
						<classname>SwingMetawidget</classname> uses <function>SwingMetawidget.setBundle</function>, which internally defers to <function>bundle.getString</function>.
					</para>
					
					<para>	
						Localization is very easy with Metawidget. For field names, if no resource bundle is supplied, Metawidget uses an 'uncamel-cased' version of the name. If
						a bundle <emphasis>is</emphasis> supplied, Metawidget uses the field name as the bundle key. For section labels, if a bundle is supplied,
						Metawidget uses a 'camel-cased' version of the label as the key.
					</para>
					
					<para>
						This means developers can initially
						build their UIs without worrying about resource bundles, then turn on localization support later.
					</para>
					
				</section>
				
			</section>
			
			<section id="section-introduction-part2-web">
				<title>Web Address Book</title>
				
				<para>
					As there are a large number of Java Web application frameworks to choose from, this example comes written
					in five of the most popular: Google Web Toolkit (GWT), Java Server Faces (JSF), Java Server Pages (JSP),
					Spring Web MVC and Struts. We recommend you follow along using the one most relevant to you.
				</para>
				
				<para>
					Web-based applications are inherently more difficult to setup and run than desktop-based
					applications because they require a container application. For
					this tutorial, we will use Apache Tomcat 6 (Tomcat), as it is one of the easier containers
					to get running. Tomcat can be downloaded from <ulink url="http://tomcat.apache.org">http://tomcat.apache.org</ulink>.
				</para>
				
				<para>
					Take a fresh install of Tomcat. The Address Book WAR is pre-built for you in
					either <filename>examples\faces\addressbook-faces.war</filename>, <filename>examples\gwt\addressbook-gwt.war</filename>,
					<filename>examples\jsp\addressbook-jsp.war</filename>, <filename>examples\spring\addressbook-spring.war</filename> or
					<filename>examples\struts\addressbook-struts.war</filename>. If you've downloaded the source code distribution, you can build it
					yourself by changing to the <filename>examples</filename> folder of the source distribution and typing:
				</para>
				
				<programlisting language="shell">ant example-faces-addressbook</programlisting>

				<para>
					(replacing <parameter>faces</parameter> with <parameter>gwt</parameter>, <parameter>jsp</parameter>, <parameter>spring</parameter> or <parameter>struts</parameter> as appropriate).
				</para>

				<tip>
					<title>Note</title>
					For most web environments, deploying Metawidget is as simple as adding <filename>metawidget.jar</filename> to
					<filename>WEB-INF\lib</filename>. For GWT, you'll also need to include <filename>metawidget.jar</filename>
					and <filename>examples\gwt\metawidget-gwt.jar</filename> in the <parameter>CLASSPATH</parameter>
					during your <parameter>GWTCompiler</parameter> step.
				</tip>				

				<para>
					Copy the WAR into Tomcat's <filename>webapps</filename> folder, start Tomcat, and open a Web browser
					to <ulink url="http://localhost:8080/addressbook-faces">http://localhost:8080/addressbook-faces</ulink>. The home page displays
					a search filter (at the top) and lists existing Address Book entries (at the bottom)
					as in <xref linkend="section-introduction-part2-web-opening-screenshot"/>.
				</para>
				
				<figure id="section-introduction-part2-web-opening-screenshot">
					<title>Web Address Book opening screen</title>
					<screenshot>
						<graphic fileref="images/screenshots/web-addressbook1.jpg" width="100mm" />
					</screenshot>
				</figure>

				<para>
					As with the Desktop Address Book, the three search filter fields are created
					by Metawidget (this time <classname>UIMetawidget</classname>, <classname>GwtMetawidget</classname>, <classname>HtmlMetawidgetTag</classname>,
					<classname>SpringMetawidgetTag</classname>
					or <classname>StrutsMetawidgetTag</classname>) based on the <classname>ContactSearch</classname> business class:
				</para>
				
				<programlisting language="jsp">&lt;m:metawidget value="#{contact.search}"&gt;
	...
&lt;/m:metawidget&gt;</programlisting>
				
				<para>
 					Again, this includes populating the <parameter>Type</parameter> dropdown and localizing the text. The <guibutton>Search</guibutton>,
					<guibutton>Add Personal Contact</guibutton> and <guibutton>Add Business Contact</guibutton> buttons are either manually specified
					in the JSP page (for GWT, Spring and Struts) or created by <classname>UIMetawidget</classname> based on annotated methods
					in the <classname>ContactBean</classname> (for JSF).
				</para>
								
				<tip>
					<title>Note</title>
					As with the Desktop Address Book, all source code for the examples can be found in the
					source code distribution under
					<filename>examples/src/java/org/metawidget/example</filename>.
					All Web-specific resources (such as JSP files) can be found under
					<filename>examples/src/web</filename>.
				</tip>				

				<para>
					The look of the Web page relies entirely on HTML and CSS technologies. These are configured in <filename>metawidget.xml</filename>:
				</para>

				<programlisting language="xml">&lt;htmlMetawidget&gt;
	&lt;parameter&gt;
		&lt;string&gt;tableStyleClass&lt;/string&gt;
		&lt;string&gt;table-form&lt;/string&gt;
	&lt;/parameter&gt;
	&lt;parameter&gt;
		&lt;string&gt;columnClasses&lt;/string&gt;
		&lt;string&gt;table-label-column,table-component-column,table-required-column&lt;/string&gt;
	&lt;/parameter&gt;
	...</programlisting>
	
				<para>
					Only the layout	of 'one column for the label, one column for the widget' is dictated by Metawidget, and that is again
					pluggable and configurable.
				</para>
				
				<para>
					Click <guibutton>Add Personal Contact</guibutton>. The page displays a form for filling out Personal Contact information
					as in <xref linkend="section-introduction-part2-web-add-screenshot"/>.
				</para>
				
				<figure id="section-introduction-part2-web-add-screenshot">
					<title>Web Address Book 'Add Personal Contact' screen</title>
					<screenshot>
						<graphic fileref="images/screenshots/web-addressbook2.jpg" width="100mm" />
					</screenshot>
				</figure>

				<para>
					All the form fields are created by Metawidget based on the <classname>PersonalContact</classname> business class. The section headings
					are the same, but have this time been rendered as HTML.
				</para>
				
				<para>
					The <parameter>Address</parameter> field is a nested Metawidget. The <parameter>Communications</parameter> field
					has been overridden in the JSP page with a manually specified table. <classname>UIMetawidget</classname> understands a manually-specified widget to
					override an automatic one if it has the same <parameter>value</parameter> binding as the automatic
					widget would have (<classname>GwtMetawidget</classname>, <classname>SpringMetawidgetTag</classname> and <classname>StrutsMetawidgetTag</classname> do
					something similar):
				</para>
				
				<programlisting language="jsp">&lt;m:metawidget value="#{contact.current}"&gt;
	...		
	&lt;h:dataTable value="#{contact.current.communications}"&gt;
		...
	&lt;/h:dataTable&gt;						
	...							
&lt;m:metawidget&gt;</programlisting>
				
				<para>
					JSF has built-in support for executing actions on table rows. In order to use it, however, the <classname>Set</classname>
					returned by <function>Contact.getCommunications</function> must be wrapped into a <classname>DataModel</classname>. This is handled by
					<function>ContactController.getCurrentCommunications</function>, but this presents a problem: the mapping for the
					<classname>HtmlDataTable</classname> must be <parameter>#{contact.currentCommunications}</parameter>, but the mapping required to override
					<classname>UIMetawidget</classname>'s automatic widget creation is <parameter>#{contact.current.communications}</parameter>.
				</para>
				
				<para>
					<classname>UIMetawidget</classname> supplies <classname>UIStub</classname> for these situations. Stubs have a binding, but do nothing with it
					and render nothing. They can be used either to suppress widget creation entirely (a stub
					with an empty body) or to replace the automatic widget creation with one or more other widgets
					with different bindings:
				</para>
				
				<programlisting language="jsp">&lt;m:metawidget value="#{contact.current}"&gt;
	...		
	&lt;m:stub value="#{contact.current.communications}"&gt;
		&lt;h:dataTable value="#{contact.currentCommunications}"&gt;
			...
		&lt;/h:dataTable&gt;						
	&lt;/m:stub&gt;						
	...							
&lt;m:metawidget&gt;</programlisting>

				<para>
					JSP, Spring, Struts lack some component-based features found in Swing and JSF. Specifically,
					whilst it is possible for tags to reference their <emphasis>parent</emphasis>
					(using <function>TagSupport.findAncestorWithClass</function>), they have no way to interrogate
					their <emphasis>children</emphasis>. Therefore, it is not possible to directly support arbitrary child tags
					within <classname>HtmlMetawidget</classname>, <classname>SpringMetawidgetTag</classname> and <classname>StrutsMetawidgetTag</classname>.
				</para>

				<para>
					Instead, we wrap the overridden <parameter>Communications</parameter> field in Metawidget's <classname>Stub</classname> tag. Metawidget
					and its Stub tags have explicit	support for co-ordinating the overriding of widget creation:
				</para>
				
				<programlisting language="jsp">&lt;m:metawidget property="contactForm"&gt;
	...		
	&lt;m:stub property="communications"&gt;
		&lt;table class="data-table"&gt;
			...
		&lt;/table&gt;
	&lt;/m:stub&gt;						
	...							
&lt;m:metawidget&gt;</programlisting>

				<para>
					<classname>GwtMetawidget</classname> uses stubs around GWT widgets like <classname>FlexTable</classname>, but can use
					the overriding widget directly if it supports the <classname>HasName</classname> interface (eg. TextBox, CheckBox, etc).
				</para>

				<section id="section-introduction-part2-web-mixing">
					<title>Mixing Metawidgets</title>
					
					<para>
						The section is specific to Spring/Struts.
					</para>

					<para>
						Within the <parameter>Communications</parameter> table, implementing <guibutton>Add Communication</guibutton> calls for a design decision.
						Struts does not support multiple <classname>ActionForms</classname> per <classname>Action</classname>, so we are unable to combine
						<classname>PersonalContactForm</classname> with a <classname>CommunicationForm</classname> (as we did in the JSF). Spring has a similar
						limitation of not supporting multiple <parameter>commandNames</parameter> per form. Instead, we need to either:
					</para>
					
					<itemizedlist>
						<listitem>
							<para>
								add fields from <classname>Communication</classname> to <classname>PersonalContactForm</classname>, and ignore them when
								saving the <classname>PersonalContact</classname>; or
							</para>
						</listitem>
						<listitem>
							<para>
						 		output plain HTML tags (ie. independent of Spring and Struts) and handle them manually
						 	</para>
						 </listitem>
					</itemizedlist>
					
					<para>
						Both approaches would be valid. For this tutorial, we choose the latter as it allows us to introduce <classname>HtmlMetawidget</classname>
						(a Metawidget for plain HTML/JSP webapps that don't use Struts or Spring) and demonstrate <emphasis>mixing</emphasis> two Metawidgets on
						the same page:
					</para>
	
					<programlisting language="jsp"><symbol>&lt;m:metawidget property="contactForm"&gt;</symbol>
	...
	&lt;m:stub property="communications"&gt;
		&lt;table class="data-table"&gt;
		...
		&lt;tr&gt;
			&lt;jsp:useBean id="communication"
							class="org.metawidget.example.shared.addressbook.model.Communication"/&gt;		
			&lt;td&gt;<symbol>&lt;mh:metawidget value="communication.type" style="width: 100%" /&gt;</symbol>&lt;/td&gt;
			&lt;td&gt;<symbol>&lt;mh:metawidget value="communication.value" style="width: 100%" /&gt;</symbol>&lt;/td&gt;
		&lt;/tr&gt;
		...
		&lt;/table&gt;
	&lt;/m:stub&gt;
	...
<symbol>&lt;/m:metawidget&gt;</symbol></programlisting>
	
					<para>
						The two different tag prefixes <parameter>m:</parameter> and <parameter>mh:</parameter> denote different tag libraries. 
						<classname>HtmlMetawidget</classname> is very similiar to <classname>StrutsMetawidgetTag</classname>, but has to use
						<parameter>jsp:useBean</parameter> to manually instantiate the bean (rather than letting Struts do it). 
						Within <filename>metawidget.xml</filename>, the default layout for <classname>HtmlMetawidget</classname> has been
						set to <classname>org.metawidget.jsp.tagext.layout.SimpleLayout</classname> (ie. a plain layout, without a label column)
					</para>
					
				</section>				
				
				<section id="section-introduction-part2-web-expression-lookup">
					<title>Expression Based Lookups</title>
					
					<para>
						This section does not apply to GWT.
					</para>

					<para>
						In the Desktop Address Book, the <parameter>title</parameter> dropdown was populated by
						a static <parameter>lookup</parameter> attribute in <filename>metawidget-metadata.xml</filename>. JSP and JSF-based technologies can do better, because they have a built-in
						scope-based component model and Expression Language.
					</para>
					
					<para>
						<function>Contact.getTitle</function> is annotated
						using <classname>@UiFacesLookup</classname> and <classname>@UiSpringLookup</classname> (and <function>ContactForm.getTitle</function>
						is annotated using <classname>@UiStrutsLookup</classname>). These are used at runtime to create dynamic lookups.
					</para>
					
					<para>
						These annotations, unlike the ones we have used so far, <emphasis>are</emphasis> UI-framework specific so you may prefer
						to declare them in <filename>metawidget-metadata.xml</filename>. Before doing so, however, you should understand we are still
						not introducing runtime dependencies into our business classes: an important feature of annotations is they 'fall away gracefully'
						if their implementing class is not found. Annotations never throw <classname>ClassDefNotFoundError</classname>.
					</para>
					
				</section>

				<section id="section-introduction-part2-web-richfaces">
					<title>Alternate Widget Libraries</title>
					
					<para>
						This section is specific to JSF.
					</para>
					
					<para>
						Metawidget factors all widget creation into <classname>WidgetBuilder</classname>s. Like <classname>Inspector</classname>s, multiple
						<classname>WidgetBuilder</classname>s can be combined using a <classname>CompositeWidgetBuilder</classname> to support third-party component
						libraries. In this section we will override Metawidget's default and introduce a <classname>RichFacesWidgetBuilder</classname>
						alongside the standard JSF <classname>HtmlWidgetBuilder</classname>. 
					</para>
					
					<para>
						Go into Tomcat's <filename>webapps\addressbook-faces</filename> folder (the exploded WAR) and
						edit <filename>WEB-INF/metawidget.xml</filename>:
					</para>
					
					<programlisting language="xml">&lt;metawidget xmlns="http://metawidget.org"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	version="1.0"
	xsi:schemaLocation="http://metawidget.org http://metawidget.org/xsd/metawidget-1.0.xsd"&gt;

&lt;htmlMetawidget xmlns="java:org.metawidget.faces.component.html"&gt;
	...
	&lt;inspector&gt;		
		&lt;compositeInspector xmlns="java:org.metawidget.inspector.composite"
								config="CompositeInspectorConfig"&gt;
			&lt;inspectors&gt;
			&lt;array&gt;
				&lt;propertyTypeInspector xmlns="java:org.metawidget.inspector.propertytype"/&gt;
				&lt;metawidgetAnnotationInspector xmlns="java:org.metawidget.inspector.annotation"/&gt;
				&lt;java5Inspector xmlns="java:org.metawidget.inspector.java5"/&gt;
				&lt;facesInspector xmlns="java:org.metawidget.inspector.faces"/&gt;			
				&lt;xmlInspector xmlns="java:org.metawidget.inspector.xml" config="XmlInspectorConfig"/&gt;
			&lt;/array&gt;
			&lt;/inspectors&gt;
		&lt;/compositeInspector&gt;
	&lt;/inspector&gt;
	<symbol>&lt;widgetBuilder&gt;
		&lt;compositeWidgetBuilder xmlns="java:org.metawidget.widgetbuilder.composite"
			config="CompositeWidgetBuilderConfig"&gt;
			&lt;widgetBuilders&gt;
				&lt;array&gt;
					&lt;overriddenWidgetBuilder xmlns="java:org.metawidget.faces.component.widgetbuilder"/&gt;
					&lt;readOnlyWidgetBuilder xmlns="java:org.metawidget.faces.component.html.widgetbuilder"/&gt;
					&lt;richFacesWidgetBuilder xmlns="java:org.metawidget.faces.component.html.widgetbuilder.richfaces"/&gt;
					&lt;htmlWidgetBuilder xmlns="java:org.metawidget.faces.component.html.widgetbuilder"/&gt;
				&lt;/array&gt;
			&lt;/widgetBuilders&gt;
		&lt;/compositeWidgetBuilder&gt;
	&lt;/widgetBuilder&gt;</symbol>
	&lt;layout&gt;
		&lt;outputTextLayoutDecorator xmlns="java:org.metawidget.faces.component.html.layout"
			config="OutputTextLayoutDecoratorConfig"&gt;
			&lt;layout&gt;
				&lt;simpleLayout xmlns="java:org.metawidget.faces.component.layout"/&gt;
			&lt;/layout&gt;
			&lt;styleClass&gt;
				&lt;string&gt;section-heading&lt;/string&gt;
			&lt;/styleClass&gt;
		&lt;/outputTextLayoutDecorator&gt;
	&lt;/layout&gt;	
&lt;/htmlMetawidget&gt;

&lt;/metawidget&gt;</programlisting>
	
					<para>
						Now restart Tomcat, refresh your Web browser and click on Homer Simpson. Notice how the
						<parameter>Date of Birth</parameter> field for Personal Contacts is now a RichFaces date picker
						widget, and the <parameter>Number of Staff</parameter> field for Business Contacts is a RichFaces slider widget.
					</para>
					
					<para>
						Going futher, Metawidget's pluggable layouts make it easy to support third-party layout components.
						Edit <filename>WEB-INF/metawidget.xml</filename> again:
					</para>
					
					<programlisting language="xml">&lt;metawidget xmlns="http://metawidget.org"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	version="1.0"
	xsi:schemaLocation="http://metawidget.org http://metawidget.org/xsd/metawidget-1.0.xsd"&gt;

&lt;htmlMetawidget xmlns="java:org.metawidget.faces.component.html"&gt;
	...
	&lt;inspector&gt;		
		&lt;compositeInspector xmlns="java:org.metawidget.inspector.composite"
								config="CompositeInspectorConfig"&gt;
			&lt;inspectors&gt;
			&lt;array&gt;
				&lt;propertyTypeInspector xmlns="java:org.metawidget.inspector.propertytype"/&gt;
				&lt;metawidgetAnnotationInspector xmlns="java:org.metawidget.inspector.annotation"/&gt;
				&lt;java5Inspector xmlns="java:org.metawidget.inspector.java5"/&gt;
				&lt;facesInspector xmlns="java:org.metawidget.inspector.faces"/&gt;			
				&lt;xmlInspector xmlns="java:org.metawidget.inspector.xml" config="XmlInspectorConfig"/&gt;
			&lt;/array&gt;
			&lt;/inspectors&gt;
		&lt;/compositeInspector&gt;
	&lt;/inspector&gt;
	&lt;widgetBuilder&gt;
		&lt;compositeWidgetBuilder xmlns="java:org.metawidget.widgetbuilder.composite"
			config="CompositeWidgetBuilderConfig"&gt;
			&lt;widgetBuilders&gt;
				&lt;array&gt;
					&lt;overriddenWidgetBuilder xmlns="java:org.metawidget.faces.component.html.widgetbuilder"/&gt;
					&lt;readOnlyWidgetBuilder xmlns="java:org.metawidget.faces.component.html.widgetbuilder"/&gt;
					&lt;richFacesWidgetBuilder xmlns="java:org.metawidget.faces.component.html.widgetbuilder.richfaces"/&gt;
					&lt;htmlWidgetBuilder xmlns="java:org.metawidget.faces.component.html.widgetbuilder"/&gt;
				&lt;/array&gt;
			&lt;/widgetBuilders&gt;
		&lt;/compositeWidgetBuilder&gt;
	&lt;/widgetBuilder&gt;
	&lt;layout&gt;
		<symbol>&lt;tabPanelLayoutDecorator xmlns="java:org.metawidget.faces.component.html.layout.richfaces"
			config="TabPanelLayoutDecoratorConfig"&gt;</symbol>
			&lt;layout&gt;
				&lt;simpleLayout xmlns="java:org.metawidget.faces.component.layout"/&gt;
			&lt;/layout&gt;
		<symbol>&lt;/tabPanelLayoutDecorator&gt;</symbol>
	&lt;/layout&gt;	
&lt;/htmlMetawidget&gt;

&lt;/metawidget&gt;</programlisting>

					<para>
						Restart Tomcat, refresh your Web browser and click on Homer Simpson again. Notice how the
						<parameter>Contact Details</parameter> and <parameter>Other</parameter> sections are
						laid out as tabs within a RichFaces <classname>TabPanel</classname> as in
						<xref linkend="section-introduction-part2-web-richfaces-screenshot"/>.						
					</para>

					<figure id="section-introduction-part2-web-richfaces-screenshot">
						<title>Web Address Book using JBoss RichFaces</title>
						<screenshot>
							<graphic fileref="images/screenshots/web-addressbook-richfaces.jpg" width="100mm" />
						</screenshot>
					</figure>

					<para>
						This demonstrates how easy it is to leverage widget libraries with Metawidget
						(this example cheats a bit, as we've pre-added the RichFaces JARs into <filename>WEB-INF\lib</filename> and some
						lines into <filename>web.xml</filename>, but you get the idea).					
					</para>
					
				</section>

			</section>

			<section id="section-introduction-part2-mobile">
				<title>Mobile Address Book</title>
				
				<para>
					For the Mobile Address Book we use the Android platform. Android has uniquely strong support for reflection
					and annotations, and guarantees the availability of key packages such as <classname>org.w3c.dom</classname>. This affords
					Metawidget excellent runtime access to inspect the <emphasis>O</emphasis> in OIM.
				</para>
				
				<para>
					Like Web-based applications, Mobile applications require a container to run. Download the Android SDK (Metawidget has been
					tested against versions 1.1, 1.5, 1.6 and 2.0) from <ulink url="http://code.google.com/android/download.html">http://code.google.com/android/download.html</ulink>.
					Then change to the installation directory (usually <filename>android-sdk-windows</filename>) and run the emulator by
					opening a command prompt and typing:
				</para>
				
				<programlisting language="shell">tools\android create avd -n my_avd -t 1</programlisting>
				
				<para>
					Replacing <parameter>-t 1</parameter> with the Android version you're using (eg. <parameter>-t 2</parameter> for
					1.5, <parameter>-t 3</parameter> for 1.6, <parameter>-t 4</parameter> for 2.0). Android 1.1 doesn't use AVDs, so you can skip
					this step. Next type:
				</para>
				
				<programlisting language="shell">tools\emulator -avd my_avd</programlisting>
				
				<para>
					The emulator may take a little while to start. Once finished, it will display the phone's desktop. The Address Book APK
					is pre-built for you in <filename>examples\android\addressbook-android.apk</filename>. If you've downloaded the source code distribution, you
					can build it yourself by changing to the <filename>examples</filename> folder of the source distribution and typing:
				</para>
				
				<programlisting language="shell">ant example-android-addressbook</programlisting>

				<para>
					(ensuring your <filename>build.properties</filename> is set correctly to point to the Android SDK).
				</para>

				<para>				
					Next, open a <emphasis>second</emphasis> command prompt, change to the Android installation directory and type:
				</para>
				
				<programlisting language="shell">tools\adb install &lt;metawidget folder&gt;\examples\android\addressbook-android.apk</programlisting>
				
				<para>
					This deploys the APK into the emulator. To run it, click the emulator's <parameter>Menu</parameter> button and
					then choose the Address Book application. The emulator displays a search filter (at the top) and lists existing
					Address Book entries (at the bottom) as in <xref linkend="section-introduction-part2-mobile-opening-screenshot"/>.
				</para>
				
				<figure id="section-introduction-part2-mobile-opening-screenshot">
					<title>Mobile Address Book opening screen</title>
					<screenshot>
						<graphic fileref="images/screenshots/mobile-addressbook1.jpg" width="60mm" />
					</screenshot>
				</figure>

				<para>
					As with the Desktop and Web Address Books, the three search filter fields are created
					by Metawidget (this time <classname>AndroidMetawidget</classname>) based on the <classname>ContactSearch</classname> business class.
					Again, this includes populating the <parameter>Type</parameter> dropdown.
				</para>

				<tip>
					<title>Note</title>
					As with the Desktop Address Book, all source code for the examples can be found in the
					source code distribution under
					<filename>examples/src/java/org/metawidget/example</filename>.
					All Android-specific resources (such as XML files) can be found under
					<filename>examples/src/android</filename>.
				</tip>				

				<para>
					The look of the screen relies entirely on Android XML layout files, styles and themes. Only the 'one column for the label, one column
					for the widget' layout is dictated by Metawidget, and that is pluggable and configurable.
				</para>

				<para>
					Choose <guibutton>Add Personal</guibutton> from the Android menu. The page displays a form for filling out Personal Contact information
					as in <xref linkend="section-introduction-part2-mobile-add-screenshot"/>.
				</para>
				
				<figure id="section-introduction-part2-mobile-add-screenshot">
					<title>Mobile Address Book 'Add Personal Contact' screen</title>
					<screenshot>
						<graphic fileref="images/screenshots/mobile-addressbook2.jpg" width="60mm" />
					</screenshot>
				</figure>

				<para>
					UIs in Android are typically defined in XML layout files, though they can also be built programmatically.
					<classname>AndroidMetawidget</classname> supports both approaches. For example, the Personal Contact screen is
					defined in <filename>contact.xml</filename>, and contains a Metawidget defined in much the same way as in
					JSP (including configuring section style and overriding widget creation): 
				</para>

				<programlisting language="xml">&lt;view class="org.metawidget.android.widget.AndroidMetawidget" android:id="@+id/metawidget"
	config="@raw/metawidget"&gt;
	
	&lt;view class="org.metawidget.android.widget.Stub" tag="communications"&gt;
			
		&lt;ListView android:id="@id+/communications" ... /&gt;
	 			
		&lt;Button android:id="@+id/buttonAddCommunication"
			android:text="@string/addCommunication" ... /&gt;
	
	&lt;/view&gt;
 
&lt;/view&gt;</programlisting>
				
				<para>
					Within <classname>CommunicationDialog</classname>, a Metawidget is defined programatically in much the same way as in
					Swing:
				</para>
				
				<programlisting language="java">mMetawidget = new AndroidMetawidget( activity );
mMetawidget.setConfig( R.raw.config );				
...
mMetawidget.setToInspect( mCommunication );</programlisting>
				
				<para>
					This produces the dialog box in <xref linkend="section-introduction-part2-mobile-dialog-screenshot"/>.
				</para>
				
				<figure id="section-introduction-part2-mobile-dialog-screenshot">
					<title>Mobile Address Book Communications Dialog</title>
					<screenshot>
						<graphic fileref="images/screenshots/mobile-addressbook3.jpg" width="60mm" />
					</screenshot>
				</figure>

			</section>

			<section>
				<title>Conclusion</title>
				
				<para>
					That concludes the introductory tutorial. In summary, we now:
				</para>
	
				<itemizedlist>
					<listitem>
						<para>
							have seen how to build an application whose UI is largely dictated by its business classes, not by hand-written UI code
						</para>
					</listitem>
					<listitem>
						<para>
							significantly reduced the amount of UI code needed in our applications
						</para>
					</listitem>
					<listitem>
						<para>
							have seen how to build an application that targets multiple platforms. If we were to add a new field to one of the business classes
							(say, <parameter>numberOfChildren</parameter> to <classname>PersonalContact</classname>), it would automatically appear
							and be functional on every platform.
						</para>
					</listitem>
				</itemizedlist>
			</section>

		</section>
			
		<section id="section-introduction-part3-other-examples">
			<title>Part 3 - Other Examples</title>
			
			<para>
				The Metawidget distribution includes other examples showcasing particular features
				on particular platforms. These additional examples are not a required part of the tutorial,
				but you may find them useful depending on which platform you use.
			</para>
	
			<section id="section-introduction-part3-applet">
				<title>Swing Applet Address Book Example</title>
	
				<para>
					The Swing Applet Address Book Example demonstrates using Metawidget in applets. The example is pre-built for you in
					<filename>examples\swing\applet\addressbook</filename>. If you've downloaded the source code distribution, you can build it
					yourself by changing to the <filename>examples</filename> folder of the source distribution and typing:
				</para>
				
				<programlisting language="shell">ant example-swing-addressbook-applet</programlisting>

				<para>
					To run the applet, open the <filename>index.html</filename> file in a Web browser. The code
					is identical to the Swing Address Book covered in Part 2 of this tutorial, except
					it uses <classname>org.metawidget.example.swing.applet.AddressBookApplet</classname> instead
					of <classname>org.metawidget.example.swing.addressbook.MainFrame</classname>.
				</para>

				<para>
					The notable feature of the example is how the applet is packaged. Metawidget is highly modular and has no
					mandatory third-party JAR dependencies. The <filename>example-swing-addressbook-applet</filename> Ant task
					builds only those inspectors necessary for the Address Book application. The resulting <filename>metawidget-applet.jar</filename> is
					then further compressed using <filename>pack200</filename>. The small download size
					makes Metawidget very viable for Applet-based environments.
				</para>
	
			</section>
			
			<section id="section-introduction-part3-seam">
				<title>Seam Example</title>
	
				<para>
					The Seam Booking Example demonstrates updating an existing Seam application to use Metawidget, reducing
					boilerplate code. The example requires you to have previously downloaded <ulink url="http://seamframework.org/Download">Seam 2.2.0.GA</ulink>
					and <ulink url="http://jboss.org/jbossas/downloads">JBoss 5.1.0.GA</ulink>, and you should be <ulink url="http://docs.jboss.com/seam/latest/reference/en-US/html/tutorial.html">familiar with the existing Seam Booking application</ulink>.
				</para>
				
				<para>
					The example is located in <filename>examples\faces\seam\booking</filename>. It is
					not pre-built. To build it, change to the <filename>examples\faces\seam\booking</filename> folder in
					the Metawidget binary distribution and type:
				</para>
				
				<programlisting language="shell">ant</programlisting>

				<para>
					To run it, type:
				</para>

				<programlisting language="shell">cd \Applications\jboss-5.1.0.GA
bin\run</programlisting>

				<para>
					Open a Web browser to <ulink url="http://localhost:8080/seam-booking">http://localhost:8080/seam-booking</ulink>. The updated Metawidget
					Seam Booking Example looks very similar to the original, as in <xref linkend="section-introduction-part3-seam-screenshot"/>,
					but uses significantly less boilerplate code.
				</para>
				
				<figure id="section-introduction-part3-seam-screenshot">
					<title>Seam Booking with Metawidget</title>
					<screenshot>
						<graphic fileref="images/screenshots/web-seam-booking.jpg" width="100mm" />
					</screenshot>
				</figure>
								
				<para>
					The files modified for adding Metawidget support are in <filename>examples\faces\seam\booking</filename>. Most of the
					UI code in <filename>view\book.xhtml</filename>, <filename>view\confirm.xhtml</filename> and
					<filename>view\hotelview.xhtml</filename> has been replaced with a single Metawidget tag. Some annotations
					have been added to <filename>Hotel.java</filename> and <filename>Booking.java</filename>, though
					Metawidget also leverages the existing JPA and Hibernate Validator ones.
				</para>
				
				<para>
					The example further demonstrates packaging Metawidget for multi-tier environments. The <filename>pack-as-frontend-backend</filename>
					Ant task in Metawidget's <filename>build.xml</filename> creates two JAR files: <filename>metawidget-frontend.jar</filename> for
					deployment in the WAR, and <filename>metawidget-backend.jar</filename> for deployment in the EJB layer. This ensures a clean
					separation between frontend and backend code, and is important for avoiding	WAR/EJB classloading problems.
				</para>
				
			</section>

			<section id="section-introduction-part3-groovy">
				<title>Groovy Example</title>

				<para>
					The Seam Groovy Booking Example demonstrates updating an existing Seam Groovy application to 
					use Metawidget, reducing boilerplate code. The example is a more advanced version of the previous Seam section, so you
					should work through that first.
				</para>

				<para>
					The example is located in <filename>examples\faces\seam\groovybooking</filename>. It is
					not pre-built. To build it, change to the <filename>examples\faces\seam\groovybooking</filename> folder in
					the Metawidget binary distribution and type:
				</para>
				
				<programlisting language="shell">ant</programlisting>

				<para>
					To run it, type:
				</para>

				<programlisting language="shell">cd \Applications\jboss-5.1.0.GA
bin\run</programlisting>

				<para>
					Open a Web browser to <ulink url="http://localhost:8080/jboss-seam-groovybooking">http://localhost:8080/jboss-seam-groovybooking</ulink>. As with the previous
					section, the updated Metawidget Seam Groovy Booking Example looks very similar to the original, but
					uses significantly less	boilerplate code. Also, this time we are using Groovy to define
					our business classes. The biggest impact this has is in <filename>metawidget.xml</filename>,
					where the inspectors have been configured to use a Groovy property style instead of a JavaBean
					property style.
				</para>
				
				<para>
					Metawidget supports pluggable 'property styles' for JavaBean, Groovy and other property styles.
					Groovy properties differ from JavaBean properties in that their annotations are tied to
					the private member variable, rather than the getters and setters. The use of Groovy is configured
					per <classname>Inspector</classname>, as in <filename>examples\faces\seam\groovybooking\resources\WEB-INF\metawidget.xml</filename>:
				</para>

				<programlisting language="xml">&lt;propertyTypeInspector config="org.metawidget.inspector.impl.BaseObjectInspectorConfig"&gt;
	&lt;propertyStyle&gt;
		&lt;groovyPropertyStyle xmlns="java:org.metawidget.inspector.impl.propertystyle.groovy"/&gt;
	&lt;/propertyStyle&gt;
&lt;/propertyTypeInspector&gt;</programlisting>

			</section>
			
			<section id="section-introduction-part3-jbpm">
				<title>jBPM Example</title>
		
				<para>
					The Seam DVD Store Example demonstrates updating an existing Seam jBPM application to use Metawidget, reducing
					boilerplate code. The example requires you to have previously downloaded Seam 2.2.0.GA
					and JBoss 5.1.0.GA, and you should be familiar with the existing Seam DVD Store application.
				</para>

				<para>
					The example is located in <filename>examples\faces\seam\dvdstore</filename>. It is
					not pre-built. To build it, change to the <filename>examples\faces\seam\dvdstore</filename> folder in
					the Metawidget binary distribution and type:
				</para>
				
				<programlisting language="shell">ant</programlisting>

				<para>
					To run it, type:
				</para>

				<programlisting language="shell">cd \Applications\jboss-5.1.0.GA
bin\run</programlisting>

				<para>
					Open a Web browser to <ulink url="http://localhost:8080/seam-dvdstore">http://localhost:8080/seam-dvdstore</ulink>. As with the previous
					two sections, the updated Metawidget Seam DVD Store example looks very similar to the original, 
					as in <xref linkend="section-introduction-part3-jbpm-screenshot"/>, but
					uses significantly less	boilerplate code.
				</para>
				
				<figure id="section-introduction-part3-jbpm-screenshot">
					<title>Seam DVD Store with Metawidget</title>
					<screenshot>
						<graphic fileref="images/screenshots/web-seam-dvd.jpg" width="100mm" />
					</screenshot>
				</figure>
				
				<para>
 					This time, as well as generating <classname>UIComponents</classname>
					for business objects such as <classname>com.jboss.dvd.seam.Customer</classname>, Metawidget inspects jBPM
					pageflow files like
					<filename>newuser.jpdl.xml</filename> and <filename>checkout.jpdl.xml</filename> to generate the
					correct <classname>UICommand</classname> buttons for each screen.				
				</para>

			</section>
			
			<section id="section-introduction-part3-icefaces">
				<title>ICEfaces Example</title>
	
				<para>
					<ulink url="http://icefaces.org">ICEfaces</ulink> is an AJAX component library for Java Server Faces. This example
					showcases how Metawidget can work with ICEfaces (1.8.2 and above) to deliver rich AJAX applications.
				</para>

				<para>
					The example is pre-built for you in <filename>examples\faces\penguincolony-faces.war</filename>. Copy the WAR into
					Tomcat's <filename>webapps</filename> folder, start Tomcat, and open a Web browser
					to <ulink url="http://localhost:8080/penguincolony-faces">http://localhost:8080/penguincolony-faces</ulink>:
				</para>

				<figure id="section-introduction-part3-icefaces-screenshot">
					<title>ICEfaces with Metawidget</title>
					<screenshot>
						<graphic fileref="images/screenshots/web-penguincolony.jpg" width="100mm" />
					</screenshot>
				</figure>

				<para>
					The application manages details of penguins in a colony. To begin, click the <guibutton>Edit</guibutton> link in the first row of the table:
					ICEfaces and Metawidget work together to pop up an AJAX form without refreshing the page. Next, clear the form's
					<parameter>Name</parameter> box and tab to the next field: an AJAX call is made and a validation error appears. Try
					entering a new name and tabbing again: the validation error disappears and the new name is immediately reflected in
					the table behind the popup box.
				</para>
				
				<para>
					The example also makes use of the <classname>@UiFacesAttribute</classname> annotation. For example, the Java code is
					annotated:
				</para>
				
				<programlisting language="java">@UiAction
@UiFacesAttribute( name = InspectionResultConstants.HIDDEN,
	expression = "#{!empty penguin.current.condition}" )
public void addCondition() { ... }

@UiFacesAttribute( name = InspectionResultConstants.HIDDEN,
	expression = "#{empty penguin.current.condition}" )
public PenguinCondition getCondition() { ...}</programlisting>
				
				<para>
					Clicking the <guibutton>Add Condition</guibutton> button, or checking one of the <parameter>Hobbies</parameter> checkboxes,
					triggers an AJAX call that re-evaluates the	<classname>@UiFacesAttribute</classname> annotations and dynamically reconstructs the
					form without requiring a page refresh. This includes removing existing buttons, creating new dropdown boxes and creating
					new labels.
				</para>
				
				<para>
					For more details on ICEfaces support, see <xref linkend="section-widgetbuilders-icefaces"/>.
				</para>
								
			</section>

			<section id="section-introduction-part3-swingappframework">
				<title>Swing AppFramework Example</title>
	
				<para>
					The Swing AppFramework Car Demo demonstrates using Metawidget with the
					<ulink url="https://appframework.dev.java.net">Swing AppFramework</ulink>. Metawidget
					can use Swing AppFramework's <classname>@Action</classname> annotation to identify actions, both amongst
					a business object's properties and in external controllers, and automatically generate <classname>JButtons</classname>
					for them.
				</para>
	
				<para>
					The application is pre-built for you in <filename>examples\swing\appframework-swing.jar</filename> or, if you've downloaded
					the source code distribution, you can build it yourself by changing to the <filename>examples</filename> folder of the source
					distribution and typing:
				</para>
				
				<programlisting language="shell">ant example-swing-appframework</programlisting>
				
				<tip>
					<title>Note</title>
					This example uses annotations, so you'll need Java SE 5 or higher
				</tip>

				<para>
					This is a self-executing JAR. For convenience, it has <filename>MAINFEST.MF</filename> dependencies hard-wired into it to
					<filename>..\..\metawidget.jar</filename> and <filename>lib\AppFramework.jar</filename> among others, so it's best not to move
					it to a different folder (if you do, you'll need to manually put those JARs on your classpath).
				</para>
				
				<para> 
					Run the code by navigating to the <filename>examples\swing</filename> folder and typing:
				</para>				
				
				<programlisting language="shell">java -jar appframework-swing.jar</programlisting>
				
				<para>
					The opening screen displays two fields to allow you to enter the make and type of a car. You can also optionally
					add an owner by clicking the <guibutton>Add an Owner</guibutton> button, or save the car using the <guibutton>Save</guibutton>
					button.
				</para>
				
				<para>
					The <guibutton>Add an Owner</guibutton> button is generated by Metawidget based on the <function>addOwner</function> method
					in the <classname>Car</classname> class (which has been annotated <classname>@org.jdesktop.application.Action</classname>). The
					<guibutton>Save</guibutton> button is generated based on the <function>save</function> method in the <classname>CarApplication</classname>
					class (also annotated <classname>@Action</classname>). Two different Metawidgets are used in the example: one pointed
					at the <classname>Car</classname> class, the other at the <classname>CarApplication</classname> class.
				</para>
				
				<para>
					Metawidget supports pluggable 'action styles'. The use of Swing AppFramework is configured
					per <classname>Inspector</classname>, as in <filename>examples/src/java/org/metawidget/example/swing/appframework/metawidget.xml</filename>
					from the source distribution:
				</para>

				<programlisting language="xml">&lt;metawidgetAnnotationInspector
	config="org.metawidget.inspector.impl.BaseObjectInspectorConfig"&gt;
	&lt;actionStyle&gt;
		&lt;swingAppFrameworkActionStyle xmlns="java:org.metawidget.inspector.impl.actionstyle.swing"&gt;
	&lt;/actionStyle&gt;
&lt;/metawidgetAnnotationInspector&gt;</programlisting>

				<para>
					As a further feature, after the <guibutton>Add an Owner</guibutton> button is clicked it disappears. This is
					acheived by using <classname>JexlInspector</classname> to introduce an expression language for Swing similar to JSP's EL.
					The method is annotated...
				</para>
				
				<programlisting language="java">@Action( name = "add" )
@UiJexlAttribute( name = HIDDEN, value = "${this.owner != null}" )
public void addOwner() {
	mOwner = new Owner();
	fireActionEvent( "addOwner" );
}</programlisting>
				
				<para>
					...such that the button gets hidden when the car has an owner.
				</para>
				
			</section>

			<section id="section-introduction-part3-scala">
				<title>Scala Example</title>
	
				<para>
					The Scala Animal Races Example demonstrates using SwingMetawidget together with
					<ulink url="http://scala-lang.org">Scala</ulink> and
					<ulink url="http://miglayout.com">MigLayout</ulink>.
				</para>
	
				<para>
					The application is pre-built for you in <filename>examples\swing\animalraces-swing.jar</filename> or, if you've downloaded
					the source code distribution, you can build it yourself by changing to the <filename>examples</filename> folder of the source
					distribution and typing:
				</para>
				
				<programlisting language="shell">ant example-swing-animalraces</programlisting>
				
				<tip>
					<title>Note</title>
					This example uses annotations, so you'll need Java SE 5 or higher
				</tip>

				<para>
					This is a self-executing JAR. For convenience, it has <filename>MAINFEST.MF</filename> dependencies hard-wired into it to
					<filename>..\..\metawidget.jar</filename> and <filename>lib\scala-library.jar</filename> among others, so it's best not to move
					it to a different folder (if you do, you'll need to manually put those JARs on your classpath).
				</para>
				
				<para> 
					Run the code by navigating to the <filename>examples\swing</filename> folder and typing:
				</para>				
				
				<programlisting language="shell">java -jar animalraces-swing.jar</programlisting>
				
				<para>
					The screen displays fields to allow you to change the name, speed and type of each animal as well buttons
					to start and stop the race.
				</para>
				
				<figure id="section-introduction-part3-scala-screenshot">
					<title>Scala and MigLayout with Metawidget</title>
					<screenshot>
						<graphic fileref="images/screenshots/desktop-animalraces.jpg" width="100mm" />
					</screenshot>
				</figure>

				<para>
					Animal Races' whimsical User Interface demonstrates how Metawidget's goal of not 'owning' the UI allows multiple
					Metawidgets to be combined for unconventional UIs. There are three Metawidgets across the top (one for each animal in
					the race), and a fourth Metawidget for the buttons at the bottom.
				</para>
				
				<para>
					The top three Metawidgets all use MigLayout. Because Metawidget does not hide the underlying UI framework, using
					MigLayout allows the Animal Races code to easily pad the Metawidget: 
				</para>

				<programlisting language="java">metawidget.setMetawidgetLayout( new MigLayout() );
metawidget.setToInspect( animal );
<symbol>((MigLayout) metawidget.getLayout()).setLayoutConstraints( new LC().insets( "10" ));</symbol></programlisting>

				<para>
					The Animal Races code is written purely in Scala, located at
					<filename>examples/src/scala/org/metawidget/example/swing/animalraces/AnimalRaces.scala</filename>. It uses
					<classname>ScalaPropertyStyle</classname> to allow Metawidget to inspect Scala-based business objects: 
				</para>
				
				<programlisting language="xml">&lt;metawidgetAnnotationInspector xmlns="java:org.metawidget.inspector.annotation"
		config="org.metawidget.inspector.impl.BaseObjectInspectorConfig"&gt;
		&lt;propertyStyle&gt;
			<symbol>&lt;scalaPropertyStyle xmlns="java:org.metawidget.inspector.impl.propertystyle.scala"/&gt;</symbol>
		&lt;/propertyStyle&gt;			
	&lt;/metawidgetAnnotationInspector&gt;</programlisting>

				<para>
					In addition, it uses <classname>BeanUtilsBindingProcessorConfig.PROPERTYSTYLE_SCALA</classname> to bind <classname>JComponents</classname>
					to Scala-based business objects:
				</para>
					
				<programlisting language="scala">val metawidget = new SwingMetawidget()
<symbol>metawidget.addWidgetProcessor( new BeanUtilsBindingProcessor()
			.setPropertyStyle( BeanUtilsBindingProcessorConfig.PROPERTYSTYLE_SCALA ))</symbol>
metawidget.setToInspect( animal )</programlisting>

			</section>

			<section id="section-introduction-part3-gwt-clientside">
				<title>GWT Client Side Example</title>
	
				<para>
					By default, <classname>GwtMetawidget</classname> inspects business objects server-side using <classname>GwtRemoteInspector</classname>. This
					is because client-side JavaScript does not support reflections or annotations. However if you don't need reflections or annotations, and
					have your own way of retrieving inspection results, you can plug in your own inspector and keep everything client-side. This
					example implements a <classname>TextAreaInspector</classname> that retrieves inspection results from a textarea and generates the UI. 
				</para>

				<para>
					The example is pre-built for you in <filename>examples\gwt\clientside-gwt</filename>. Because everything is purely
					client side, there is no need for Tomcat or any other container: simply navigate to the example
					folder and open <filename>index.html</filename> in your Web browser:
				</para>
				
				<figure id="section-introduction-part3-gwt-clientside-screenshot">
					<title>Client-Side GwtMetawidget</title>
					<screenshot>
						<graphic fileref="images/screenshots/web-clientside.jpg" width="100mm" />
					</screenshot>
				</figure>

				<para>
					The example shows a textbox on the left containing inspection results in <filename>inspection-result-1.0.xsd</filename> format. The
					result of generating this XML is shown on the right. Click the <guibutton>Sample #2</guibutton> and <guibutton>Sample #3</guibutton>
					buttons to preload different XML samples, and the <guibutton>Generate</guibutton> button to generate their UI. Alternatively, you can edit
					the XML by hand to add new properties and actions and click <guibutton>Generate</guibutton>.
				</para>
				
				<para>
					Data binding and event binding are also implemented client side. Click the <guibutton>Save</guibutton> to save the data from the generated UI
					using a <classname>MapPropertyBinding</classname> (in a real application, this Map could be passed back to the server for
					persisting). Click the <guibutton>Add Tracks</guibutton> button to trigger an event binding.
				</para>
				
				<para>
					Finally, this example showcases using third-party GWT component libraries. <classname>ExtGwtWidgetBuilder</classname> is used
					to render a date picker widget. For more details on
					<ulink url="http://extjs.com/products/gxt">ExtGWT</ulink>
					support, see <xref linkend="section-widgetbuilders-gwt-extgwt"/>. 
				</para>
								
			</section>

			<section id="section-introduction-part3-gwt-hosted">
				<title>GWT Hosted Mode Examples</title>
	
				<para>
					The <filename>examples\gwt\addressbook-gwt.war</filename> (discussed in Part 2 of this tutorial)
					and the <filename>examples\gwt\clientside</filename> (discussed in Part 3 of this tutorial) demonstrates GWT
					running in <emphasis>GWT Web mode</emphasis>. Developers may prefer instead to run the examples in <emphasis>GWT hosted mode</emphasis>
					as in <xref linkend="section-introduction-part3-gwt-hosted-screenshot"/>.
				</para>

				<figure id="section-introduction-part3-gwt-hosted-screenshot">
					<title>Address Book Example running in GWT Hosted Mode</title>
					<screenshot>
						<graphic fileref="images/screenshots/web-gwt-hosted.jpg" width="100mm" />
					</screenshot>
				</figure>

				<para>
					There are two ways to set up the hosted mode projects. For Windows developers, there is an automated Ant build
					included in the source distribution (not the binary distribution). To run it, type: 
				</para>
				
				<programlisting language="shell">cd examples\src\web\gwt
ant</programlisting>
								
				<tip>
					<title>Note</title>
					You will need to either configure <parameter>GWT_HOME</parameter>, <parameter>METAWIDGET_HOME</parameter>
					and <parameter>METAWIDGET_SRC_HOME</parameter> environment variables or pass <parameter>-Dgwt.home</parameter>,
					<parameter>-Dmetawidget.home</parameter> and <parameter>-Dmetawidget.src.home</parameter>
					arguments to Ant. GWT_HOME should point to a GWT 1.7 installation. METAWIDGET_HOME should point to the binary
					Metawidget distribution. METAWIDGET_SRC_HOME should point to the source Metawidget distribution.
				</tip>
				
				<para>
					The build will create Eclipse projects which can be imported by using Eclipse's
					<parameter>File->Import</parameter> menu and choosing
					<parameter>Existing Projects into Workspace</parameter>
					(as described in the <ulink url="http://code.google.com/webtoolkit/gettingstarted.html">GWT Getting Started Guide</ulink>).
					You should now be able to run the sample applications in hosted mode, including running their unit tests.
				</para>
				
				<para>
					Alternatively, you can set up the hosted mode projects manually. Here are the steps for the Address Book example
					(for other examples, replace the phrase <classname>AddressBook</classname> as appropriate): 
				</para>

				<itemizedlist>
					<listitem>
						<para>
							Run the GWT <filename>webAppCreator</filename> (as described in the
							<ulink url="http://code.google.com/webtoolkit/gettingstarted.html">GWT Getting Started Guide</ulink>). Here
							we assume GWT is installed at <filename>\gwt-windows-1.7.0</filename> and you want to create a hosted
							mode project at <filename>\gwt-addressbook</filename>:
						</para>
						
						<programlisting language="shell">\gwt-windows-1.7.0\webAppCreator -out
						\gwt-addressbook org.metawidget.example.gwt.addressbook.client.AddressBook</programlisting>
					</listitem>
					<listitem>
						<para>
							Delete the default generated Java source files:
						</para>
						
						<programlisting language="shell">del \gwt-addressbook\src\org\metawidget\example</programlisting>
					</listitem>
					<listitem>
						<para>
							Copy over the Address Book example's Java source files. Here we assume the Metawidget source distribution is installed
							at <filename>\metawidget-src</filename> and you are using the Windows <filename>xcopy</filename> command:
						</para>
						
						<programlisting language="shell">xcopy /s /i \metawidget-src\examples\src\java\org\metawidget\example\gwt\addressbook
						\gwt-addressbook\src\org\metawidget\example\gwt\addressbook
xcopy /s /i \metawidget-src\examples\src\java\org\metawidget\example\shared\addressbook
						\gwt-addressbook\src\org\metawidget\example\shared\addressbook
copy \metawidget-src\examples\src\java\org\metawidget\example\GwtAddressBook.gwt.xml
						\gwt-addressbook\src\org\metawidget\example</programlisting>
					</listitem>
					<listitem>
						<para>
							Delete the default generated Web source files:
						</para>
						
						<programlisting language="shell">del \gwt-addressbook\war</programlisting>
					</listitem>
					<listitem>
						<para>
							Copy over the Address Book example's Web source files:
						</para>
						
						<programlisting language="shell">xcopy /s /i \metawidget-src\examples\src\web\gwt\addressbook \gwt-addressbook\war
xcopy /s /i \metawidget-src\examples\src\web\shared\addressbook \gwt-addressbook\war
copy \metawidget-src\examples\src\java\org\metawidget\example\GwtAddressBook.gwt.xml
						\gwt-addressbook\src\org\metawidget\example</programlisting>
					</listitem>
					<listitem>
						<para>
							Copy over Metawidget itself. Here we assume the Metawidget binary distribution is installed
							at <filename>\metawidget-bin</filename>:
						</para>
						
						<programlisting language="shell">copy \metawidget-bin\metawidget.jar \gwt-addressbook\war\WEB-INF\lib
mkdir \gwt-addressbook\lib
copy \metawidget-bin\examples\gwt\metawidget-gwt.jar
			\gwt-addressbook\lib\metawidget-gwt.jar</programlisting>
					</listitem>
					<listitem>
						<para>
							Import <filename>\gwt-addressbook</filename> into Eclipse by using <parameter>File->Import</parameter> and choosing
							<parameter>Existing Projects into Workspace</parameter>
							(as described in the <ulink url="http://code.google.com/webtoolkit/gettingstarted.html">GWT Getting Started Guide</ulink>).
						</para>
					</listitem>
					<listitem>
						<para>
							Use Eclipse's <parameter>Project->Properties->Java Build Path</parameter> dialog and its
							<parameter>Libraries</parameter> tab to add the JARs <filename>lib/metawidget-gwt.jar</filename> and
							<filename>WEB-INF/lib/metawidget.jar</filename> into the project.
						</para>
					</listitem>
					<listitem>
						<para>
							Finally, edit the <filename>AddressBook.launch</filename> file to replace...
						</para>
						<programlisting language="xml">-startupUrl AddressBook.html org.metawidget.example.gwt.addressbook.client.AddressBook</programlisting>
						<para>
							...with...
						</para>
						<programlisting language="xml">-startupUrl index-hosted.jsp org.metawidget.example.GwtAddressBook</programlisting>
						You should now be able to run the sample applications in hosted mode.
					</listitem>
				</itemizedlist>					
				
				<para>
					Once you have the samples running, you can quickly make changes and play around. For example,
					find the line in <classname>ContactDialog</classname> that configures a <classname>LabelLayoutDecorator</classname>
					(which decorates sections using <classname>Label</classname>s) and change it to a
					<classname>TabPanelLayoutDecorator</classname>. This will decorate sections using a GWT <classname>TabPanel</classname>,
					as shown in <xref linkend="section-introduction-part3-gwt-hosted-screenshot-tabpanel"/>.					
				</para>
				
				<figure id="section-introduction-part3-gwt-hosted-screenshot-tabpanel">
					<title>Address Book Example using GWT TabPanel</title>
					<screenshot>
						<graphic fileref="images/screenshots/web-gwt-hosted-tabpanel.jpg" width="100mm" />
					</screenshot>
				</figure>
				
			</section>
			
		</section>

	</chapter>

	<chapter id="chapter-architecture">
		<title>Architecture</title>
		
		<para>
			There are a large variety of system architectures, and many different types of UI. Metawidget's approach
			to managing this diversity is not to define lots of 'flags' to tweak lots of little variables, but to
			establish a pipeline with plug-in points along the way for your own custom classes.
			This five-stage pipeline is shown on the right of <xref linkend="chapter-architecture-overall"/>. It
			is co-ordinated by a platform-specific Metawidget class
			(eg. <classname>SwingMetawidget</classname>, <classname>StrutsMetawidgetTag</classname> etc) as shown on the left. 
		</para>
		
		<!--
			http://www.websequencediagrams.com
			
			Metawidget->Inspector: asks for inspection
			Inspector->Inspector: inspects\nbusiness object
			Inspector->Metawidget: returns inspection result
			Metawidget->InspectionResultProcessor: asks to process
			InspectionResultProcessor->InspectionResultProcessor: sorts result
			InspectionResultProcessor->Metawidget: returns sorted result
			loop for each widget
			   Metawidget->WidgetBuilder: asks for widget
			   WidgetBuilder->WidgetBuilder: chooses\nbest widget
			   WidgetBuilder->Metawidget: returns chosen widget
			   Metawidget->WidgetProcessors: asks to process
			   WidgetProcessors->WidgetProcessors: attach binding
			   WidgetProcessors->WidgetProcessors: attach validation
			   WidgetProcessors->WidgetProcessors: ...etc
			   WidgetProcessors->Metawidget: returns final widget
			   Metawidget->Layout: asks to layout
			   Layout->Layout: lays out widget
			end
		-->
		
		<figure id="chapter-architecture-overall">
			<title>Metawidget uses a five-stage pipeline</title>
			<screenshot>
				<graphic fileref="images/activitydiagrams/architecture.png" width="140mm"/>
			</screenshot>			
		</figure>
		
		<para>
			The five stages of the pipeline are:
		</para>
		
		<orderedlist>
			<listitem>
				<para>
					an <classname>Inspector</classname> that inspects specific back-end architectures. This can be a single <classname>Inspector</classname> or
					a list of multiple <classname>Inspector</classname>s (eg. <classname>PropertyTypeInspector</classname>, <classname>JpaInspector</classname> etc)
					by using <classname>CompositeInspector</classname> (see <xref linkend="section-introduction-part1-compositeinspector"/>). In the latter case,
					the multiple inspection results are all combined into a single result. 
				</para>
			</listitem>
			<listitem>
				<para>
					a list of <classname>InspectionResultProcessor</classname>s that can modify the inspection result. These can be used to
					sort the result, exclude certain fields, and so on.
				</para>
			</listitem>
			<listitem>
				<para>
					a <classname>WidgetBuilder</classname> that creates widgets for specific front-end frameworks. This can be a
					single <classname>WidgetBuilder</classname> or a list of multiple <classname>WidgetBuilder</classname>s
					(eg. <classname>HtmlWidgetBuilder</classname>, <classname>RichFacesWidgetBuilder</classname> etc) by using
					<classname>CompositeWidgetBuilder</classname>.
				</para>
				<para>
					In the latter case, the first <classname>WidgetBuilder</classname>
					to return a match is used. In this way <classname>WidgetBuilder</classname>s for third party UI component libraries
					(that provide specialized components) can be listed first, and <classname>WidgetBuilder</classname>s for the
					platform's standard components can be listed last (as a 'fallback' choice).
				</para>
			</listitem>
			<listitem>
				<para>
					a list of <classname>WidgetProcessor</classname>s that can modify each widget. These can be used to add
					data binding, event handlers, validation, tooltips and so on.
				</para>
			</listitem>
			<listitem>
				<para>
					a <classname>Layout</classname> that arranges each widget on the screen, possibly organising them into columns and
					decorating them with labels (eg. <classname>HtmlTableLayout</classname>).
				</para>
			</listitem>
		</orderedlist>

		<tip>
			<title>Immutable</title>
			All <classname>Inspector</classname>s, <classname>WidgetBuilder</classname>s, <classname>WidgetProcessor</classname>s
			and <classname>Layout</classname>s are required to be immutable. This means you only
			need a single instance of them for your entire application. If you are using
			<filename>metawidget.xml</filename> (see later) then <classname>ConfigReader</classname> takes care
			of this for you, but if you are instantiating them in Java code you should
			reuse instances. Keeping everything immutable allows Metawidget to be very performant at the
			same time as being very pluggable.
		</tip>

		<para>
			The following sections discuss each of the five stages of the pipeline in detail.
		</para>
		
		<section id="section-architecture-metawidgets">
			<title>Metawidgets</title>

			<para>
				Metawidget comes with a native component for each popular UI framework. This section
				discusses characteristics common to all Metawidgets. For in-depth documentation of
				a Metawidget for a specific UI framework, see <xref linkend="chapter-metawidgets"/>.				
			</para>
			
			<section id="section-architecture-metawidgets-interface">
				<title>Interface</title>
				
				<para>
					Metawidgets are not required to extend any Java base class or implement any Java interface.	This is
					because most UI frameworks require widgets inherit one of <emphasis>their</emphasis> base classes,
					such as <classname>javax.swing.JComponent</classname> or <classname>javax.faces.UIComponent</classname>, and
					Java does not support multiple inheritance.
				</para>
				
				<para>
					In addition, while all Metawidgets support roughly the same functionality, different UI frameworks have different in-built capabilities.
					For example, JSF has <function>UIComponent.setRenderer</function> for choosing different layouts
					for the same widget, whereas <classname>SwingMetawidget</classname> has to roll its own <function>setMetawidgetLayout</function> method.
					This diversity of capabilities means there cannot be a common 'Metawidget Java interface' either.
				</para>
				
				<para>
					However, despite not extending any common base class or interface, all Metawidgets follow roughly the
					same design, with roughly the same method names:
				</para>
				
				<orderedlist>
					<listitem>
						<para>
							<function>setToInspect</function> is called to set the Object for inspection. The user typically calls
							this method, either directly or through some intermediate language (eg. using a JSP attribute).
						</para>
					</listitem>
					<listitem>
						<para>
							Internally, <function>buildWidgets</function> is called to begin the process.
							It first calls <function>Inspector.inspect</function> to return
							an XML string of inspection results, then <function>InspectionResultProcessor.processInspectionResult</function>
							to sort them.
						</para>
					</listitem>
					<listitem>
						<para>							
							<function>buildWidgets</function> calls <function>WidgetBuilder.buildWidget</function> to choose a suitable widget for the
							top-level element of the XML (based on its <parameter>@type</parameter> attribute). If <function>WidgetBuilder.buildWidget</function>
							returns such a widget, skip to 6.
						</para>
					</listitem>
					<listitem>
						<para>							
							if <function>WidgetBuilder.buildWidget</function> returns null for the top-level element, call <function>buildCompoundWidget</function> to
							iterate over each child of the top-level element.
						</para>
					</listitem>
					<listitem>
						<para>
							for each child, call <function>WidgetBuilder.buildWidget</function> and add the returned widget to the Metawidget. If
							<function>WidgetBuilder.buildWidget</function> returns null for a child, create a nested Metawidget.
						</para>
					</listitem>
					<listitem>
						<para>
							the created widgets are passed through a series of <classname>WidgetProcessor</classname>s. These can apply binding mechanisms,
							validators and so on.
						</para>
					</listitem>
					<listitem>
						<para>
							as a final step, the created widgets are passed to a <classname>Layout</classname>. They can further be adorned with facet widgets.
						</para>
					</listitem>
				</orderedlist>
				
				<para>
					For those looking to write their own Metawidget (say, for a currently unsupported platform) there is a
					<classname>BasePipeline</classname> class that implements the above steps 2-7 for you, see
					<xref linkend="section-architecture-metawidgets-implementing-your-own-pipeline"/>.
					All of the supplied Metawidgets are implemented using this class.
				</para>
				
			</section>
			
			<section id="section-architecture-metawidgets-look">
				<title>Customizing Look and Feel</title>

				<para>
					As much as possible, Metawidgets defer to the existing Look and Feel technology of their native UI framework. For example,
					<classname>HtmlMetawidget</classname> uses HTML/CSS, <classname>SwingMetawidget</classname> uses Swing Look-and-Feels,
					and <classname>AndroidMetawidget</classname> uses Android styles and themes.
				</para>
				
				<para>
					The one visual area Metawidget <emphasis>does</emphasis> control is how the widgets it creates are laid out. Typically this is in
					a tabular 'one column for the label, one column for the widget' format, but this is pluggable.
				</para>
				
				<para>
					Metawidgets come with different <classname>Layout</classname> classes that can arrange the widgets in different ways, and
					these are set on the Metawidget in a framework-specific
					way. For example, JSF uses <parameter>&lt;m:metawidget rendererType=""&gt;</parameter> whereas <classname>SwingMetawidget</classname>
					uses <function>setMetawidgetLayout</function>. Where possible, the layout classes defer back to the capabilities
					of the native framework. For example, Swing's <classname>GridBagLayout</classname> or Android's <classname>TableLayout</classname>.
				</para>
				
				<para>
					Some layouts will add localized labels and section headings to the widgets, whereas other layouts may leave them unadorned. Different
					Layouts may support different parameters (for example, a <classname>TableLayout</classname> may support <parameter>numberOfColumns</parameter>).
					These are initialized on the Layout at construction time using a <classname>xxxLayoutConfig</classname>.
				</para>
				
			</section>
			
			<section id="section-architecture-metawidgets-override">
				<title>Overriding Widget Creation</title>

				<para>
					Metawidget tries to automate much of the widget creation, but provides many hooks to customize the process:
				</para>
				
				<itemizedlist>
					<listitem>
						<para>
							<emphasis role="bold">stub</emphasis> child widgets can be used to suppress widget creation entirely or to
							replace automatic widget creation with one or more other widgets with different bindings.
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis role="bold">facet</emphasis> child widgets pass through to the chosen layout
							as decorations (such as button bars).
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis role="bold">WidgetBuilders</emphasis> can be plugged in to the pipeline to control widget creation.
							They can be configured through <classname>xxxWidgetBuilderConfig</classname> classes.
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis role="bold">WidgetProcessors</emphasis> can be plugged in to the pipeline to fine-tune widget properties.
							They can be configured through <classname>xxxWidgetProcessorConfig</classname> classes.
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis role="bold">Layouts</emphasis> can be plugged in to the pipeline to control layout.
							They can be configured through <classname>xxxLayoutConfig</classname> classes.
						</para>
					</listitem>
				</itemizedlist>
				
			</section>

			<section id="section-architecture-metawidgets-implementing-your-own">
				<title>Implementing Your Own Metawidget</title>
	
				<para>
					Metawidget creates widgets native to a particular UI framework. Having to implement your own
					Metawidget should be far less common than having to implement your own <classname>Inspector</classname>, 
					<classname>WidgetBuilder</classname> or <classname>WidgetProcessor</classname>, but if your chosen UI
					framework is not supported 'out of the box' you may	need to implement your own. 
				</para>
				
				<para>
					Metawidgets are not required to extend any base class or implement any interface. However,
					it is recommended developers familiarize themselves with existing
					Metawidgets (such as <classname>UIMetawidget</classname>) to make their API similar.
					Whilst there is no one Metawidget base class, a number of convenience classes are provided:
				</para>
					
				<section id="section-architecture-metawidgets-implementing-your-own-pipeline">
					<title>BasePipeline</title>
					
					<para>
						All the built-in Metawidgets use <classname>BasePipeline</classname> to ease their implementation. It
						provides pre-built functionality such as co-ordinating the 5 stages of the pipeline,
						deciding when to use single versus compound widgets, support
						for overriding widgets, incorporating stubs, and changing between read-only and active modes.
					</para>
					
				</section>
	
				<section id="section-architecture-metawidgets-implementing-your-own-android">
					<title>Android</title>
					
					<para>
						Android already defines a separation between <classname>Views</classname> and <classname>ViewGroups</classname>.
						<classname>org.metawidget.android.widget.layout.Layout</classname> and its subclasses automate the use
						of existing Android <classname>ViewGroups</classname>.					
					</para>
					
				</section>
	
				<section id="section-architecture-metawidgets-implementing-your-own-faces">
					<title>Java Server Faces</title>
					
					<para>
						For frameworks based on JSF, <classname>org.metawidget.faces.component.UIMetawidget</classname>
						provides base widget functionality. See <classname>org.metawidget.faces.component.html.HtmlMetawidget</classname> for example usage.
					</para>
					
					<para>
						JSF already defines a clean separation between widgets and their renderers.
						<classname>org.metawidget.faces.renderkit.LayoutRenderer</classname> and its subclasses leverage this to
						support different layouts.
					</para>
				</section>
				
				<section id="section-architecture-metawidgets-implementing-your-own-jsp">
					<title>Java Server Pages</title>
					
					<para>
						For frameworks based on JSP, <classname>org.metawidget.jsp.tagext.MetawidgetTag</classname> and the more
						commonly used <classname>org.metawidget.jsp.tagext.html.BaseHtmlMetawidgetTag</classname> provide base
						taglib functionality. See <classname>StrutsMetawidgetTag</classname> for example usage.
					</para>
					
					<para>
						<classname>MetawidgetTag</classname> also defines a clean separation between choosing widgets and laying them out.
						<classname>org.metawidget.jsp.tagext.Layout</classname> and its subclasses can perform the layout for
						<emphasis>all</emphasis> JSP-based frameworks.
					</para>
				</section>
	
				<section id="section-architecture-metawidgets-implementing-your-own-swing">
					<title>Swing</title>
					
					<para>
						Swing already defines a clean separation between widgets and layout managers.
						<classname>org.metawidget.swing.layout.Layout</classname> and its subclasses automate the use
						of existing Swing <classname>LayoutManagers</classname>.
					</para>
				</section>
	
			</section>

		</section>
		
		<section id="section-architecture-inspectors">
			<title>Inspectors</title>

			<para>
				Inspectors decouple the process of examining back-end metadata and generating inspection results. This section
				covers inspectors in general. For in-depth documentation of individual inspectors
				see <xref linkend="chapter-inspectors"/>.
			</para>

			<section id="section-architecture-inspectors-interface">
				<title>Interface</title>

				<para>
					All inspectors must implement the <classname>Inspector</classname> interface. This is a simple
					interface that defines only one method:
				</para>
				
				<programlisting language="java">String inspect( Object toInspect, String type, String... names );</programlisting>
				
				<para>
					Each inspector must look to the <parameter>type</parameter> parameter and the <parameter>names</parameter> array. These
					form a path into the business object domain model. For example the <parameter>type</parameter> may be <parameter>com.myapp.Person</parameter>
					and the <parameter>names</parameter> may be <parameter>address</parameter> and <parameter>street</parameter>.
					This would form a path into the domain model of	<parameter>com.myapp.Person/address/street</parameter> (ie. return information
					on the <parameter>street</parameter> property within the <parameter>address</parameter> property of the <parameter>Person</parameter> type).
				</para>
				
				<para>
					Depending on the type of inspector, it may use the given <classname>toInspect</classname> to access the runtime
					object for the given <classname>type</classname>. Or it may ignore the <classname>toInspect</classname> and look up
					information for the given <classname>type</classname> from an XML file or a database schema. This allows Metawidget
					to inspect types that have no corresponding Java object. For example: 
				</para>

				<programlisting language="java">metawidget.setToInspect( null );	// No setToInspect
metawidget.setPath( "Login Form" );</programlisting>

				<para>
					This could be combined with, say, an <classname>XmlInspector</classname> and a <filename>metawidget-metadata.xml</filename>:
				</para>
				
				<programlisting language="xml">&lt;entity type="Login Form"&gt;
	&lt;property name="username"/&gt;
	&lt;property name="password"/&gt;
&lt;/entity&gt;</programlisting>

				<para>
					This approach also allows Metawidget to inspect abstract classes:
				</para>

				<programlisting language="java">metawidget.setToInspect( null );	// No setToInspect
metawidget.setPath( MyAbstractClass.class.getName() );</programlisting>

				<tip>
					<title>Note</title>							
					In general, a non-null <function>setToInspect</function> is a preferrable, as
					many binding and validation technologies (see later) will be expecting a concrete object.
				</tip>
				
			</section>
			
			<section id="section-architecture-inspectors-usage">
				<title>Usage</title>
				
				<para>
					Unless explicitly specified, each Metawidget will instantiate a default inspector. Typically this
					will be a <classname>CompositeInspector</classname> composed of a <classname>PropertyTypeInspector</classname>
					and a <classname>MetawidgetAnnotationInspector</classname>.
				</para>
				
				<para>
					This default behaviour can be overridden either in code:
				</para>
				
				<programlisting language="java">metawidget.setInspector( new MyInspector() );</programlisting>
				
				<para>
					Or via <filename>metawidget.xml</filename>:
				</para>
				
				<programlisting language="xml">&lt;swingMetawidget xmlns="java:org.metawidget.swing"&gt;
	&lt;inspector&gt;
		&lt;myInspector xmlns="java:com.myapp"/&gt;
	&lt;/inspector&gt;
&lt;/swingMetawidget&gt;</programlisting>
	
				<para>
					This allows easy plugging in of alternate inspectors. Note that overriding the default
					means the default is no longer instantiated. In the example above, this would mean <classname>MyInspector</classname>
					is used but the default inspectors are not. This is usually not what you want,
					because <classname>MyInspector</classname> will be focussed on a particular type of back-end metadata and
					will want to leave other metadata to other inspectors.
				</para>
				
				<para>
					To achieve this, use <classname>CompositeInspector</classname>.
				</para>
				
			</section>
			
			<section id="section-architecture-inspectors-compositeinspector">
				<title>CompositeInspector</title>
				
				<para>
					<classname>CompositeInspector</classname> composes the results of several inspectors into one and
					returns a single, combined inspection result. As shown in <xref linkend="section-architecture-compositeinspector-chain"/>
					<classname>CompositeInspector</classname> works by calling each inspector in turn, combining the
					inspection result as it goes. 
				</para>
				
				<!--
					http://www.websequencediagrams.com:
					
					Metawidget->CompositeInspector: asks for inspection
					CompositeInspector->Inspector #1: asks for inspection
					Inspector #1->CompositeInspector: returns inspection result
					CompositeInspector->CompositeInspector: stores as\nfirst result
					CompositeInspector->Inspector #2: asks for inspection
					Inspector #2->CompositeInspector: returns inspection result
					CompositeInspector->CompositeInspector: combines with\nfirst result
					CompositeInspector->Inspector #3: asks for inspection
					Inspector #3->CompositeInspector: returns inspection result
					CompositeInspector->CompositeInspector: combines with\nfirst two results
					CompositeInspector->Metawidget: returns combined inspection result
				-->
				
				<figure id="section-architecture-compositeinspector-chain">
					<title>CompositeInspector composes multiple inspectors into one</title>
					<screenshot>
						<graphic fileref="images/activitydiagrams/architecture-compositeinspector.png" width="140mm"/>
					</screenshot>			
				</figure>				
				
				<para>
					All inspectors are required to be immutable (see later). Therefore, although <classname>CompositeInspector</classname>
					maintains a list of inspectors this must not be changeable. To enforce this, the list is set at instantation
					time using <classname>CompositeInspectorConfig</classname>. This can either be set in code:
				</para>
				
				<programlisting language="java">metawidget.setInspector( new CompositeInspector( new CompositeInspectorConfig()
	.setInspectors(
		new PropertyTypeInspector(),
		new MetawidgetAnnotationInspector(),
		new MyInspector()
	)));</programlisting>
				
				<para>
					Or via <filename>metawidget.xml</filename>
				</para>
				
				<programlisting language="xml">&lt;swingMetawidget xmlns="java:org.metawidget.swing"&gt;
&lt;inspector&gt;
	&lt;compositeInspector
		xmlns="java:org.metawidget.inspector.composite"
		config="CompositeInspectorConfig"&gt;
		&lt;inspectors&gt;
			&lt;array&gt;
				&lt;propertyTypeInspector xmlns="java:org.metawidget.inspector.propertytype"/&gt;
				&lt;metawidgetAnnotationInspector xmlns="java:org.metawidget.inspector.annotation" /&gt;
				&lt;myInspector xmlns="java:com.myapp"/&gt;
			&lt;/array&gt;
		&lt;/inspectors&gt;
	&lt;/compositeInspector&gt;
&lt;/inspector&gt;
&lt;/swingMetawidget&gt;</programlisting>

			</section>

			<section id="section-architecture-inspectors-defaults">
				<title>Defaults</title>
				
				<para>
					All Metawidgets have default <classname>Inspector</classname>s. Overriding the default means the default is no
					longer instantiated. Usually this is not what you want, so you should consider instantiating
					the default along with your new <classname>Inspector</classname> (ie. use <classname>CompositeInspector</classname>).
					You can see the default by looking in the
					Metawidget JAR for the file <filename>metawidget-xxx-default.xml</filename> (where <filename>xxx</filename>
					is your target platform, such as <filename>swing</filename> or <filename>struts</filename>). 
				</para>
				
				<para>
					For reference, the defaults are:
				</para>

				<informaltable>
					<colgroup>
						<col width="30%"/>
						<col width="70%"/>
					</colgroup>
					<thead>
						<tr>
							<th align="left">Platform</th>
							<th align="left">Default</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>Android</td>
							<td><programlisting language="xml">&lt;compositeInspector xmlns="java:org.metawidget.inspector.composite"
		config="CompositeInspectorConfig"&gt;
		&lt;inspectors&gt;
			&lt;array&gt;
				&lt;propertyTypeInspector /&gt;
				&lt;metawidgetAnnotationInspector /&gt;
			&lt;/array&gt;
		&lt;/inspectors&gt;
	&lt;/compositeInspector&gt;</programlisting></td>
						</tr>
						<tr>
							<td>GWT</td>
							<td><programlisting language="xml">&lt;compositeInspector xmlns="java:org.metawidget.inspector.composite"
		config="CompositeInspectorConfig"&gt;
		&lt;inspectors&gt;
			&lt;array&gt;
				&lt;propertyTypeInspector /&gt;
				&lt;metawidgetAnnotationInspector /&gt;
			&lt;/array&gt;
		&lt;/inspectors&gt;
	&lt;/compositeInspector&gt;</programlisting></td>
						</tr>
						<tr>
							<td>JSF</td>
							<td><programlisting language="xml">&lt;compositeInspector xmlns="java:org.metawidget.inspector.composite"
		config="CompositeInspectorConfig"&gt;
		&lt;inspectors&gt;
			&lt;array&gt;
				&lt;propertyTypeInspector /&gt;
				&lt;metawidgetAnnotationInspector /&gt;
				&lt;facesInspector /&gt;
			&lt;/array&gt;
		&lt;/inspectors&gt;
	&lt;/compositeInspector&gt;</programlisting></td>
						</tr>
						<tr>
							<td>JSP</td>
							<td><programlisting language="xml">&lt;compositeInspector xmlns="java:org.metawidget.inspector.composite"
		config="CompositeInspectorConfig"&gt;
		&lt;inspectors&gt;
			&lt;array&gt;
				&lt;propertyTypeInspector /&gt;
				&lt;metawidgetAnnotationInspector /&gt;
				&lt;jspAnnotationInspector /&gt;				
			&lt;/array&gt;
		&lt;/inspectors&gt;
	&lt;/compositeInspector&gt;</programlisting></td>
						</tr>
						<tr>
							<td>Spring</td>
							<td><programlisting language="xml">&lt;compositeInspector xmlns="java:org.metawidget.inspector.composite"
		config="CompositeInspectorConfig"&gt;
		&lt;inspectors&gt;
			&lt;array&gt;
				&lt;propertyTypeInspector /&gt;
				&lt;metawidgetAnnotationInspector /&gt;
				&lt;springAnnotationInspector /&gt;
			&lt;/array&gt;
		&lt;/inspectors&gt;
	&lt;/compositeInspector&gt;</programlisting></td>
						</tr>
						<tr>
							<td>Struts</td>
							<td><programlisting language="xml">&lt;compositeInspector xmlns="java:org.metawidget.inspector.composite"
		config="CompositeInspectorConfig"&gt;
		&lt;inspectors&gt;
			&lt;array&gt;
				&lt;propertyTypeInspector /&gt;
				&lt;metawidgetAnnotationInspector /&gt;
				&lt;strutsAnnotationInspector /&gt;
				&lt;commonsValidatorInspector
					config="CommonsValidatorInspectorConfig"/&gt;
			&lt;/array&gt;
		&lt;/inspectors&gt;
	&lt;/compositeInspector&gt;</programlisting></td>
						</tr>
						<tr>
							<td>Swing</td>
							<td><programlisting language="xml">&lt;compositeInspector xmlns="java:org.metawidget.inspector.composite"
		config="CompositeInspectorConfig"&gt;
		&lt;inspectors&gt;
			&lt;array&gt;
				&lt;propertyTypeInspector /&gt;
				&lt;metawidgetAnnotationInspector /&gt;
			&lt;/array&gt;
		&lt;/inspectors&gt;
	&lt;/compositeInspector&gt;</programlisting></td>
						</tr>
					</tbody>
				</informaltable>				
				
			</section>

			<section id="section-architecture-inspectors-immutability">
				<title>Immutability</title>
				
				<para>
					All inspectors are required to be immutable. This means you only
					need a single instance of an <classname>Inspector</classname> for your entire application. If you are using
					<filename>metawidget.xml</filename> (see later) then <classname>ConfigReader</classname> takes care
					of this for you, but if you are instantiating <classname>Inspector</classname>s in Java code you should
					reuse instances.
				</para>
				
				<para>
					Note that immutable only means <classname>Inspector</classname>s cannot be changed once instantiated - it does not
					mean they cannot be configured. Many <classname>Inspector</classname>s have corresponding <classname>xxxConfig</classname>
					classes that allow them to be configured prior to instantation in a type-safe way. For example, a
					<classname>JpaInspector</classname> can be configured in code:
				</para>

				<programlisting language="java">metawidget.setInspector( new JpaInspector( new JpaInspectorConfig().setHideIds( false )));</programlisting>
				
				<para>
					Or in <filename>metawidget.xml</filename>:
				</para>
				
				<programlisting language="xml">&lt;jpaInspector xmlns="java:org.metawidget.inspector.jpa" config="JpaInspectorConfig"&gt;
	&lt;hideIds&gt;
		&lt;boolean&gt;true&lt;/boolean&gt;
	&lt;/hideIds&gt;
&lt;/jpaInspector&gt;</programlisting>
				
			</section>

			<section id="section-architecture-inspectors-inspectionresult">
				<title>inspection-result</title>
	
				<para>
					The <parameter>inspection-result</parameter> XML format is the 'glue' that holds everything together: the
					<classname>Metawidget</classname>s request it, the <classname>Inspector</classname>s provide it, and
					the <classname>WidgetBuilder</classname>s base their choice of widgets on it.
				</para>
				
				<para>
					It is a very simple format. As an example:
				</para>
				
				<programlisting language="xml">&lt;inspection-result version="1.0"&gt;
	&lt;entity type="com.myapp.Person"&gt;
		&lt;property name="name" required="true"/&gt;
		&lt;property name="age" minimum-value="0"/&gt;
	&lt;/entity&gt;
&lt;/inspection-result&gt;</programlisting>
	
				<para>
					Only a handful of XML attributes are mandatory (see <filename>inspection-result-1.0.xsd</filename>). Most, such as <parameter>retired</parameter>
					and <parameter>minimum-value</parameter>, are provided at the discretion of the <classname>Inspector</classname>
					and recognised at the discretion of the <classname>WidgetBuilder</classname>s, <classname>WidgetProcessor</classname>s
					and <classname>Layout</classname>s. This loose coupling
					allows <classname>Inspector</classname>s to evolve independently for new types of metadata, <classname>WidgetBuilder</classname>s
					to evolve independently with new types of widgets, and so on.
				</para>
				
			</section>
		
			<section id="section-architecture-inspectors-implementing-your-own">
				<title>Implementing Your Own Inspector</title>
	
				<para>
					Metawidget inspects a wide variety of back-end architectures. If your chosen back-end
					architecture is not supported 'out of the box', you may need to implement your own <classname>Inspector</classname>. 
				</para>
				
				<para>
					All <classname>Inspector</classname>s must implement the <classname>org.metawidget.inspector.Inspector</classname> interface:
				</para>
				
				<programlisting language="java">public interface Inspector {
	String inspect( Object toInspect, String type, String... names );
}</programlisting>
				
				<para>
					The interface has only one method: <function>inspect</function>. Its parameters are:
				</para>
				
				<itemizedlist>
					<listitem>
						<para>
							an <classname>Object</classname> to inspect. This may be <parameter>null</parameter>, or can be ignored for inspectors inspecting static metadata (such as XML files)
						</para>
					</listitem>
					<listitem>
						<para>
							a <parameter>type</parameter>. This must match the given <classname>Object</classname>, or some attribute in the inspected config file
						</para>
					</listitem>
					<listitem>
						<para>
							a list of <parameter>names</parameter> to be traversed beneath the type
						</para>
					</listitem>
				</itemizedlist>				
	
				<para>
					The returned String must be an XML document conforming to <filename>inspection-result-1.0.xsd</filename>. To assist
					development, deploy your inspector within <classname>ValidatingCompositeInspector</classname> to
					automatically validate the returned DOM during testing.
				</para>
				
				<para>
					A number of convenience base classes are provided for different inspectors: 
				</para>
				
				<itemizedlist>
					<listitem>
						<para>
							<classname>BaseObjectInspector</classname> assists in inspecting annotations and properties (including
							support for different property styles, such as JavaBean properties or Groovy properties). Here
							is an example of a custom <classname>Inspector</classname> to inspect tooltip metadata from
							a custom annotation. It extends the code from the tutorial (see <xref linkend="section-introduction-part1"/>).
						</para>
				
						<programlisting language="java">package com.myapp;
			
<symbol>import java.lang.annotation.*;
import java.util.*;</symbol>
import javax.swing.JFrame;
<symbol>import org.metawidget.inspector.composite.*;
import org.metawidget.inspector.impl.*;
import org.metawidget.inspector.impl.propertystyle.*;
import org.metawidget.inspector.propertytype.*;</symbol>
import org.metawidget.swing.*;
<symbol>import org.metawidget.util.*;</symbol>

public class Main {

	public static void main( String[] args ) {
		Person person = new Person();

		SwingMetawidget metawidget = new SwingMetawidget();
		CompositeInspectorConfig inspectorConfig = new CompositeInspectorConfig().setInspectors(							
					<symbol>new PropertyTypeInspector(),
					new TooltipInspector() );</symbol>
		metawidget.setInspector( new CompositeInspector( inspectorConfig ) );
		metawidget.setToInspect( person );

		JFrame frame = new JFrame( "Metawidget Tutorial" );
		frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
		frame.getContentPane().add( metawidget );
		frame.setSize( 400, 250 );
		frame.setVisible( true );
	}
	
	<symbol>@Retention( RetentionPolicy.RUNTIME )
	@Target( { ElementType.FIELD, ElementType.METHOD } )
	static @interface Tooltip {
		String value();
	}

	static class TooltipInspector
		extends BaseObjectInspector {

		protected Map&lt;String, String&gt; inspectProperty( Property property )
			throws Exception {
			
			Map&lt;String, String&gt; attributes = CollectionUtils.newHashMap();

			Tooltip tooltip = property.getAnnotation( Tooltip.class );

			if ( tooltip != null )
				attributes.put( "tooltip", tooltip.value() );

			return attributes;
		}
	}</symbol>
}</programlisting>
						<para>
							You could then annotate the <classname>Person</classname> class...
						</para>
						
						<programlisting language="java">package com.myapp;

<symbol>import com.myapp.Main.Tooltip;</symbol>

public class Person {
	<symbol>@Tooltip("Person's full name")</symbol>
	public String name;
	<symbol>@Tooltip("Age in years")</symbol>
	public int age;
	<symbol>@Tooltip("Whether person is retired")</symbol>
	public boolean retired;
}</programlisting>

						<para>
							...and <classname>TooltipInspector</classname> would pick up the custom <classname>@Tooltip</classname>
							annotation and feed it into the Metawidget pipeline.
						</para>
						
						<tip>
							<title>Note</title>							
							Because Metawidget decouples inspection from widget creation, by default <classname>SwingMetawidget</classname>
							will not be expecting this new <parameter>tooltip</parameter> attribute and will ignore it. You will
							need to further combine this example with a <classname>TooltipProcessor</classname>, see
							<xref linkend="section-architecture-widgetprocessors-implementing-your-own"/>.
						</tip>
						
					</listitem>
					<listitem>				
						<para>
							For inspecting XML files, <classname>BaseXmlInspector</classname> assists
							in opening and traversing through the XML, as well as merging multiple XML files
							into one (eg. merging multiple Hibernate mapping files). Here is an example of a
							custom <classname>Inspector</classname> to inspect XML:
						</para>
						
						<para>
							TODO: for now, see <classname>StrutsInspector</classname> for example usage.
						</para>
					</listitem>
				</itemizedlist>
	
				<para>
					When implementing your own inspector, try to avoid technology-specific XML attribute names. For example, <classname>FacesInspector</classname>
					has an annotation <classname>@UiFacesNumberConverter</classname>. This annotation certainly has technology-specific parts to it, as
					it names a JSF <classname>Converter</classname> that only applies in JSF environments, so
					it is reasonable to name the XML attribute <parameter>faces-converter-class</parameter>. However, <classname>NumberConverter</classname>s also
					use other properties about the field, such as the maximum number of integer digits. Such properties are not JSF-specific (eg. we can
					source the same property from Hibernate Validator's <classname>@Digits</classname> annotation), so are better named 'neutrally'
					(eg. <classname>maximum-integer-digits</classname>). 
				</para>
				
				<important>
					<title>Config classes must override equals and hashCode</title>
					If your <classname>Inspector</classname> has a <classname>xxxInspectorConfig</classname> class, and you want
					it to be cacheable and reusable by
					<classname>ConfigReader</classname> and <filename>metawidget.xml</filename>,  the <classname>xxxInspectorConfig</classname>
					class <emphasis>must</emphasis> override <function>equals</function> and <function>hashCode</function>.
				</important>				
				
				<tip>
					<title>Generate an XML Schema</title>
					If your <classname>Inspector</classname> has an <classname>xxxInspectorConfig</classname> class, consider
					defining an XML Schema for it. This is optional, but allows users to validate their use of your <classname>Inspector</classname> in their
					<filename>metawidget.xml</filename> at development time. There is an Ant task,
					<classname>org.metawidget.config.XmlSchemaGeneratorTask</classname>, provided in the source distribution that can help with this
					by auto-generating the schema. All the existing Metawidget schemas are generated using this Ant task.
				</tip>				
				
			</section>

		</section>

		<section id="section-architecture-inspectionresultprocessors">
			<title>Inspection Result Processors</title>

			<para>
				<classname>InspectionResultProcessor</classname>s allow arbitrary processing of the inspection result
				returned by the <classname>Inspector</classname>, before it is passed to the <classname>WidgetBuilder</classname>.
				This section covers <classname>InspectionResultProcessor</classname>s in general. For in-depth documentation of individual
				<classname>InspectionResultProcessor</classname>s see <xref linkend="chapter-inspectionresultprocessors"/>.
			</para>
			

			<section id="section-architecture-inspectionresultprocessors-interface">
				<title>Interface</title>

				<para>
					All <classname>InspectionResultProcessor</classname>s must implement the <classname>InspectionResultProcessor</classname> interface. This is a simple
					interface that defines only one method:
				</para>
				
				<programlisting language="java">E processInspectionResult( E inspectionResult, M metawidget );</programlisting>
				
				<para>
					Where <parameter>E</parameter> is a DOM Element (typically <classname>org.w3c.dom.Element</classname>) containing
					the inspection result, and M is a Metawidget class (ie. <classname>SwingMetawidget</classname>, <classname>UIMetawidget</classname> etc).					
				</para>
				
				<para>
					The <classname>InspectionResultProcessor</classname> must returned the processed inspection result's DOM Element. This is typically
					the same as the given <parameter>inspectionResult</parameter>. The parent Metwidget then passes this to the next
					<classname>InspectionResultProcessor</classname> in the list as show in <xref linkend="section-architecture-inspectionresultprocessors-typical"/>.
				</para>
				
				<!--
					http://www.websequencediagrams.com:
					
					Metawidget->InspectionResultProcessor #1: asks to process
					InspectionResultProcessor #1->InspectionResultProcessor #1: processes\nresult
					InspectionResultProcessor #1->Metawidget: returns processed result
					Metawidget->InspectionResultProcessor #2: asks to process
					InspectionResultProcessor #2->InspectionResultProcessor #2: processes\nresult
					InspectionResultProcessor #2->Metawidget: returns processed result
				-->
				
				<figure id="section-architecture-inspectionresultprocessors-typical">
					<title>Typical InspectionResultProcessor list</title>
					<screenshot>
						<graphic fileref="images/activitydiagrams/architecture-inspectionresultprocessors.png" width="100mm"/>
					</screenshot>							
				</figure>
				
				<para>
					In most cases the <classname>InspectionResultProcessor</classname> will simply be modifying the given <parameter>inspectionResult</parameter>.
					However it can decide to swap it out by returning a different DOM. This new DOM will then be passed down the list. Alternatively,
					the <classname>InspectionResultProcessor</classname> can return <parameter>null</parameter> to cancel inspection entirely. No further
					<classname>InspectionResultProcessor</classname>s will be called, as shown in <xref linkend="section-architecture-inspectionresultprocessors-abort"/>.
				</para>

				<!--
					http://www.websequencediagrams.com:
					
					participant Metawidget
					participant "InspectionResultProcessor #1"
					participant "InspectionResultProcessor #2"					
					Metawidget->InspectionResultProcessor #1: asks to process
					InspectionResultProcessor #1->InspectionResultProcessor #1: aborts\ninspection
					InspectionResultProcessor #1->Metawidget: returns null
				-->
				
				<figure id="section-architecture-inspectionresultprocessors-abort">
					<title>An InspectionResultProcessor can abort the inspection</title>
					<screenshot>
						<graphic fileref="images/activitydiagrams/architecture-inspectionresultprocessors-abort.png" width="100mm"/>
					</screenshot>							
				</figure>
				
			</section>

			<section id="section-architecture-inspectionresultprocessors-defaults">
				<title>Defaults</title>
				
				<para>
					Most Metawidgets have default <classname>InspectionResultProcessor</classname>s. You can see the default by looking in the
					Metawidget JAR for the file <filename>metawidget-xxx-default.xml</filename> (where <filename>xxx</filename>
					is your target platform, such as <filename>swing</filename> or <filename>struts</filename>). 
				</para>
				
				<para>
					For reference, the defaults are:
				</para>
				
				<informaltable>
					<colgroup>
						<col width="30%"/>
						<col width="70%"/>
					</colgroup>
					<thead>
						<tr>
							<th align="left">Platform</th>
							<th align="left">Default</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>Android</td>
							<td><programlisting language="xml">&lt;array&gt;
	&lt;comesAfterInspectionResultProcessor /&gt;
&lt;/array&gt;</programlisting></td>
						</tr>
						<tr>
							<td>GWT</td>
							<td><programlisting language="xml">&lt;array&gt;
	&lt;comesAfterInspectionResultProcessor /&gt;
&lt;/array&gt;</programlisting></td>
						</tr>
						<tr>
							<td>JSF</td>
							<td><programlisting language="xml">&lt;array&gt;
	&lt;comesAfterInspectionResultProcessor /&gt;
&lt;/array&gt;</programlisting></td>
						</tr>
						<tr>
							<td>JSP</td>
							<td><programlisting language="xml">&lt;array&gt;
	&lt;comesAfterInspectionResultProcessor /&gt;
&lt;/array&gt;</programlisting></td>
						</tr>
						<tr>
							<td>Spring</td>
							<td><programlisting language="xml">&lt;array&gt;
	&lt;comesAfterInspectionResultProcessor /&gt;
&lt;/array&gt;</programlisting></td>
						</tr>
						<tr>
							<td>Struts</td>
							<td><programlisting language="xml">&lt;array&gt;
	&lt;comesAfterInspectionResultProcessor /&gt;
&lt;/array&gt;</programlisting></td>
						</tr>
						<tr>
							<td>Swing</td>
							<td><programlisting language="xml">&lt;array&gt;
	&lt;comesAfterInspectionResultProcessor /&gt;
&lt;/array&gt;</programlisting></td>
						</tr>
					</tbody>
				</informaltable>
			</section>

			<section id="section-architecture-inspectionresultprocessors-immutability">
				<title>Immutability</title>
				
				<para>
					All <classname>InspectionResultProcessor</classname>s are required to be immutable. This means you only
					need a single instance of an <classname>InspectionResultProcessor</classname> for your entire application. If you are using
					<filename>metawidget.xml</filename> then <classname>ConfigReader</classname> takes care
					of this for you, but if you are instantiating <classname>InspectionResultProcessor</classname>s in Java code you should
					reuse instances.
				</para>
				
			</section>

			<section id="section-architecture-inspectionresultprocessors-implementing-your-own">
				<title>Implementing Your Own InspectionResultProcessor</title>

				<para>
					Here is an example of a custom <classname>InspectionResultProcessor</classname> that chooses,
					and sorts, business object fields based on a <classname>JComponent</classname> client property. It extends the code from the tutorial
					(see <xref linkend="section-introduction-part1"/>).
				</para>
				
				<programlisting language="java">package com.myapp;
			
<symbol>import static org.metawidget.inspector.InspectionResultConstants.*;</symbol>

import javax.swing.*;
import org.metawidget.swing.*;
<symbol>import org.metawidget.inspectionresultprocessor.iface.*;
import org.metawidget.util.*;
import org.w3c.dom.*;</symbol>

public class Main {

	public static void main( String[] args ) {
		Person person = new Person();

		SwingMetawidget metawidget = new SwingMetawidget();
		<symbol>metawidget.addInspectionResultProcessor( new IncludingInspectionResultProcessor() );
		metawidget.putClientProperty( "include", new String[]{ "age", "retired" } );</symbol>
		metawidget.setToInspect( person );

		JFrame frame = new JFrame( "Metawidget Tutorial" );
		frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
		frame.getContentPane().add( metawidget );
		frame.setSize( 400, 250 );
		frame.setVisible( true );
	}
	
	<symbol>static class IncludingInspectionResultProcessor
		implements InspectionResultProcessor&lt;Element, SwingMetawidget&gt; {
		
		public Element processInspectionResult( Element inspectionResult, SwingMetawidget metawidget ) {
		
			String[] includes = (String[]) metawidget.getClientProperty( "include" );
			Element entity = (Element) inspectionResult.getFirstChild();
			int propertiesToCleanup = entity.getChildNodes().getLength();

			// Pull out the names in order

			for( String include : includes ) {
			
				Element property = XmlUtils.getChildWithAttributeValue( entity, NAME, include );

				if ( property == null )
					continue;

				entity.appendChild( property );
				propertiesToCleanup--;
			}

			// Remove the rest

			for( int loop = 0; loop &lt; propertiesToCleanup; loop++ ) {
				entity.removeChild( entity.getFirstChild() );
			}

			return inspectionResult;
		}
	}</symbol>
}</programlisting>

				<tip>
					<title>Note</title>
					We don't necessarily recommend this approach, as it requires hard-coding business property names and won't refactor well.
				</tip>
			</section>

		</section>

		<section id="section-architecture-widgetbuilders">
			<title>Widget Builders</title>
			
			<para>
				WidgetBuilders decouple the process of choosing widgets based on inspection results. This section
				covers WidgetBuilders in general. For in-depth documentation of individual WidgetBuilders
				see <xref linkend="chapter-widgetbuilders"/>.
			</para>
			
			<section id="section-architecture-widgetbuilders-interface">
				<title>Interface</title>

				<para>
					All WidgetBuilders must implement the <classname>WidgetBuilder</classname> interface. This is a simple
					interface that defines only one method:
				</para>
				
				<programlisting language="java">W buildWidget( String elementName, Map&lt;String, String&gt; attributes, M metawidget )</programlisting>
				
				<para>
					Where <parameter>W</parameter> is a widget type (such as <classname>JComponent</classname> or <classname>UIComponent</classname>)
					and <parameter>M</parameter> is a Metawidget type (such as <classname>SwingMetawidget</classname> or <classname>UIMetawidget</classname>).
				</para>
				
				<para>
					Each WidgetBuilder must look to the <parameter>elementName</parameter>, which is typically just 'property' or 'action'
					from the <filename>inspection-result</filename>, and
					to the various <parameter>attributes</parameter> and instantiate an appropriate widget. WidgetBuilders can use
					the given <parameter>metawidget</parameter> to help them if needed (for example, to access a UI context with which
					to instantiate widgets). Typically the WidgetBuilders do not need to configure the widget beyond simply instantiating it: the job
					of setting <parameter>id</parameter>s, attaching validators, configuring bindings and so forth is done by the
					<classname>WidgetProcessor</classname>s (see <xref linkid="section-architecture-widgetprocessors"/>).
				</para>
				
			</section>
			
			<section id="section-architecture-widgetbuilders-usage">
				<title>Usage</title>
				
				<para>
					Unless explicitly specified, each Metawidget will instantiate default <classname>WidgetBuilder</classname>s to match
					the target platform. For example, <classname>SwingMetawidget</classname> will by default
					instantiate an
					<classname>OverriddenWidgetBuilder</classname>, <classname>ReadOnlyWidgetBuilder</classname> and <classname>SwingWidgetBuilder</classname>.
				</para>
				
				<para>
					This default behaviour can be overridden either in code:
				</para>
				
				<programlisting language="java">metawidget.setWidgetBuilder( new MyWidgetBuilder() );</programlisting>
				
				<para>
					Or via <filename>metawidget.xml</filename>
				</para>
				
				<programlisting language="xml">&lt;swingMetawidget xmlns="java:org.metawidget.swing"&gt;
	&lt;widgetBuilder&gt;
		&lt;myWidgetBuilder xmlns="java:com.myapp"/&gt;
	&lt;/widgetBuilder&gt;
&lt;/swingMetawidget&gt;</programlisting>
	
				<para>
					This allows easy plugging in of third-party widget libraries. Note that overriding the default
					means the default is no longer instantiated. In the example above, this would mean <classname>MyWidgetBuilder</classname>
					is used but <classname>OverriddenWidgetBuilder</classname>, <classname>ReadOnlyWidgetBuilder</classname>
					and <classname>SwingWidgetBuilder</classname> are not. This is usually not what you want,
					because <classname>MyWidgetBuilder</classname> will be focussed on a particular third party library and
					will want to leave widget overriding to <classname>OverriddenWidgetBuilder</classname>, read-only
					widgets (ie. labels) to <classname>ReadOnlyWidgetBuilder</classname> and
					standard widgets to <classname>SwingWidgetBuilder</classname>.
				</para>
				
				<para>
					To achieve this, use <classname>CompositeWidgetBuilder</classname>.
				</para>
				
			</section>
			
			<section id="section-architecture-compositewidgetbuilder">
				<title>CompositeWidgetBuilder</title>

				<para>
					<classname>CompositeWidgetBuilder</classname> combines the widget libraries of several
					<classname>WidgetBuilder</classname>s. It defers widget building to an internal list of
					<classname>WidgetBuilder</classname>s, in order, and goes with the first one that returns
					non-null (see figure <xref linkend="section-architecture-compositewidgetbuilder-chain"/>).
				</para>
				
				<!--
					http://www.websequencediagrams.com:
					
					participant Metawidget
					participant CompositeWidgetBuilder
					participant "WidgetBuilder #1"
					participant "WidgetBuilder #2"
					participant "WidgetBuilder #3"
					Metawidget->CompositeWidgetBuilder: asks for widget
					CompositeWidgetBuilder->WidgetBuilder #1: asks for widget
					WidgetBuilder #1->CompositeWidgetBuilder: returns null
					CompositeWidgetBuilder->WidgetBuilder #2: asks for widget
					WidgetBuilder #2->CompositeWidgetBuilder: returns widget
					CompositeWidgetBuilder->Metawidget: returns widget
				-->
				
				<figure id="section-architecture-compositewidgetbuilder-chain">
					<title>CompositeWidgetBuilder composes multiple WidgetBuilders into one</title>
					<screenshot>
						<graphic fileref="images/activitydiagrams/architecture-compositewidgetbuilder.png" width="140mm"/>
					</screenshot>			
				</figure>
				
				<para>					
					In this way <classname>WidgetBuilder</classname>s for third party UI component libraries
					(that provide specialized components) can be listed first, and <classname>WidgetBuilder</classname>s for the
					platform's standard components can be listed last (as a 'fallback' choice).					  
				</para>
				
				<para>
					<classname>CompositeWidgetBuilder</classname> can be instantiated either in code:
				</para>
							
				<programlisting language="java">metawidget.setWidgetBuilder( new CompositeWidetBuilder( new CompositeWidgetBuilderConfig()
	.setWidgetBuilders(
		new MyWidgetBuilder(), new SwingWidgetBuilder()
	)));</programlisting>
				
				<para>
					Or via <filename>metawidget.xml</filename>
				</para>
				
				<programlisting language="xml">&lt;swingMetawidget xmlns="java:org.metawidget.swing"&gt;
	&lt;widgetBuilder&gt;
		&lt;compositeWidgetBuilder
			xmlns="java:org.metawidget.widgetbuilder.composite"
			config="CompositeWidgetBuilderConfig"&gt;
			&lt;widgetBuilders&gt;
				&lt;array&gt;
					&lt;overriddenWidgetBuilder xmlns="java:org.metawidget.swing.widgetbuilder"/&gt;
					&lt;readOnlyWidgetBuilder xmlns="java:org.metawidget.swing.widgetbuilder"/&gt;
					&lt;myWidgetBuilder xmlns="java:com.myapp"/&gt;
					&lt;swingWidgetBuilder xmlns="java:org.metawidget.swing.widgetbuilder"/&gt;
				&lt;/array&gt;
			&lt;/widgetBuilders&gt;
		&lt;/compositeWidgetBuilder&gt;
	&lt;/widgetBuilder&gt;
&lt;/swingMetawidget&gt;</programlisting>

			</section>

			<section id="section-architecture-overriddenwidgetbuilder">
				<title>OverriddenWidgetBuilder</title>
				
				<para>
					The first <classname>WidgetBuilder</classname> in the <classname>CompositeWidgetBuilder</classname>
					chain should generally be an <classname>OverriddenWidgetBuilder</classname>. This looks for existing
					child widgets that override default generation. What consitutes an 'overriden widget' varies from
					platform to platform. For example, for Swing any child widget with the same <parameter>name</parameter>
					will be taken as the override (see <xref linkend="section-introduction-part1-creation"/>). Android
					uses the <parameter>tag</parameter> attribute, JSF uses the value binding, and so on. For details
					on the <classname>OverriddenWidgetBuilder</classname> for your platform see <xref linkend="chapter-widgetbuilders"/>.
				</para>
				
				<para>
					You can also choose to plug-in your own <classname>WidgetBuilder</classname> that detects 'overriden widgets' based
					on your own criteria. Here is an example of a custom <classname>WidgetBuilder</classname> that excludes widgets
					based on a client property. It extends the code from the tutorial (see <xref linkend="section-introduction-part1"/>).
				</para>
				
				<programlisting language="java">package com.myapp;
			
<symbol>import static org.metawidget.inspector.InspectionResultConstants.*;

import java.util.*;</symbol>

import javax.swing.*;
import org.metawidget.swing.*;
<symbol>import org.metawidget.swing.widgetbuilder.*;
import org.metawidget.widgetbuilder.composite.*;
import org.metawidget.widgetbuilder.iface.*;
import org.metawidget.util.*;</symbol>

public class Main {

	public static void main( String[] args ) {
		Person person = new Person();

		SwingMetawidget metawidget = new SwingMetawidget();
		<symbol>metawidget.setWidgetBuilder( new CompositeWidgetBuilder&lt;JComponent, SwingMetawidget&gt;(
			new CompositeWidgetBuilderConfig&lt;JComponent, SwingMetawidget&gt;().setWidgetBuilders(
				new ExcludingWidgetBuilder(),
				new SwingWidgetBuilder() ) ) );
		metawidget.putClientProperty( "exclude", new String[]{ "age", "retired" } );</symbol>
		metawidget.setToInspect( person );

		JFrame frame = new JFrame( "Metawidget Tutorial" );
		frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
		frame.getContentPane().add( metawidget );
		frame.setSize( 400, 250 );
		frame.setVisible( true );
	}
	
	<symbol>static class ExcludingWidgetBuilder
		implements WidgetBuilder&lt;JComponent, SwingMetawidget&gt; {
		public JComponent buildWidget( String elementName, Map&lt;String, String&gt; attributes,
										SwingMetawidget metawidget ) {
			String[] exclude = (String[]) metawidget.getClientProperty( "exclude" );

			if ( ArrayUtils.contains( exclude, attributes.get( NAME )))
				return new Stub();

			return null;
		}
	}</symbol>
}</programlisting>

				<tip>
					<title>Note</title>
					We don't necessarily recommend this approach, as it requires hard-coding business property names and won't refactor well.
				</tip>

				<tip>
					<title>Note</title>
					Although you could adapt this approach to only include (instead of exclude) certain fields, you could not adapt it
					to include fields <emphasis>in the order given in the client property</emphasis>. This is because <classname>WidgetBuilder</classname>s
					only operate on single widgets at a time. Instead, see <xref linkend="section-architecture-inspectionresultprocessors"/> 
				</tip>
			</section>
			
			<section id="section-architecture-readonlywidgetbuilder">
				<title>ReadOnlyWidgetBuilder</title>
				
				<para>
					The second <classname>WidgetBuilder</classname> in the <classname>CompositeWidgetBuilder</classname>
					chain should generally be a <classname>ReadOnlyWidgetBuilder</classname>. This builds standard
					platform widgets (ie. labels) for fields with <parameter>read-only="true"</parameter>.
				</para>
				
				<para>
					The exception to this rule would be if you wanted to add a custom <classname>WidgetBuilder</classname>
					for a widget library that had its own read-only components, or if you wanted to customise the
					read-only handling. Here is an example of a custom <classname>WidgetBuilder</classname> that returns
					non-editable <classname>JTextField</classname>s (instead of <classname>JLabel</classname>s)
					for read-only fields. It extends the code from the tutorial (see <xref linkend="section-introduction-part1"/>).
				</para>
				
				<programlisting language="java">package com.myapp;
			
<symbol>import static org.metawidget.inspector.InspectionResultConstants.*;

import java.util.*;</symbol>

import javax.swing.*;
import org.metawidget.swing.*;
<symbol>import org.metawidget.swing.widgetbuilder.*;
import org.metawidget.widgetbuilder.composite.*;
import org.metawidget.widgetbuilder.iface.*;
import org.metawidget.util.*;</symbol>

public class Main {

	public static void main( String[] args ) {
		Person person = new Person();

		SwingMetawidget metawidget = new SwingMetawidget();
		<symbol>metawidget.setWidgetBuilder( new CompositeWidgetBuilder&lt;JComponent, SwingMetawidget&gt;(
			new CompositeWidgetBuilderConfig&lt;JComponent, SwingMetawidget&gt;().setWidgetBuilders(
				new ReadOnlyTextFieldWidgetBuilder(),
				new SwingWidgetBuilder() ) ) );</symbol>
		metawidget.setToInspect( person );

		JFrame frame = new JFrame( "Metawidget Tutorial" );
		frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
		frame.getContentPane().add( metawidget );
		frame.setSize( 400, 250 );
		frame.setVisible( true );
	}
	
	<symbol>static class ReadOnlyTextFieldWidgetBuilder
		implements WidgetBuilder&lt;JComponent, SwingMetawidget&gt; {
		public JComponent buildWidget( String elementName, Map&lt;String, String&gt; attributes,
										SwingMetawidget metawidget ) {
			if ( !WidgetBuilderUtils.isReadOnly( attributes ) )
				return null;

			if ( TRUE.equals( attributes.get( HIDDEN )))
				return null;

			Class&lt;?&gt; clazz = ClassUtils.niceForName( attributes.get( TYPE ) );

			if ( String.class.equals( clazz ) || clazz.isPrimitive() ) {
				JTextField textField = new JTextField();
				textField.setEditable( false );

				return textField;
			}

			return null;
		}
	}</symbol>
}</programlisting>

			</section>

			<section id="section-architecture-widgetbuilders-defaults">
				<title>Defaults</title>
				
				<para>
					All Metawidgets have default <classname>WidgetBuilder</classname>s. Overriding the default means the default is no
					longer instantiated. Usually this is not what you want, so you should consider instantiating
					the default along with your new <classname>WidgetBuilder</classname> (ie. use <classname>CompositeWidgetBuilder</classname>).
					You can see the default by looking in the
					Metawidget JAR for the file <filename>metawidget-xxx-default.xml</filename> (where <filename>xxx</filename>
					is your target platform, such as <filename>swing</filename> or <filename>struts</filename>). 
				</para>
				
				<para>
					For reference, the defaults are:
				</para>
				
				<informaltable>
					<colgroup>
						<col width="30%"/>
						<col width="70%"/>
					</colgroup>
					<thead>
						<tr>
							<th align="left">Platform</th>
							<th align="left">Default</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>Android</td>
							<td>...TODO...</td>
						</tr>
						<tr>
							<td>GWT</td>
							<td>...TODO...</td>							
						</tr>
						<tr>
							<td>JSF</td>
							<td><programlisting language="xml">&lt;compositeWidgetBuilder config="CompositeWidgetBuilderConfig"&gt;
	&lt;widgetBuilders&gt;
		&lt;array&gt;
			&lt;overriddenWidgetBuilder /&gt;
			&lt;readOnlyWidgetBuilder /&gt;
			&lt;htmlWidgetBuilder /&gt;
		&lt;/array&gt;
	&lt;/widgetBuilders&gt;
&lt;/compositeWidgetBuilder&gt;</programlisting></td>							
						</tr>
						<tr>
							<td>JSP</td>
							<td><programlisting language="xml">&lt;compositeWidgetBuilder config="CompositeWidgetBuilderConfig"&gt;
	&lt;widgetBuilders&gt;
		&lt;array&gt;
			&lt;overriddenWidgetBuilder /&gt;
			&lt;readOnlyWidgetBuilder /&gt;
			&lt;htmlWidgetBuilder /&gt;
		&lt;/array&gt;
	&lt;/widgetBuilders&gt;
&lt;/compositeWidgetBuilder&gt;</programlisting></td>							
						</tr>
						<tr>
							<td>Spring</td>
							<td><programlisting language="xml">&lt;compositeWidgetBuilder config="CompositeWidgetBuilderConfig"&gt;
	&lt;widgetBuilders&gt;
		&lt;array&gt;
			&lt;overriddenWidgetBuilder /&gt;
			&lt;springWidgetBuilder /&gt;
			&lt;readOnlyWidgetBuilder /&gt;
			&lt;htmlWidgetBuilder /&gt;
		&lt;/array&gt;
	&lt;/widgetBuilders&gt;
&lt;/compositeWidgetBuilder&gt;</programlisting></td>							
						</tr>
						<tr>
							<td>Struts</td>
							<td><programlisting language="xml">&lt;compositeWidgetBuilder config="CompositeWidgetBuilderConfig"&gt;
	&lt;widgetBuilders&gt;
		&lt;array&gt;
			&lt;overriddenWidgetBuilder /&gt;
			&lt;strutsWidgetBuilder /&gt;
			&lt;readOnlyWidgetBuilder /&gt;
			&lt;htmlWidgetBuilder /&gt;
		&lt;/array&gt;
	&lt;/widgetBuilders&gt;
&lt;/compositeWidgetBuilder&gt;</programlisting></td>							
						</tr>
						<tr>
							<td>Swing</td>
							<td><programlisting language="xml">&lt;compositeWidgetBuilder config="CompositeWidgetBuilderConfig"&gt;
	&lt;widgetBuilders&gt;
		&lt;array&gt;
			&lt;overriddenWidgetBuilder /&gt;
			&lt;readOnlyWidgetBuilder /&gt;
			&lt;swingWidgetBuilder /&gt;
		&lt;/array&gt;
	&lt;/widgetBuilders&gt;
&lt;/compositeWidgetBuilder&gt;</programlisting></td>							
						</tr>
					</tbody>
				</informaltable>
				
			</section>

			<section id="section-architecture-widgetbuilders-immutability">
				<title>Immutability</title>
				
				<para>
					All WidgetBuilders are required to be immutable. This means you only
					need a single instance of a WidgetBuilder for your entire application. If you are using
					<filename>metawidget.xml</filename> then <classname>ConfigReader</classname> takes care
					of this for you, but if you are instantiating WidgetBuilders in Java code you should
					reuse instances.
				</para>
				
				<para>
					Note that immutable only means <classname>WidgetBuilder</classname>s cannot be changed once instantiated - it does not
					mean they cannot be configured. Many <classname>WidgetBuilder</classname>s have corresponding <classname>xxxConfig</classname>
					classes that allow them to be configured prior to instantation in a type-safe way. For example, a
					<classname>HtmlWidgetBuilder</classname> can be configured in code:
				</para>

				<programlisting language="java">metawidget.setWidgetBuilder( new HtmlWidgetBuilder( new HtmlWidgetBuilderConfig()
			.setDataTableStyleClass( "data-table" )));</programlisting>
				
				<para>
					Or in <filename>metawidget.xml</filename>:
				</para>
				
				<programlisting language="xml">&lt;htmlWidgetBuilder xmlns="java:org.metawidget.faces.component.html.widgetbuilder"
	config="HtmlWidgetBuilderConfig"&gt;
	&lt;dataTableStyleClass&gt;
		&lt;boolean&gt;data-table&lt;/boolean&gt;
	&lt;/dataTableStyleClass&gt;
&lt;/htmlWidgetBuilder&gt;</programlisting>				
				
			</section>
			
			<section id="section-architecture-widgetbuilders-implementing-your-own">
				<title>Implementing Your Own WidgetBuilder</title>
	
				<para>
					The pluggable nature of <classname>WidgetBuilder</classname>s makes it easy to add your own. Because <classname>CompositeWidgetBuilder</classname> can
					be used to chain <classname>WidgetBuilder</classname>s together, you only need worry about supporting your particular component library's widgets. You
					can simply return <parameter>null</parameter> for all other types of fields and rely on another <classname>WidgetBuilder</classname>
					further down the chain to instantiate one of the usual widgets.
				</para>
				
				<para>
					For example, <classname>RichFacesWidgetBuilder</classname> only instantiates the RichFaces components, and returns <parameter>null</parameter>
					for everything else.
				</para>
				
				<para>
					Here is an example of a custom <classname>WidgetBuilder</classname> that uses two <classname>JRadioButton</classname>s,
					instead of the usual <classname>JCheckBox</classname>, to represent <classname>boolean</classname> properties. It extends the code
					from the tutorial (see <xref linkend="section-introduction-part1"/>).
				</para>
				
				<programlisting language="java">package com.myapp;
			
<symbol>import static org.metawidget.inspector.InspectionResultConstants.*;

import java.awt.*;
import java.util.*;</symbol>
import javax.swing.*;
import org.metawidget.swing.*;
<symbol>import org.metawidget.swing.widgetbuilder.*;
import org.metawidget.widgetbuilder.composite.*;
import org.metawidget.widgetbuilder.impl.*;</symbol>

public class Main {

	public static void main( String[] args ) {
		Person person = new Person();

		SwingMetawidget metawidget = new SwingMetawidget();
		<symbol>metawidget.setWidgetBuilder( new CompositeWidgetBuilder&lt;JComponent, SwingMetawidget&gt;(
			new CompositeWidgetBuilderConfig&lt;JComponent, SwingMetawidget&gt;().setWidgetBuilders(
				new JRadioButtonWidgetBuilder(),
				new SwingWidgetBuilder() ) ) );</symbol>
		metawidget.setToInspect( person );

		JFrame frame = new JFrame( "Metawidget Tutorial" );
		frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
		frame.getContentPane().add( metawidget );
		frame.setSize( 400, 250 );
		frame.setVisible( true );
	}
	
	<symbol>static class JRadioButtonWidgetBuilder
		implements WidgetBuilder&lt;JComponent, SwingMetawidget&gt; {

		public JComponent buildWidget( String elementName, Map&lt;String, String&gt; attributes,
			SwingMetawidget metawidget ) {
			
			if ( !"boolean".equals( attributes.get( TYPE ) ) )
				return null;

			JRadioButton trueButton = new JRadioButton( "True" );
			JRadioButton falseButton = new JRadioButton( "False" );
			JPanel panel = new JPanel();
			panel.setLayout( new GridLayout( 2, 1 ) );
			panel.add( trueButton );
			panel.add( falseButton );

			ButtonGroup buttonGroup = new ButtonGroup();
			buttonGroup.add( trueButton );
			buttonGroup.add( falseButton );

			return panel;
		}
	}</symbol>
}</programlisting>

				<tip>
					<title>Generate an XML Schema</title>
					If your <classname>WidgetBuilder</classname> has an <classname>xxxWidgetBuilderConfig</classname> class, consider
					defining an XML Schema for it. This is optional, but allows users to validate their use of your <classname>WidgetBuilder</classname> in their
					<filename>metawidget.xml</filename> at development time. There is an Ant task,
					<classname>org.metawidget.config.XmlSchemaGeneratorTask</classname>, provided in the source distribution that can help with this
					by auto-generating the schema. All the existing Metawidget schemas are generated using this Ant task.
				</tip>
								
				<section id="section-architecture-widgetbuilders-implementing-your-own-faces">
					<title>Special considerations for Java Server Faces</title>
					
					<para>
						When developing <classname>WidgetBuilders</classname> for JSF component libraries, be aware that Metawidget integrates
						with the JSF lifecycle in a slightly unorthodox way. Upon POSTback, Metawidget first decodes, processes validators
						and updates the business model as usual. Upon <function>encodeBegin</function>, however, Metawidget
						<emphasis>destroys and recreates</emphasis>	all previously generated <classname>UIComponent</classname>s. This is so
						the <classname>UIComponent</classname>s can adapt to updates to the business model. For example, they might need to be changed
						from a <classname>UIOutputText</classname> to a <classname>UIInputText</classname> if the user clicks an
						<parameter>Edit</parameter> button.
					</para>
					
					<para>
						In most cases such recreation works well, but on occasion a component may not be expecting to be recreated, and may not function properly.
						For example, the ICEfaces <classname>SelectInputDate</classname> component stores the state of its date popup internally. If
						it is recreated, this state is lost and the popup never appears. For such components, <classname>WidgetBuilder</classname>
						authors can set the attribute <classname>UIMetawidget.COMPONENT_ATTRIBUTE_NOT_RECREATABLE</classname> on the component
						to prevent its destruction and recreation. Of course, this somewhat impacts its flexibility. For example, a
						<classname>SelectInputDate</classname> would not be able to change its date format in response to another component on the form.
					</para>
				</section>
				
			</section>			
			
		</section>

		<section id="section-architecture-widgetprocessors">
			<title>Widget Processors</title>

			<para>
				<classname>WidgetProcessor</classname>s allow arbitrary processing of a widget following
				its building by a <classname>WidgetBuilder</classname> and before its inclusion in the <classname>Layout</classname>.
				This section covers <classname>WidgetProcessor</classname>s in general. For in-depth documentation of individual
				<classname>WidgetProcessor</classname>s see <xref linkend="chapter-widgetprocessors"/>.
			</para>

			<section id="section-architecture-widgetprocessors-interface">
				<title>Interface</title>

				<para>
					All <classname>WidgetProcessor</classname>s must implement the <classname>WidgetProcessor</classname> interface.
					This is a simple interface that defines only one method:
				</para>
				
				<programlisting language="java">W processWidget( W widget, String elementName, Map&lt;String, String&gt; attributes, M metawidget );</programlisting>
				
				<para>
					Where <parameter>W</parameter> is a widget class (ie. <classname>JComponent</classname>, <classname>UIComponent</classname> etc)
					and M is a Metawidget class (ie. <classname>SwingMetawidget</classname>, <classname>UIMetawidget</classname> etc).					
				</para>
				
				<para>
					<function>processWidget</function> is called for each widget built by the <classname>WidgetBuilder</classname>s.
					<classname>WidgetProcessor</classname>s can modify
					the given <parameter>widget</parameter> according
					to the given <parameter>elementName</parameter> and various <parameter>attributes</parameter>. They can use
					the given <parameter>metawidget</parameter> to help them if needed (for example, to access a UI context with which
					to create validators).
				</para>
				<para>
					The <function>processWidget</function> method must return the processed widget. This is typically the same as the given
					<parameter>widget</parameter>. The parent Metawidget then passes this to the next <classname>WidgetProcessor</classname>
					in the list as show in <xref linkend="section-architecture-widgetprocessors-typical"/>.
				</para>

				<!--
					http://www.websequencediagrams.com:
					
					Metawidget->BindingProcessor: asks to process
					BindingProcessor->BindingProcessor: adds data binding
					BindingProcessor->Metawidget: returns bound widget
					Metawidget->ConverterProcessor: asks to process
					ConverterProcessor->ConverterProcessor: adds converter
					ConverterProcessor->Metawidget: returns widget with converter
					Metawidget->ValidatorProcessor: asks to process
					ValidatorProcessor->ValidatorProcessor: adds validator
					ValidatorProcessor->Metawidget: returns widget with validator
				-->
				
				<figure id="section-architecture-widgetprocessors-typical">
					<title>Typical WidgetProcessor list</title>
					<screenshot>
						<graphic fileref="images/activitydiagrams/architecture-widgetprocessors.png" width="100mm"/>
					</screenshot>							
				</figure>
				
				<para>
					In most cases the <classname>WidgetProcessor</classname> will simply be modifying the given <parameter>widget</parameter>
					(adding validators, changing styles and so on). However it can decide to swap the widget out by returning a different
					widget. This new widget will then be passed down the list as shown in
					<xref linkend="section-architecture-widgetprocessors-substitute"/>. For an example use of this capability, see
					<classname>HiddenFieldProcessor</classname>.
				</para>
				
				<!--
					http://www.websequencediagrams.com:
					
					Metawidget->HiddenFieldProcessor: gives stub for processing
					HiddenFieldProcessor->HiddenFieldProcessor: substitutes stub\nfor hidden field
					HiddenFieldProcessor->Metawidget: returns hidden field
					Metawidget->WidgetProcessor #2: gives hidden field for processing			 
				 -->
				 
				<figure id="section-architecture-widgetprocessors-substitute">
					<title>WidgetProcessors can substitute widgets</title>			
					<screenshot>
						<graphic fileref="images/activitydiagrams/architecture-widgetprocessors-substitute.png" width="100mm"/>
					</screenshot>							
				</figure>
				
				<para>
					Alternatively, the <classname>WidgetProcessor</classname> can decide to exclude the widget entirely by
					returning null. Subsequent <classname>WidgetProcessor</classname>s will not be called, as
					shown in <xref linkend="section-architecture-widgetprocessors-exclude"/>, and no
					widget will be added to the <classname>Layout</classname>.
				</para>
				
				<!--
					http://www.websequencediagrams.com:
					
					participant Metawidget
					participant "WidgetProcessor #1"
					participant "WidgetProcessor #2"
					Metawidget->WidgetProcessor #1: gives widget for processing
					WidgetProcessor #1->WidgetProcessor #1: decides to\nexclude widget
					WidgetProcessor #1->Metawidget: returns null
				 -->
				 
				<figure id="section-architecture-widgetprocessors-exclude">
					<title>WidgetProcessors can exclude widgets</title>			
					<screenshot>
						<graphic fileref="images/activitydiagrams/architecture-widgetprocessors-exclude.png" width="100mm"/>
					</screenshot>							
				</figure>

				<para>
					The list of <classname>WidgetProcessors</classname> is maintained by the parent Metawidget, and is changeable (this
					is different to say, <classname>CompositeInspector</classname> or <classname>CompositeWidgetBuilder</classname> whose
					lists are immutable). This capability is designed to allow easy attaching of event handlers, and scenarios such
					as inner classes that have connections to their parent class:					
				</para>
				
				<programlisting language="java">final Object someObject = ...;
				
metawidget.addWidgetProcessor( new WidgetProcessor&lt;JComponent, SwingMetawidget&gt;() {
	JComponent processWidget( JComponent widget, String elementName, Map&lt;String, String&gt; attributes,
											SwingMetawidget metawidget ) {
		...decide whether to attach event handler...
		
		widget.add( new AbstractAction() {
			public void actionPerformed( ActionEvent e ) {
				someObject.doSomething();
			}
		}	
	}
}</programlisting>
			</section>
			
			<section id="section-architecture-widgetprocessors-advancedinterface">
				<title>Advanced Interface</title>

				<para>
					The <classname>WidgetProcessor</classname> interface only has a single method. This allows
					it to take advantage of Java 7 language features such as: 
				</para>
				
				<programlisting language="java">metawidget.addWidgetProcessor(
	#(JComponent w, String name, Map&lt;String, String&gt; attr, SwingMetawidget m)
	{ w( #(ActionEvent e) { someObject.doSomething } ) } );</programlisting>
	
				<para>
					However for those needing more control over the <code>WidgetProcessor</code> lifecycle there is
					an extended interface <classname>AdvancedWidgetProcessor</classname>. This interface defines
					two additional methods:
				</para>
				
				<programlisting language="java">void onStartBuild( M metawidget );
				
void onEndBuild( M metawidget );</programlisting>

				<!--
					http://www.websequencediagrams.com
					
					Metawidget->WidgetProcessor: onStartBuild
					loop widget
					   Metawidget->WidgetProcessor: processWidget
					end
					Metawidget->WidgetProcessor: onEndBuild
				-->
				
				<figure id="section-architecture-widgetprocessors-loop">
					<title>onStartBuild and onEndBuild are called once, processWidget is called for each widget</title>
					<screenshot>
						<graphic fileref="images/activitydiagrams/architecture-widgetprocessors-loop.png" width="50mm"/>
					</screenshot>			
				</figure>
				
				<para>
					The first method, <function>onStartBuild</function>, is called at the start of the widget building process,
					before the <classname>WidgetBuilder</classname> is called. <classname>WidgetProcessor</classname>s may wish to act
					on this event to initialize themselves ready for processing. However it is acceptable to do nothing.				
				</para>
				<para>
					The last method, <function>onEndBuild</function>, is called at the end of the widget building process,
					after all widgets have been built and added to the <classname>Layout</classname>. <classname>WidgetProcessor</classname>s may wish to act
					on this event to clean themselves up following processing. However it is acceptable to do nothing.
				</para>
			</section>

			<section id="section-architecture-widgetprocessors-defaults">
				<title>Defaults</title>
				
				<para>
					Most Metawidgets have default <classname>WidgetProcessor</classname>s. You can see the default by looking in the
					Metawidget JAR for the file <filename>metawidget-xxx-default.xml</filename> (where <filename>xxx</filename>
					is your target platform, such as <filename>swing</filename> or <filename>struts</filename>). 
				</para>
				
				<para>
					For reference, the defaults are:
				</para>
				
				<informaltable>
					<colgroup>
						<col width="30%"/>
						<col width="70%"/>
					</colgroup>
					<thead>
						<tr>
							<th align="left">Platform</th>
							<th align="left">Default</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>Android</td>
							<td>(none)</td>
						</tr>
						<tr>
							<td>GWT</td>
							<td>(none)</td>
						</tr>
						<tr>
							<td>JSF</td>
							<td><programlisting language="xml">&lt;array&gt;
	&lt;requiredAttributeProcessor /&gt;
	&lt;immediateAttributeProcessor /&gt;
	&lt;standardBindingProcessor /&gt;
	&lt;readableIdProcessor /&gt;
	&lt;labelProcessor /&gt;
	&lt;standardValidatorProcessor /&gt;
	&lt;standardConverterProcessor /&gt;
	&lt;cssStyleProcessor /&gt;							
&lt;/array&gt;</programlisting></td>
						</tr>
						<tr>
							<td>JSP</td>
							<td>(none)</td>
						</tr>
						<tr>
							<td>Spring</td>
							<td>(none)</td>
						</tr>
						<tr>
							<td>Struts</td>
							<td>(none)</td>
						</tr>
						<tr>
							<td>Swing</td>
							<td><programlisting language="xml">&lt;array&gt;
	&lt;reflectionBindingProcessor /&gt;
&lt;/array&gt;</programlisting></td>
						</tr>
					</tbody>
				</informaltable>
				
			</section>			

			<section id="section-architecture-widgetprocessors-immutability">
				<title>Immutability</title>
				
				<para>
					All <classname>WidgetProcessor</classname>s are required to be immutable. This means you only
					need a single instance of a <classname>WidgetProcessor</classname> for your entire application. If you are using
					<filename>metawidget.xml</filename> then <classname>ConfigReader</classname> takes care
					of this for you, but if you are instantiating <classname>WidgetProcessor</classname>s in Java code you should
					reuse instances.
				</para>
				
				<para>
					Although individual <classname>WidgetProcessor</classname>s are immutable, the <classname>List</classname> they
					are contained in can be changed. Methods such as <function>addWidgetProcessor</function> allows clients to dynamically
					add <classname>WidgetProcessor</classname>s at runtime. This is useful for adding event handlers (see
					<xref linkend="section-architecture-widgetprocessors-interface"/>).
				</para>
				
				<para>
					Note that immutable only means <classname>WidgetProcessor</classname>s cannot be changed once instantiated - it does not
					mean they cannot be configured. Many <classname>WidgetProcessor</classname>s have corresponding <classname>xxxConfig</classname>
					classes that allow them to be configured prior to instantation in a type-safe way. For example, a
					<classname>BeansBindingProcessor</classname> can be configured in code:
				</para>

				<programlisting language="java">metawidget.addWidgetProcessor( new BeansBindingProcessor( new BeansBindingProcessorConfig()
			.setUpdateStrategy( UpdateStrategy.READ_WRITE )));</programlisting>
				
				<para>
					Or in <filename>metawidget.xml</filename>:
				</para>
				
				<programlisting language="xml">&lt;beansBindingProcessor xmlns="java:org.metawidget.swing.widgetprocessor.binding.beansbinding"
	config="BeansBindingProcessorConfig"&gt;
	&lt;updateStrategy&gt;
		&lt;enum&gt;READ_WRITE&lt;/enum&gt;
	&lt;/updateStrategy&gt;
&lt;/beansBindingProcessor&gt;</programlisting>				
				
			</section>

			<section id="section-architecture-widgetprocessors-implementing-your-own">
				<title>Implementing Your Own WidgetProcessor</title>
			
				<para>
					Here is an example of a custom <classname>WidgetProcessor</classname> to add tooltips to
					add <classname>JComponents</classname>. It extends the code from the tutorial
					(see <xref linkend="section-introduction-part1"/>).
				</para>
				
				<programlisting language="java">package com.myapp;
	
<symbol>import static org.metawidget.inspector.InspectionResultConstants.*;
import java.util.*;</symbol>
import javax.swing.*;
import org.metawidget.swing.*;
<symbol>import org.metawidget.widgetprocessor.impl.*;</symbol>

public class Main {

	public static void main( String[] args ) {
		Person person = new Person();

		SwingMetawidget metawidget = new SwingMetawidget();
		<symbol>metawidget.addWidgetProcessor( new TooltipProcessor() );</symbol>
		metawidget.setToInspect( person );

		JFrame frame = new JFrame( "Metawidget Tutorial" );
		frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
		frame.getContentPane().add( metawidget );
		frame.setSize( 400, 250 );
		frame.setVisible( true );
	}

	<symbol>static class TooltipProcessor
		implements WidgetProcessor&lt;JComponent, SwingMetawidget&gt; {
		
		public JComponent processWidget( JComponent widget, String elementName,
										 Map&lt;String, String&gt; attributes, SwingMetawidget metawidget ) {
			widget.setToolTipText( attributes.get( NAME ) );
			return widget;
		}
	}</symbol>
}</programlisting>

				<para>
					Like <classname>Inspector</classname>s, <classname>InspectionResultProcessor</classname>s, <classname>WidgetBuilder</classname>s and
					<classname>Layout</classname>s, <classname>WidgetProcessor</classname>s are required to be immutable.
					However you can still make them configurable by using
					<classname>xxxWidgetProcessorConfig</classname> classes. For example: 
				</para>
						
				<programlisting language="java">public class TooltipProcessorConfig {
	private String mPrefix;
	
	public TooltipProcessorConfig setPrefix( String prefix ) {
		mPrefix = prefix;
		return this;
	}

	public String getPrefix() {
		return mPrefix;
	}
	
	// ...must override equals and hashCode too...
}</programlisting>
				<para>
					These <classname>xxxWidgetProcessorConfig</classname> classes are then passed to the <classname>WidgetProcessor</classname>
					at construction time, and stored internally:
				</para>
				
				<programlisting language="java">public class TooltipProcessor {
	private String mPrefix;
	
	public TooltipProcessor( TooltipProcessorConfig config ) {
		mPrefix = config.getPrefix();
	}
}</programlisting>

				<para>
					This mechanism can then be controlled either programmatically:
				</para>
				
				<programlisting language="java">metawidget.addWidgetProcessor( new TooltipProcessor( new TooltipProcessorConfig().setPrefix("Tip:")));</programlisting>
					
				<para>
					Or through metawidget.xml:
				</para>
					
				<programlisting language="xml">&lt;tooltipProcessor xmlns="java:com.foo" config="TooltipProcessorConfig"&gt;
	&lt;prefix&gt;
		&lt;string&gt;Tip:&lt;/string&gt;
	&lt;/prefix&gt;
&lt;/tooltipProcessor&gt;</programlisting>

				<important>
					<title>Config classes must override equals and hashCode</title>
					If you want your configurable <classname>WidgetProcessor</classname> to be cacheable and reusable by
					<classname>ConfigReader</classname> and <filename>metawidget.xml</filename>,  the <classname>xxxWidgetProcessorConfig</classname>
					class <emphasis>must</emphasis> override <function>equals</function> and <function>hashCode</function>.
				</important>

				<tip>
					<title>Generate an XML Schema</title>
					If you intend your <classname>WidgetProcessor</classname> to be configurable via <filename>metawidget.xml</filename>, consider
					defining an XML Schema for it. This is optional, but allows users to validate their use of your <classname>WidgetProcessor</classname> in their
					<filename>metawidget.xml</filename> at development time. There is an Ant task,
					<classname>org.metawidget.config.XmlSchemaGeneratorTask</classname>, provided in the source distribution that can help with this
					by auto-generating the schema. All the existing Metawidget schemas are generated using this Ant task.
				</tip>				

			</section>
		</section>
		
		<section id="section-architecture-layouts">
			<title>Layouts</title>

			<para>
				<classname>Layout</classname>s arrange widgets on the screen, following their
				building by a <classname>WidgetBuilder</classname> and processing by any <classname>WidgetProcessor</classname>s.
				This section covers <classname>Layout</classname>s in general. For in-depth documentation of individual
				<classname>Layout</classname>s see <xref linkend="chapter-layouts"/>.
			</para>

			<section id="section-architecture-layouts-interface">
				<title>Interface</title>

				<para>
					All <classname>Layout</classname>s must implement the <classname>Layout</classname> interface.
					This is a simple interface that defines only one method:
				</para>
				
				<programlisting language="java">void layoutWidget(W widget,String elementName,Map&lt;String, String&gt; attributes,C container,M metawidget);</programlisting>

				<para>
					Where <parameter>W</parameter> is a widget class (ie. <classname>Control</classname>, <classname>JComponent</classname> etc),
					C is widget container class (ie. <classname>Composite</classname>, <classname>JComponent</classname> etc)
					and M is a Metawidget class (ie. <classname>SwtMetawidget</classname>, <classname>SwingMetawidget</classname> etc).					
				</para>
				
				<para>
					<function>layoutWidget</function> is called for	each widget. <classname>Layout</classname>s	should
					add the given <parameter>widget</parameter>
					as a child of the given <parameter>container</parameter>, according to the given
					<parameter>elementName</parameter> and <parameter>attributes</parameter>. They can use
					the given <parameter>metawidget</parameter> to access additional services if needed (such as
					state saving).
				</para>
				
			</section>

			<section id="section-architecture-layouts-advancedinterface">
				<title>Advanced Interface</title>

				<para>
					The <classname>Layout</classname> interface only has a single method. However for those
					needing more control over the <code>Layout</code> lifecycle there is
					an extended interface <classname>AdvancedLayout</classname>. This interface defines
					four additional methods:
				</para>

				<programlisting language="java">void onStartBuild(M metawidget);
				
void startContainerLayout(W container,M metawidget);
				
void endContainerLayout(W container,M metawidget);

void onEndBuild(M metawidget);</programlisting>
				
				<!--
					http://www.websequencediagrams.com
					
					Metawidget->Layout: onStartBuild
					loop container
					   Metawidget->Layout: startContainerLayout
					   loop widget
					      Metawidget->Layout: layoutWidget
					   end
					   Metawidget->Layout: endContainerLayout
					end
					Metawidget->Layout: onEndBuild
				-->
				
				<figure id="section-architecture-layouts-loop">
					<title>startContainerLayout and endContainerLayout are called for each container, layoutWidget is called for each widget</title>
					<screenshot>
						<graphic fileref="images/activitydiagrams/architecture-layouts-loop.png" width="50mm"/>
					</screenshot>			
				</figure>
				
				<para>
					The first method, <function>onStartBuild</function>, is called at the start of the widget building process,
					before the <classname>WidgetBuilder</classname> is called. <classname>Layout</classname>s may wish to act
					on this event to initialize themselves ready for processing, or to perform 'outermost-container-only' processing, such as adding facets.
					However it is acceptable to do nothing.				
				</para>				
				<para>
					The second method, <function>startContainerLayout</function>, is called to initialize the
					given <parameter>container</parameter>. It is acceptable to do nothing.			
				</para>
				<para>
					The third method, <function>endContainerLayout</function>, is called to finish the given <parameter>container</parameter>.
					It is acceptable to do nothing.
				</para>
				<para>
					The last method, <function>onEndBuild</function>, is called at the end of the widget building process,
					after all widgets have been built and added to the <classname>Layout</classname>. <classname>Layout</classname>s may wish to act
					on this event to clean themselves up following processing, or to perform 'outermost-container-only' processing, such as adding facets.
					However it is acceptable to do nothing.
				</para>				
			</section>

			<section id="section-architecture-layouts-layoutdecorator">
				<title>LayoutDecorator</title>
				
				<para>
					<classname>LayoutDecorator</classname> allows you to combine multiple <classname>Layout</classname>s
					together in a heirarchy. Conceptually, this is similar to <classname>CompositeInspector</classname>
					or <classname>CompositeWidgetBuilder</classname>, but <classname>Layout</classname>s are fundamentally
					different in that most are 'end points' that cannot sensibly be composed into sequential lists (eg. what
					should happen if you try to combine a <classname>GridBagLayout</classname> with a <classname>FlowLayout</classname>?).
				</para>
				
				<para>
					Rather, <classname>Layout</classname>s must be combined <emphasis>heirarchically</emphasis>, with an 'outer' <classname>Layout</classname>
					delegating to a single 'inner' <classname>Layout</classname>. <classname>LayoutDecorator</classname> is an abstract
					class that can be extended in order to decorate other <classname>Layout</classname>s. For example,
					<classname>GridBagLayout</classname> can be decorated using <classname>TabbedPaneLayoutDecorator</classname> to
					add tabbed section functionality.
				</para>
				
				<programlisting language="xml">&lt;metawidgetLayout&gt;
	&lt;tabbedPaneLayoutDecorator xmlns="java:org.metawidget.swing.layout"
		config="TabbedPaneLayoutDecoratorConfig"&gt;
		&lt;layout&gt;
			&lt;gridBagLayout /&gt;
		&lt;/layout&gt;
	&lt;/tabbedPaneLayoutDecorator&gt;			
&lt;/metawidgetLayout&gt;</programlisting>

				<para>
					A <classname>LayoutDecorator</classname> can also decorate another <classname>LayoutDecorator</classname> to provide
					fine-grained control over nested sections. For example, the business object...
				</para>

				<programlisting language="java">public class Person {
	@UiSection( { "Person", "Name" } )
	public String firstname;
	
	public String surname;
	
	@UiSection( { "Person", "Contact Detail" } )
	public String telephone;
}</programlisting>

				<para>
					...could be rendered using nested <classname>TabbedPaneLayoutDecorator</classname>s...
				</para>

				<programlisting language="xml">&lt;metawidgetLayout&gt;
	&lt;tabbedPaneLayoutDecorator xmlns="java:org.metawidget.swing.layout"
		config="TabbedPaneLayoutDecoratorConfig"&gt;
		&lt;layout&gt;
			&lt;tabbedPaneLayoutDecorator config="TabbedPaneLayoutDecoratorConfig"&gt;
				&lt;layout&gt;
					&lt;gridBagLayout /&gt;
				&lt;/layout&gt;
			&lt;/tabbedPaneLayoutDecorator&gt;			
		&lt;/layout&gt;
	&lt;/tabbedPaneLayoutDecorator&gt;			
&lt;/metawidgetLayout&gt;</programlisting>

				<para>
					...as shown in <xref linkend="section-architecture-layouts-layoutdecorator-nested-tabs"/>.
				</para>	

				<figure id="section-architecture-layouts-layoutdecorator-nested-tabs">
					<title>Nested TabbedPaneLayoutDecorators</title>
					<screenshot>
						<graphic fileref="images/screenshots/layout-nested-tabs.jpg" width="100mm"/>
					</screenshot>
				</figure>

				<para>
					Alternatively, it could use a <classname>TabbedPaneLayoutDecorator</classname> nested within a
					<classname>SeparatorLayoutDecorator</classname>...
				</para>

				<programlisting language="xml">&lt;metawidgetLayout&gt;
	&lt;separatorLayoutDecorator xmlns="java:org.metawidget.swing.layout"
		config="SeparatorLayoutDecoratorConfig"&gt;
		&lt;layout&gt;
			&lt;tabbedPaneLayoutDecorator config="TabbedPaneLayoutDecoratorConfig"&gt;
				&lt;layout&gt;
					&lt;gridBagLayout /&gt;
				&lt;/layout&gt;
			&lt;/tabbedPaneLayoutDecorator&gt;			
		&lt;/layout&gt;
	&lt;/separatorLayoutDecorator&gt;			
&lt;/metawidgetLayout&gt;</programlisting>

				<para>
					...as shown in <xref linkend="section-architecture-layouts-layoutdecorator-separator-tabs"/>.
				</para>	

				<figure id="section-architecture-layouts-layoutdecorator-separator-tabs">
					<title>TabbedPaneLayoutDecorator within a SeparatorLayoutDecorator</title>
					<screenshot>
						<graphic fileref="images/screenshots/layout-separator-tabs.jpg" width="100mm"/>
					</screenshot>
				</figure>

				<para>
					Or the opposite - a <classname>SeparatorLayoutDecorator</classname> nested within a
					<classname>TabbedPaneLayoutDecorator</classname>...
				</para>

				<programlisting language="xml">&lt;metawidgetLayout&gt;
	&lt;tabbedPaneLayoutDecorator xmlns="java:org.metawidget.swing.layout"
		config="TabbedPaneLayoutDecoratorConfig"&gt;
		&lt;layout&gt;
			&lt;separatorLayoutDecorator config="SeparatorLayoutDecoratorConfig"&gt;
				&lt;layout&gt;
					&lt;gridBagLayout /&gt;
				&lt;/layout&gt;
			&lt;/separatorLayoutDecorator&gt;			
		&lt;/layout&gt;
	&lt;/tabbedPaneLayoutDecorator&gt;			
&lt;/metawidgetLayout&gt;</programlisting>

				<para>
					...as shown in <xref linkend="section-architecture-layouts-layoutdecorator-tabs-separator"/>.
				</para>	

				<figure id="section-architecture-layouts-layoutdecorator-tabs-separator">
					<title>SeparatorLayoutDecorator within a TabbedPaneLayoutDecorator</title>
					<screenshot>
						<graphic fileref="images/screenshots/layout-tabs-separator.jpg" width="100mm"/>
					</screenshot>
				</figure>
			</section>

			<section id="section-architecture-layouts-defaults">
				<title>Defaults</title>
				
				<para>
					All Metawidgets have default <classname>Layout</classname>s.
					You can see the default by looking in the
					Metawidget JAR for the file <filename>metawidget-xxx-default.xml</filename> (where <filename>xxx</filename>
					is your target platform, such as <filename>swing</filename> or <filename>struts</filename>). 
				</para>
				
				<para>
					For reference, the defaults are:
				</para>
				
				<informaltable>
					<colgroup>
						<col width="30%"/>
						<col width="70%"/>
					</colgroup>
					<thead>
						<tr>
							<th align="left">Platform</th>
							<th align="left">Default</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>Android</td>
							<td><programlisting language="xml">&lt;textViewLayoutDecorator config="TextViewLayoutDecoratorConfig"&gt;
	&lt;layout&gt;
		&lt;tableLayout /&gt;
	&lt;/layout&gt;
&lt;/textViewLayoutDecorator&gt;</programlisting></td>							
						</tr>
						<tr>
							<td>GWT</td>
							<td><classname>LabelLayoutDecorator</classname> around a <classname>FlexTableLayout</classname></td>
						</tr>
						<tr>
							<td>JSF</td>
							<td><programlisting language="xml">&lt;outputTextLayoutDecorator config="OutputTextLayoutDecoratorConfig"&gt;
		&lt;layout&gt;
			&lt;simpleLayout/&gt;
		&lt;/layout&gt;
	&lt;/outputTextLayoutDecorator&gt;</programlisting></td>
						</tr>
						<tr>
							<td>JSP</td>
							<td><programlisting language="xml">&lt;headingTagLayoutDecorator config="HeadingTagLayoutDecoratorConfig"&gt;
	&lt;layout&gt;
		&lt;htmlTableLayout/&gt;
	&lt;/layout&gt;
&lt;/headingTagLayoutDecorator&gt;</programlisting></td>
						</tr>
						<tr>
							<td>Spring</td>
							<td><programlisting language="xml">&lt;headingTagLayoutDecorator config="HeadingTagLayoutDecoratorConfig"&gt;
	&lt;layout&gt;
		&lt;htmlTableLayout/&gt;
	&lt;/layout&gt;
&lt;/headingTagLayoutDecorator&gt;</programlisting></td>
						</tr>
						<tr>
							<td>Struts</td>
							<td><programlisting language="xml">&lt;headingTagLayoutDecorator config="HeadingTagLayoutDecoratorConfig"&gt;
	&lt;layout&gt;
		&lt;htmlTableLayout/&gt;
	&lt;/layout&gt;
&lt;/headingTagLayoutDecorator&gt;</programlisting></td>
						</tr>
						<tr>
							<td>Swing</td>
							<td><programlisting language="xml">&lt;separatorLayoutDecorator config="SeparatorLayoutDecoratorConfig"&gt;
	&lt;layout&gt;
		&lt;gridBagLayout/&gt;
	&lt;/layout&gt;
&lt;/separatorLayoutDecorator&gt;</programlisting></td>							
						</tr>
					</tbody>
				</informaltable>
				
			</section>

			<section id="section-architecture-layouts-immutability">
				<title>Immutability</title>
				
				<para>
					All <classname>Layout</classname>s are required to be immutable. This means you only
					need a single instance of a <classname>Layout</classname> for your entire application. If you are using
					<filename>metawidget.xml</filename> then <classname>ConfigReader</classname> takes care
					of this for you, but if you are instantiating <classname>Layout</classname>s in Java code you should
					reuse instances.
				</para>
				
				<para>
					Note that immutable only means <classname>Layout</classname>s cannot be changed once instantiated - it does not
					mean they cannot be configured. Many <classname>Layout</classname>s have corresponding <classname>xxxConfig</classname>
					classes that allow them to be configured prior to instantation in a type-safe way. For example, an
					<classname>HtmlTableLayout</classname> can be configured in code:
				</para>

				<programlisting language="java">metawidget.setLayout( new HtmlTableLayout( new HtmlTableLayoutConfig().setNumberOfColumns( 2 ));</programlisting>
				
				<para>
					Or in <filename>metawidget.xml</filename>:
				</para>
				
				<programlisting language="xml">&lt;htmlTableLayout xmlns="java:org.metawidget.jsp.tagext.html.layout"
	config="HtmlTableLayoutConfig"&gt;
	&lt;numberOfColumns&gt;
		&lt;int&gt;2&lt;/int&gt;
	&lt;/numberOfColumns&gt;
&lt;/htmlTableLayout&gt;</programlisting>				
			</section>

			<section id="section-architecture-layouts-implementing-your-own">
				<title>Implementing Your Own Layout</title>
			
				<para>
					Here is an example of a custom <classname>Layout</classname> that arranges components
					in a bulleted HTML list. It could be useful for, say, arranging <parameter>action</parameter>
					elements that were represented by HTML anchor tags:
				</para>
				
				<programlisting language="java">package com.myapp;

import java.util.*;
import javax.servlet.jsp.*;
import javax.servlet.jsp.tagext.*;
import org.metawidget.jsp.*;
import org.metawidget.jsp.tagext.*;
import org.metawidget.layout.iface.*;

public class HtmlListLayout
	implements AdvancedLayout&lt;Tag, MetawidgetTag&gt; {
	
	public void onStartBuild( MetawidgetTag metawidgetTag ) {}

	public void startContainerLayout( Tag containerTag, MetawidgetTag metawidgetTag ) {
		try	{
			JspWriter writer = metawidgetTag.getPageContext().getOut();
			writer.write( "&lt;ul&gt;" );
		} catch ( Exception e ) {
			throw LayoutException.newException( e );
		}
	}

	public void layoutChild( Tag tag, String elementName, Map&lt;String, String&gt; attributes,
		Tag containerTag, MetawidgetTag metawidgetTag ) {
		try {
			JspWriter writer = metawidgetTag.getPageContext().getOut();
			writer.write( "&lt;li&gt;" );
			writer.write( JspUtils.writeTag( metawidgetTag.getPageContext(), tag, containerTag, null ) );
			writer.write( "&lt;/li&gt;" );
		} catch ( Exception e ) {
			throw LayoutException.newException( e );
		}
	}

	public void endContainerLayout( Tag containerTag, MetawidgetTag metawidgetTag ) {
		try {
			JspWriter writer = metawidgetTag.getPageContext().getOut();
			writer.write( "&lt;/ul&gt;" );
		} catch ( Exception e ) {
			throw LayoutException.newException( e );
		}
	}
	
	public void onEndBuild( MetawidgetTag metawidgetTag ) {}	
}</programlisting>
				
				<para>
					Like <classname>Inspector</classname>s, <classname>WidgetBuilder</classname>s and
					<classname>WidgetProcessor</classname>s, <classname>Layout</classname>s are required to be
					immutable. However they will generally need to use some internal state, such as tracking
					the current row in a table layout. This can be achieved in two ways:
				</para>
				
				<orderedlist>
					<listitem>
						<para>
							For state that will remain constant throughout the life of the <classname>Layout</classname>, such as
							a CSS class to put on a generated HTML table, use <classname>xxxLayoutConfig</classname> classes.
							For example: 
						</para>
						
						<programlisting language="java">public class HtmlTableLayoutConfig {
	private String mTableStyle;
	
	public HtmlTableLayoutConfig setTableStyle( String tableStyle )	{
		mTableStyle = tableStyle;
		return this;
	}

	public String getTableStyleClass() {
		return mTableStyleClass;
	}
	
	// ...must override equals and hashCode too...
}</programlisting>
						<para>
							These <classname>xxxLayoutConfig</classname> classes are then passed to the <classname>Layout</classname>
							at construction time, and stored internally:
						</para>
						
						<programlisting language="java">public class HtmlTableLayout {
	private String mTableStyle;
	
	public HtmlTableLayout() {
		this( new HtmlTableLayoutConfig() );
	}

	public HtmlTableLayout( HtmlTableLayoutConfig config ) {
		mTableStyle = config.getTableStyle();
	}
}</programlisting>

						<para>
							This mechanism can then be controlled either programmatically:
						</para>
						
						<programlisting language="java">metawidget.setLayout( new HtmlTableLayout( new HtmlTableLayoutConfig().setTableStyleClass("foo")));</programlisting>
						
						<para>
							Or through metawidget.xml:
						</para>
						
						<programlisting language="xml">&lt;htmlTableLayout xmlns="java:org.metawidget.jsp.tagext.html.layout" config="HtmlTableLayoutConfig"&gt;
		&lt;tableStyleClass&gt;
			&lt;string&gt;foo&lt;/string&gt;
		&lt;/tableStyleClass&gt;
	&lt;/htmlTableLayout&gt;</programlisting>

						<important>
							<title>Config classes must override equals and hashCode</title>
							If you want your configurable <classname>Layout</classname> to be cacheable and reusable by
							<classname>ConfigReader</classname> and <filename>metawidget.xml</filename>,  the <classname>xxxLayoutConfig</classname>
							class <emphasis>must</emphasis> override <function>equals</function> and <function>hashCode</function>.
						</important>

						<tip>
							<title>Generate an XML Schema</title>
							If you intend your <classname>Layout</classname> to be configurable via <filename>metawidget.xml</filename>, consider
							defining an XML Schema for it. This is optional, but allows users to validate their use of your <classname>Layout</classname> in their
							<filename>metawidget.xml</filename> at development time. There is an Ant task,
							<classname>org.metawidget.config.XmlSchemaGeneratorTask</classname>, provided in the source distribution that can help with this
							by auto-generating the schema. All the existing Metawidget schemas are generated using this Ant task.
						</tip>				
				
					</listitem>
					<listitem>
						<para>
							For state that will change during laying out, such as tracking the current row, store it in the
							Metawidget that is passed in to <function>startContainerLayout</function>, <function>layoutChild</function>
							and <function>endContainerLayout</function>. You may want to further wrap the state in a small helper
							class, for example:
						</para>
						
						<programlisting language="java">public void layoutChild( JComponent component, String elementName, Map&lt;String, String&gt; attributes,
											JComponent container, SwingMetawidget metawidget ) {
	getState( container ).currentRow++;
}

private State getState( SwingMetawidget metawidget ) {
	State state = (State) container.getClientProperty( getClass() );

	if ( state == null ) {
		state = new State();
		metawidget.putClientProperty( getClass(), state );
	}

	return state;
}

static class State {
	int currentRow;
}</programlisting>

					</listitem>
				</orderedlist>
				
			</section>
			
		</section>

		<section id="section-architecture-xml">
			<title>metawidget.xml and ConfigReader</title>

			<para>
				<filename>metawidget.xml</filename> is an alternate (and optional) way to configure Metawidget.
				It allows you to configure a Metawidget without writing any Java code. This
				can be useful in environments with intermediate languages that shield the developer from the
				raw Java, such as JSPs or Facelets. It can also be useful as a single place for configuring multiple Metawidgets,
				such as across multiple dialogs of a desktop application.
			</para>
			
			<para>
				The <filename>metawidget.xml</filename> format, as parsed by <classname>org.metawidget.config.ConfigReader</classname>,
				is specialised for configuring Metawidget instances. The following sections explore some of the features of the
				XML format and <classname>ConfigReader</classname>.
			</para>
			
			<section id="section-architecture-xml-construct-objects">
				<title>Constructing New Objects</title>
				
				<para>
					<classname>ConfigReader</classname> can construct new instances of objects. The XML element name is the Java class name
					and the XML namespace is the Java package. The following example constructs an <classname>org.metawidget.swing.SwingMetawidget</classname>. 
				</para>

				<programlisting language="xml">&lt;metawidget xmlns="http://metawidget.org"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://metawidget.org http://metawidget.org/xsd/metawidget-1.0.xsd"&gt;

	&lt;swingMetawidget xmlns="java:org.metawidget.swing"/&gt;
	
&lt;/metawidget&gt;			
</programlisting>

				<para>
					Using the XML namespace to denote the Java package allows the (optional) plugging in of XML Schema validation on
					a per-package basis. For example:
				</para>

				<programlisting language="xml">&lt;swingMetawidget xmlns="java:org.metawidget.swing"
xsi:schemaLocation="java:org.metawidget.swing http://metawidget.org/xsd/org.metawidget.swing-1.0.xsd"/&gt;</programlisting>

			</section>

			<section id="section-architecture-xml-call-setters">
				<title>Calling Setter Methods</title>
				
				<para>
					Within an object, <classname>ConfigReader</classname> can call <function>setXXX</function> methods. The following example
					calls the <function>setOpaque</function> method of <classname>SwingMetawidget</classname>:
				</para>

				<programlisting language="xml">&lt;metawidget xmlns="http://metawidget.org"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://metawidget.org http://metawidget.org/xsd/metawidget-1.0.xsd"&gt;

	&lt;swingMetawidget xmlns="java:org.metawidget.swing"&gt;
		&lt;opaque&gt;
			&lt;boolean&gt;true&lt;/boolean&gt;
		&lt;/opaque&gt;
	&lt;/swingMetawidget&gt;
	
&lt;/metawidget&gt;</programlisting>

				<para>
					Multi-parameter methods are also supported. The following example calls the <function>setParameter</function> method
					of <classname>HtmlMetawidget</classname> (it takes two arguments):
				</para>

				<programlisting language="xml">&lt;metawidget xmlns="http://metawidget.org"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://metawidget.org http://metawidget.org/xsd/metawidget-1.0.xsd"&gt;

	&lt;htmlMetawidget xmlns="java:org.metawidget.faces.component.html"&gt;
		&lt;parameter&gt;
			&lt;string&gt;numberOfColumns&lt;/string&gt;
			&lt;int&gt;2&lt;/int&gt;
		&lt;/parameter&gt;		
	&lt;/htmlMetawidget&gt;
	
&lt;/metawidget&gt;</programlisting>

			</section>
			
			<section id="section-architecture-xml-construct-primitives">
				<title>Constructing Primitive Types</title>
				
				<para>
					As alluded to in the previous section, when calling <function>setXXX</function> methods the XML format can
					specify simple types. The previous example used <classname>boolean</classname>, <classname>string</classname>
					and <classname>int</classname>. Also supported are: 
				</para>

				<informaltable>
					<colgroup>
						<col width="40%"/>
						<col width="60%"/>
					</colgroup>
					<thead>
						<tr>
							<th align="left">Element name</th>
							<th align="left">Java type</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td><parameter>&lt;array&gt;</parameter></td>
							<td>
								constructs a Java array. The array's component type (ie. <classname>String[]</classname>, <classname>int[]</classname> etc)
								is based on the signature of the method being invoked (ie. <function>setInspectors( Inspector... )</function>)
							</td>
						</tr>					
						<tr>
							<td><parameter>&lt;boolean&gt;</parameter></td>
							<td>Java <classname>boolean</classname> primitive</td>
						</tr>
						<tr>
							<td><parameter>&lt;bundle&gt;</parameter></td>
							<td>
								uses <classname>ResourceBundle.getBundle</classname> to construct a <classname>ResourceBundle</classname>
							</td>
						</tr>
						<tr>
							<td><parameter>&lt;class&gt;</parameter></td>
							<td>Java <classname>Class</classname></td>
						</tr>
						<tr>
							<td><parameter>&lt;constant&gt;</parameter></td>
							<td>
								Static field. This can either be fully qualified (eg. <parameter>javax.swing.SwingConstants.LEFT</parameter>) or
								just the field name, in which case the field must be defined by the class of the parent XML node
							</td>
						</tr>
						<tr>
							<td><parameter>&lt;enum&gt;</parameter></td>
							<td>
								Java <classname>enum</classname> primitive. The enum type is based on the signature of the
								method being invoked
							</td>
						</tr>
						<tr>
							<td><parameter>&lt;file&gt;</parameter></td>
							<td>
								uses <classname>FileInputStream</classname> to open a file as an <classname>InputStream</classname>
							</td>
						</tr>
						<tr>
							<td><parameter>&lt;int&gt;</parameter></td>
							<td>Java <classname>int</classname> primitive</td>
						</tr>
						<tr>
							<td><parameter>&lt;list&gt;</parameter></td>
							<td>constructs a <classname>java.util.ArrayList</classname></td>
						</tr>
						<tr>
							<td><parameter>&lt;null&gt;</parameter></td>
							<td>Java <classname>null</classname> value</td>
						</tr>
						<tr>
							<td><parameter>&lt;pattern&gt;</parameter></td>
							<td>Java <classname>Pattern</classname></td>
						</tr>
						<tr>
							<td><parameter>&lt;resource&gt;</parameter></td>
							<td>uses <classname>Class.getResourceAsStream</classname> to open a resource as an <classname>InputStream</classname></td>
						</tr>
						<tr>
							<td><parameter>&lt;set&gt;</parameter></td>
							<td>constructs a <classname>java.util.HashSet</classname></td>
						</tr>
						<tr>
							<td><parameter>&lt;string&gt;</parameter></td>
							<td>constructs a <classname>java.lang.String</classname></td>
						</tr>
						<tr>
							<td><parameter>&lt;url&gt;</parameter></td>
							<td>uses <classname>URL.openStream</classname> to open a URL as an <classname>InputStream</classname></td>
						</tr>
					</tbody>
				</informaltable>
			</section>

			<section id="section-architecture-xml-resolving-resources">
				<title>Resolving Resources</title>
				
				<para>
					Some environments store their resources in specialized locations that are inaccessible
					by normal means (ie. <classname>ClassLoader.getResource</classname>). For example, Web
					environments use a <filename>WEB-INF</filename> folder that must be accessed through
					<classname>ServletContext.getResource</classname>. Simiarly, Android environments must resolve
					resources using <classname>Context.getResources</classname>. 
				</para>
				
				<para>
					<classname>ConfigReader</classname> and its specialized subclasses, such as
					<classname>ServletConfigReader</classname> and <classname>AndroidConfigReader</classname>
					understand this distinction and provide resource resolving capability to all the
					objects they create. Specifically, <classname>ConfigReader</classname> implements
					<classname>ResourceResolver</classname> and passes itself to any <classname>xxxConfig</classname>
					classes that implement <classname>NeedsResourceResolver</classname>.					
				</para>
				
			</section>

			<section id="section-architecture-xml-understand-immutability">
				<title>Understanding Immutability</title>
				
				<para>
					Metawidget dictates all <classname>Inspector</classname>s, <classname>WidgetBuilder</classname>s, <classname>WidgetProcessor</classname>s
					and <classname>Layout</classname>s be immutable. This is an important design decision as
					it means a single instance can be reused across an entire application. Immutabilty
					is enforced by not having any <function>setXXX</function> methods on the objects themselves.
					Rather, the <function>setXXX</function> methods are called on <classname>Config</classname> objects, which are then passed
					to the object's constructor. Once constructed, the object cannot be changed.
				</para>
				
				<para>
					<classname>ConfigReader</classname> understands this distinction by way of a <parameter>config</parameter> attribute. The following example
					configures an immutable <classname>Inspector</classname>. The <function>setInspectors</function> method is called
					on <classname>org.metawidget.inspector.composite.CompositeInspectorConfig</classname>
					and then passed to <classname>CompositeInspector</classname>:
				</para>

				<programlisting language="xml">&lt;compositeInspector xmlns="java:org.metawidget.inspector.composite" config="CompositeInspectorConfig"&gt;
	&lt;inspectors&gt;
		&lt;array&gt;
			&lt;propertyTypeInspector xmlns="java:org.metawidget.inspector.propertytype"/&gt;
			&lt;metawidgetAnnotationInspector xmlns="java:org.metawidget.inspector.annotation" /&gt;
		&lt;/array&gt;
	&lt;/inspectors&gt;
&lt;/compositeInspector&gt;</programlisting>

				<para>
					Having constructed an immutable object, <classname>ConfigReader</classname> will cache the instance and reuse it. The
					<parameter>config</parameter> attribute defaults to using the same package as the <parameter>xmlns</parameter> (ie.
					<classname>org.metawidget.inspector.composite</classname> in the example above). This can be overridden if a fully
					qualified classname is provided.
				</para>

				<important>
					<title>Config classes must override equals and hashCode</title>
					In order to reliably cache and reuse an immutable object that uses a <parameter>config</parameter> attribute, the
					<classname>xxxConfig</classname> class <emphasis>must</emphasis> override <function>equals</function>
					and <function>hashCode</function>. This is important to bear in mind when implementing your own custom objects.
				</important>				
								
			</section>
			
		</section>

	</chapter>

	<chapter id="chapter-metawidgets">
		<title>Metawidgets</title>
		
		<para>
			Metawidget ships with native widgets for different UI frameworks. Whilst all Metawidget widgets are
			broadly similar, they are tailored to take advantage of their native environment. This chapter examines
			each Metawidget widget in detail.
		</para>

		<section id="section-metawidgets-desktop">
			<title>Desktop Metawidgets</title>

			<section id="section-metawidgets-desktop-swing">
				<title>SwingMetawidget</title>
	
				<para>
					<classname>SwingMetawidget</classname> is a Swing component. For an introduction
					to <classname>SwingMetawidget</classname>, see <xref linkend="section-introduction-part1"/>
					and <xref linkend="section-introduction-part2-desktop"/>.
				</para>
	
				<section id="section-metawidgets-desktop-swing-installation">
					<title>Installation</title>

					<para>
						There are two steps to installing <classname>SwingMetawidget</classname> within a Swing application:
					</para>
					
					<orderedlist>
						<listitem>
							<para>
								Add <filename>metawidget.jar</filename> to your <parameter>CLASSPATH</parameter>.
							</para>
						</listitem>
						<listitem>
							<para>
								You can (optionally) configure the Metawidget, either programmatically (as detailed in <xref linkend="section-introduction-part1-inspectors"/>)
								or using a <filename>metawidget.xml</filename> file (as detailed in <xref linkend="section-introduction-part1-metawidget-config"/>).
							</para>
						</listitem>
					</orderedlist>
					
				</section>
				
				<section id="section-metawidgets-desktop-swing-look">
					<title>Customizing Look and Feel</title>
					
					<para>
	 					Since inception, Swing has had built-in, and extensive, Look and Feel support. Metawidget
						does not overlap this. For layouts, Swing supports a multitude of <classname>LayoutManagers</classname>.
						Metawidget leverages these, and automates them to construct UIs automatically.
					</para>
					
				</section>
				
			</section>
		</section>
		
		<section id="section-metawidgets-web">
			<title>Web Metawidgets</title>
		
			<section id="section-metawidgets-web-gwt">
				<title>GwtMetawidget</title>
	
				<para>
					<classname>GwtMetawidget</classname> is a client-side, JavaScript widget for GWT. Despite the limitations of the
					JavaScript environment, <classname>GwtMetawidget</classname> supports reflection, annotations, pluggable layouts and data binding. For an introduction
					to <classname>GwtMetawidget</classname>, see <xref linkend="section-introduction-part2-web"/> and 
					<xref linkend="section-introduction-part3-gwt-hosted"/>.
				</para>
				
				<section id="section-metawidgets-web-gwt-installation">
					<title>Installation</title>
					
					<para>
						There are five steps to installing Metawidget within a GWT application:
					</para>
					
					<orderedlist>
						<listitem>
							<para>
								Update the application's <filename>.gwt.xml</filename> module to include Metawidet:
							</para>
							<programlisting language="xml">&lt;module&gt;								
	&lt;inherits name="org.metawidget.GwtMetawidget" /&gt;
	...
&lt;/module&gt;</programlisting>
						</listitem>
						<listitem>
							<para>
								Include both <filename>metawidget.jar</filename> <emphasis>and</emphasis> <filename>examples\gwt\metawidget-gwt.jar</filename>
								in the <parameter>CLASSPATH</parameter> during the GWTCompiler phase. This provides the <classname>GwtMetawidget</classname> component.
							</para>
						</listitem>
						<listitem>
							<para>
								Add <filename>metawidget.jar</filename> into <filename>WEB-INF/lib</filename>. This provides the <classname>GwtRemoteInspectorImpl</classname> servlet.
							</para>
						</listitem>
						<listitem>						
							<para>
								Update the application's <filename>web.xml</filename> to include <classname>GwtRemoteInspectorImpl</classname>:
							</para>							
							<programlisting language="xml">&lt;web-app&gt;
	...
	&lt;servlet&gt;
		&lt;servlet-name&gt;metawidget-inspector&lt;/servlet-name&gt;
		&lt;servlet-class&gt;org.metawidget.inspector.gwt.remote.server.GwtRemoteInspectorImpl&lt;/servlet-class&gt;
	&lt;/servlet&gt;

	&lt;servlet-mapping&gt;
		&lt;servlet-name&gt;metawidget-inspector&lt;/servlet-name&gt;
		&lt;url-pattern&gt;/metawidget-inspector&lt;/url-pattern&gt;
	&lt;/servlet-mapping&gt;
&lt;/web-app&gt;</programlisting>
						</listitem>
						<listitem>
							<para>
								You can (optionally) configure the default <classname>Inspector</classname>. To do this, add a
								<filename>metawidget.xml</filename> file into <filename>WEB-INF</filename>, and an
								<parameter>init-param</parameter> to your <filename>web.xml</filename>:								
							</para>
							
							<programlisting language="xml">&lt;init-param&gt;
	&lt;param-name>config&lt;/param-name&gt;
	&lt;param-value>metawidget.xml&lt;/param-value&gt;
&lt;/init-param&gt;</programlisting>
							
						</listitem>
					</orderedlist>
					
					<para>
						A working example of all five steps can be found in <filename>addressbook-gwt.war</filename> included in the binary
						distribution. You may also find the <filename>example-gwt-addressbook</filename> Ant task in the source
						distribution's <filename>build.xml</filename> useful.
					</para>
					
				</section>
				
				<section id="section-metawidgets-web-gwt-reflection">
					<title>Reflection and Annotations</title>
					
					<para>
						<classname>GwtMetawidget</classname> leverages Metawidget's separate <classname>Inspector</classname>/renderer
						architecture and AJAX to perform server-side inspection as in <xref linkend="section-metawidgets-web-gwt-inspection"/>. This
						allows <classname>GwtMetawidget</classname> to reflect properties and inspect annotations of business
						objects, even though JavaScript	supports neither.
					</para>
					
					<!--
						http://www.websequencediagrams.com:
						
						User->Browser: hits page
						Browser->Browser: creates\nbusiness\nobject
						Browser->GwtMetawidget: creates metawidget
						Browser->GwtMetawidget: sets business object
						GwtMetawidget->Server: sends business object
						Server->Server: runs inspector
						Server->GwtMetawidget: returns inspection results
						GwtMetawidget->Browser: renders HTML widgets
						Browser->User: sees page 
					 -->
					 
					<figure id="section-metawidgets-web-gwt-inspection">
						<title>GwtMetawidget uses AJAX to perform server-side inspection</title>
						<screenshot>
							<graphic fileref="images/activitydiagrams/gwt-inspection.png" width="120mm"/>
						</screenshot>							
					</figure>
					
					<para>
						The process is:
					</para>

					<orderedlist>
						<listitem>
							<para>
								instantiate the business object on the client-side as normal (ie. as JavaScript)
							</para>
						</listitem>
						<listitem>
							<para>
								give the business object to <classname>GwtMetawidget</classname> (a client-side, JavaScript GWT Widget)
							</para>
						</listitem>
						<listitem>
							<para>
								<classname>GwtMetawidget</classname> uses AJAX to pass the business object to the server
							</para>
						</listitem>
						<listitem>
							<para>
								the server, using Java, runs all the <classname>Inspector</classname>s (including reflection and annotations)
							</para>
						</listitem>
						<listitem>
							<para>
								the server returns the inspection results as an XML document
							</para>
						</listitem>
						<listitem>
							<para>
								<classname>GwtMetawidget</classname> uses JavaScript to render the HTML widgets
							</para>
						</listitem>
					</orderedlist>
					
					<para>
						Note that steps 3 and 5 (the AJAX call to and from the server) are the most costly in terms of performance. Techniques
						to improve GWT performance are discussed in <xref linkend="section-performance-rebind"/>. 
					</para>

				</section>
				
				<section id="section-metawidgets-web-gwt-client-side-inspection">
					<title>Client-Side Inspection</title>
					
					<para>
						As noted in <xref linkend="section-metawidgets-web-gwt-reflection"/> by default <classname>GwtMetawidget</classname> uses
						server-side inspectors. This allows the full power of Java-based reflection but carries the performance cost of an AJAX call.
						This cost can be mitigated by using rebinding (see <xref linkend="section-performance-rebind"/>), but there is
						another way: inspection can be performed <emphasis>client-side</emphasis>, with no AJAX calls.
					</para>
					
					<para>
						Setting up a client-side <classname>Inspector</classname> is very easy. The default <classname>GwtMetawidget</classname>
						<classname>Inspector</classname> is <classname>GwtRemoteInspectorProxy</classname>, which is itself a client-side
						<classname>Inspector</classname> (one that makes a remote call to <classname>GwtRemoteInspectorImpl</classname>). To
						replace this default, simply implement your own <classname>Inspector</classname>:
					</para>
					
					<programlisting language="java">public class MyClientSideInspector
	implements Inspector {
	public String inspect( Object toInspect, String type, String... names ) {
		return ...some XML string...
	}
}</programlisting>					

					<para>
						Make sure this <classname>Inspector</classname> is located under the <filename>client</filename> folder of your GWT application
						so that it is compiled by the GWTCompiler into JavaScript. Use this <classname>Inspector</classname> by doing...
					</para>

					<programlisting language="java">myGWTMetawidget.setInspector( new MyClientSideInspector() )</programlisting>
					
					<para>
						...which overrides the default <classname>GwtRemoteInspectorProxy</classname>. For an example of this technique
						see <xref linkend="section-introduction-part3-gwt-clientside"/>.
					</para>
					
				</section>
				
			</section>

			<section id="section-metawidgets-web-jsp">
				<title>HtmlMetawidgetTag (JSP)</title>
				
				<section id="section-metawidgets-web-hidden">
					<title>Hidden Fields</title>
					
					<para>
						Many Web applications store their data at the <classname>HttpServletRequest</classname> level, not at the
						<classname>HttpSession</classname> level. Using session-level state (or, ideally, a UI framework that supports some
						kind of 'conversation'-level state) is safer than passing variables to and from the client in hidden HTML fields. However, Web
						Metawidgets support that approach for those that need it through <function>setCreateHiddenFields( true )</function>.
					</para>
				</section>

			</section>
			
			<section id="section-metawidgets-web-faces">
				<title>UIMetawidget (JSF)</title>
	
				<para>
					<classname>UIMetawidget</classname> is a Java Server Faces component. For an introduction
					to <classname>UIMetawidget</classname>, see <xref linkend="section-introduction-part2-web"/> 
					and <xref linkend="section-introduction-part3-seam"/>. 
				</para>
	
				<section id="section-metawidgets-web-faces-installation">
					<title>Installation</title>

					<para>
						There are three steps to installing <classname>UIMetawidget</classname> within a JSF application:
					</para>
					
					<orderedlist>
						<listitem>
							<para>
								Add <filename>metawidget.jar</filename> into <filename>WEB-INF/lib</filename>.
							</para>
						</listitem>
						<listitem>
							<para>
								Add a tag library descriptor to the top of your JSP page...
							</para>
							<programlisting language="xml">&lt;%@ taglib uri="http://metawidget.org/faces" prefix="m" %&gt;
	...
	&lt;m:metawidget value="#{foo}"/&gt;
	...</programlisting>
							<para>
								...or Facelets page...
							</para>
							<programlisting language="xml">&lt;ui:composition xmlns="http://www.w3.org/1999/xhtml"
	...
	xmlns:m="http://metawidget.org/faces"&gt;
	...
	&lt;m:metawidget value="#{foo}"/&gt;
	...</programlisting>
						</listitem>
						<listitem>
							<para>
								You can (optionally) configure the Metawidget by adding a <filename>metawidget.xml</filename> file into <filename>WEB-INF</filename>.
							</para>
						</listitem>
					</orderedlist>
					
				</section>

				<section id="section-metawidgets-web-faces-look">
					<title>Customizing Look and Feel</title>
					
					<para>
						One of JSF's most important Look and Feel technologies is CSS.
						Metawidget supports several approaches to suit different needs.
					</para>
					
					<para>
						By convention, JSF's HTML widgets (<classname>HtmlInputText</classname>, <classname>HtmlSelectBooleanCheckbox</classname>, etc) define
						<parameter>style</parameter> and <parameter>styleClass</parameter> attributes for applying CSS styles and classes to their output.
						<classname>HtmlMetawidget</classname> follows this convention. When expanding to a single widget (such as an
						<classname>HtmlInputText</classname>) the CSS styles are applied to it. When expanding to multiple widgets,
						<emphasis>all</emphasis> widgets have the same CSS styles applied to them.
					</para>
					
					<para>
						Another important JSF Look and Feel technology is Renderers. Whilst
						often Renderers are discussed in the context of rendering the same widget to different
						platforms (eg. HTML or WML), they can equally be used to render the same widget to the same
						platform but in different layouts.
					</para>
					
					<para>
						<classname>HtmlTableLayoutRenderer</classname> is the default <classname>LayoutRenderer</classname>. It further
						defines parameters such as <parameter>tableStyle</parameter>,
						<parameter>labelStyle</parameter> and <parameter>columnStyleClasses</parameter> parameters (see the
						JavaDoc for a complete list). The latter is a comma separated list of CSS style classes to be applied to table columns. The first style
						class is the label column, the second the widget column, and the third the 'required' column.
						Further style classes may be used for multi-column layouts. You can	get quite far using, for example:
					</para>
	
					<programlisting language="css">.table-component-column input { width: 100%; }</programlisting>
					
					<para>
						..this approach has the advantage of automatically applying to every widget,
						so overridden widgets do not have to explicitly set styleClass information.
						However, not all Web browsers support fine-grained CSS selectors such as...
					</para>
					
					<programlisting language="css">.table-component-column input[type="button"] { width: auto; }</programlisting>
					
					<para>
						...in which case it may be better to switch to using <parameter>styleClass</parameter> on <classname>HtmlMetawidget</classname> itself.
					</para>
					
					<para>
						Other supplied <classname>LayoutRenderer</classname>s include <parameter>div</parameter> and <parameter>simple</parameter> (see
						the JavaDoc, and the <filename>META-INF/faces-config.xml</filename> in <filename>metawidget.jar</filename> for a
						complete list).
					</para>
					
				</section>
				
			</section>
			
			<section id="section-metawidgets-web-spring">
				<title>SpringMetawidgetTag</title>
	
				<para>
					<classname>SpringMetawidgetTag</classname> is a Spring taglib. For an introduction
					to <classname>SpringMetawidgetTag</classname>, see <xref linkend="section-introduction-part2-web"/>.
				</para>

				<section id="section-metawidgets-web-spring-installation">
					<title>Installation</title>

					<para>
						There are three steps to installing <classname>SpringMetawidgetTag</classname> within a Spring application:
					</para>
					
					<orderedlist>
						<listitem>
							<para>
								Add <filename>metawidget.jar</filename> into <filename>WEB-INF/lib</filename>.
							</para>
						</listitem>
						<listitem>
							<para>
								Add a tag library descriptor to the top of your JSP page:
							</para>
							<programlisting language="xml">&lt;%@ taglib uri="http://metawidget.org/spring" prefix="m" %&gt;
	...
	&lt;m:metawidget value="#{foo}"/&gt;
	...</programlisting>
						</listitem>
						<listitem>
							<para>
								You can (optionally) configure the Metawidget by adding a <filename>metawidget.xml</filename> file into <filename>WEB-INF</filename>.
							</para>
						</listitem>
					</orderedlist>
				</section>

				<section id="section-metawidgets-web-spring-look">
					<title>Customizing Look and Feel</title>
					
					<para>
						JSP-based technologies do not distinguish between what a widget is versus how it is rendered.
						Instead, <classname>SpringMetawidgetTag</classname> mimics this by providing loosely coupled <classname>Layout</classname> classes.
						Each layout can further be configured by using specific <parameter>param</parameter> tags.
					</para>
					
				</section>
				
				<section id="section-metawidgets-web-spring-override">
					<title>Overriding Widget Creation</title>				

					<para>
						With regard to overriding widget creation, JSP-based technologies such as Spring lack some component-based features.
						Specifically, whilst it is possible for JSP	tags to reference their <emphasis>parent</emphasis> (using <function>TagSupport.findAncestorWithClass</function>),
						they have no way to enumerate their <emphasis>children</emphasis>. Therefore, it is not possible to
						directly support arbitrary child tags within <classname>SpringMetawidgetTag</classname>. As a next best thing, Metawidget includes
						<classname>StubTag</classname> for wrapping arbitrary tags. It also supports wrapping arbitrary HTML.
					</para>
					
				</section>

			</section>

			<section id="section-metawidgets-web-struts">
				<title>StrutsMetawidgetTag</title>
	
				<para>
					<classname>StrutsMetawidgetTag</classname> is a Struts taglib. For an introduction
					to <classname>StrutsMetawidgetTag</classname>, see <xref linkend="section-introduction-part2-web"/>.
				</para>

				<section id="section-metawidgets-web-struts-installation">
					<title>Installation</title>

					<para>
						There are three steps to installing <classname>StrutsMetawidgetTag</classname> within a Struts application:
					</para>
					
					<orderedlist>
						<listitem>
							<para>
								Add <filename>metawidget.jar</filename> into <filename>WEB-INF/lib</filename>.
							</para>
						</listitem>
						<listitem>
							<para>
								Add a tag library descriptor to the top of your JSP page:
							</para>
							<programlisting language="xml">&lt;%@ taglib uri="http://metawidget.org/struts" prefix="m" %&gt;
	...
	&lt;m:metawidget value="#{foo}"/&gt;
	...</programlisting>
						</listitem>
						<listitem>
							<para>
								You can (optionally) configure the Metawidget by adding a <filename>metawidget.xml</filename> file
								into <filename>WEB-INF</filename>.
							</para>
						</listitem>
					</orderedlist>
				</section>

				<section id="section-metawidgets-web-struts-look">
					<title>Customizing Look and Feel</title>
					
					<para>
						JSP-based technologies do not distinguish between what a widget is versus how it is rendered.
						Instead, <classname>StrutsMetawidgetTag</classname> mimics this by providing loosely coupled <classname>Layout</classname> classes.
						Each layout can further be configured by using specific <parameter>param</parameter> tags.
					</para>
					
				</section>
				
				<section id="section-metawidgets-web-struts-override">
					<title>Overriding Widget Creation</title>				

					<para>
						With regard to overriding widget creation, JSP-based technologies such as Struts lack some component-based features.
						Specifically, whilst it is possible for JSP	tags to reference their <emphasis>parent</emphasis> (using <function>TagSupport.findAncestorWithClass</function>),
						they have no way to enumerate their <emphasis>children</emphasis>. Therefore, it is not possible to
						directly support arbitrary child tags within <classname>SpringMetawidgetTag</classname>. As a next best thing, Metawidget includes
						<classname>StubTag</classname> for wrapping arbitrary tags. It also supports wrapping arbitrary HTML.
					</para>
					
				</section>
				
				<section id="section-metawidgets-web-struts-troubleshooting">
					<title>Troubleshooting</title>				
	
					<section id="section-metawidgets-web-struts-troubleshooting-1">
						<title>I get "Cannot find bean org.apache.struts.taglib.html.BEAN in any scope"</title>
						
						<para>
							<classname>StrutsMetawidgetTag</classname> creates native Struts widgets, such as <parameter>&lt;html:text&gt;</parameter>, but does
							not create the surrounding Struts form. Make sure your Metawidget tag is enclosed in
							a <parameter>&lt;html:form&gt;</parameter> tag and the Struts HTML taglib is included at the top of the page.
						</para>
					</section>

					<section id="section-metawidgets-web-struts-troubleshooting-2">
						<title>I see "MultipartRequestHandler", "ServletWrapper" and other weird names</title>
						
						<para>
							If you use <classname>PropertyTypeInspector</classname> to inspect your <classname>ActionForm</classname>-based
							classes, by default it will discover properties from the
							<classname>org.apache.struts.action.ActionForm</classname> base class, such as <function>getMultipartRequestHandler</function>.
							To prevent this, configure <filename>metawidget.xml</filename>: 
						</para>
						
						<programlisting language="xml">&lt;propertyTypeInspector xmlns="java:org.metawidget.inspector.propertytype"
	config="org.metawidget.inspector.impl.BaseObjectInspectorConfig"&gt;
	&lt;propertyStyle&gt;
		&lt;javaBeanPropertyStyle xmlns="java:org.metawidget.inspector.impl.propertystyle.javabean"
			config="org.metawidget.inspector.impl.propertystyle.BasePropertyStyleConfig"&gt;
			&lt;excludeBaseType&gt;
				&lt;pattern&gt;^(java|javax|org\.apache\.struts)\..*$&lt;/pattern&gt;
			&lt;/excludeBaseType&gt;
		&lt;/javaBeanPropertyStyle&gt;
	&lt;/propertyStyle&gt;
&lt;/propertyTypeInspector&gt;</programlisting>

					</section>
				</section>
			</section>
			
		</section>

		<section id="section-metawidgets-mobile">
			<title>Mobile Metawidgets</title>

			<section id="section-metawidgets-mobile-android">
				<title>AndroidMetawidget</title>
	
				<para>
					<classname>AndroidMetawidget</classname> is an Android widget. For an introduction
					to <classname>AndroidMetawidget</classname>, see <xref linkend="section-introduction-part2-mobile"/>.
				</para>

				<section id="section-metawidgets-mobile-android-installation">
					<title>Installation</title>

					<para>
						There are two steps to installing <classname>AndroidMetawidget</classname> within an Android application:
					</para>
					
					<orderedlist>
						<listitem>
							<para>
								Add <filename>metawidget.jar</filename> to your <parameter>CLASSPATH</parameter> (ie. under
								your project's <parameter>Libraries</parameter> tab in Eclipse)
							</para>
						</listitem>
						<listitem>
							<para>
								You can (optionally) configure the Metawidget, either programmatically (as detailed in <xref linkend="section-introduction-part1-inspectors"/>)
								or using a <filename>metawidget.xml</filename> file (as detailed in <xref linkend="section-introduction-part1-metawidget-config"/>)
								in your <filename>res/raw</filename> folder.
							</para>
						</listitem>
					</orderedlist>
					
					<tip>
						<title>Note</title>
						Given the resource constraints of a mobile device, consider creating a custom <filename>metawidget.jar</filename> that
						only includes the classes you need (as detailed in <xref linkend="section-performance-jar"/>).
					</tip>
					
				</section>

				<section id="section-metawidgets-mobile-android-i18n">
					<title>Internationalization</title>
					
					<para>
						<classname>AndroidMetawidget</classname> supports localization through the <function>setBundle</function> method. This
						method takes your <classname>R.string</classname> class, which is generated by Android from your
						<filename>res/values/strings.xml</filename> file. For example, if your <filename>strings.xml</filename> file was:
					</para>
					
					<programlisting language="xml">&lt;resources&gt;
	&lt;string name="dob"&gt;Date of Birth&lt;string&gt;
&lt;/resources&gt;</programlisting>

					<para>
						And your business object had a property:
					</para>
					
					<programlisting language="java">class Person {
	...
	public Date getDob() {
		return mDob;
	}
}</programlisting>

					<para>
						Then you can set Metawidget to use your <classname>R.string</classname> class either programmatically or using
						<filename>metawidget.xml</filename>:
					</para>
	
					<programlisting language="xml">&lt;androidMetawidget&gt;
	&lt;bundle&gt;
		&lt;class&gt;org.metawidget.example.android.addressbook.R$string&lt;/class&gt;
	&lt;/bundle&gt;
&lt;/androidMetawidget&gt;</programlisting>
				
					<para>
						And at runtime Metawidget will translate the <function>Person.getDob</function> method into a property called
						<parameter>dob</parameter>, resolve the integer <classname>R.string.dob</classname> and use that to look up
						the localized text in <filename>strings.xml</filename>. For different locales, put the <filename>strings.xml</filename>
						file in adjacent <filename>res/values-xx</filename> folders - for example <filename>res/values-en</filename>.  
					</para>					
				</section>
				
			</section>
			
		</section>

	</chapter>

	<chapter id="chapter-inspectors">
		<title>Inspectors</title>
		
		<para>
			This chapter covers each <classname>Inspector</classname> in detail. For an explanation of how
			<classname>Inspector</classname>s
			fit into the overall architecture of Metawidget, see <xref linkend="chapter-architecture"/>
		</para>

		<para>
			Throughout this chapter when we say 'returns the following attributes' this is a shorthand way
			of saying 'returns the following Metawidget attributes (via a piece of XML conforming to <filename>inspection-result.xsd</filename>).
			These are passed to the Widget Builder to assist with choosing appropriate widgets'. Quite
			which widget will be chosen is covered in <xref linkend="chapter-widgetbuilders"/>: it could be
			a JSF <classname>HtmlInputTextarea</classname>, or a Swing <classname>JTextArea</classname>, or some
			other framework.
		</para>

		<section id="section-inspectors-property">
			<title>Property Inspectors</title>

			<section id="section-inspectors-base-object">
				<title>BaseObjectInspector</title>
				
				<para>
					<classname>BaseObjectInspector</classname> underlies many of the Inspectors that inspect objects (as opposed to, say,
					XML files). It provides easy-to-override methods such as...
				</para>
				
				<programlisting language="java">protected Map&lt;String, String&gt; inspectProperty( Property property )</programlisting>
				
				<para>
					...for inspecting properties, and...
				</para>

				<programlisting language="java">protected Map&lt;String, String&gt; inspectAction( Action action )</programlisting>
				
				<para>
					...for inspecting actions, and finally...
				</para>

				<programlisting language="java">protected Map&lt;String, String&gt; inspectTrait( Trait trait )</programlisting>
				
				<para>
					...for inspecting things that apply to both properties and actions (eg. <classname>@UiLabel</classname>). Quite what
					constitutes a 'property' or an 'action' is decoupled into pluggable <classname>PropertyStyle</classname>s
					and <classname>ActionStyle</classname>s.
				</para>
				
				<section id="section-inspectors-base-object-propertystyle">
					<title>PropertyStyle</title>
					
					<para>
						The <classname>PropertyStyle</classname> interface allows pluggable, fine-grained control over what is considered a 'property'.					
						Different environments may have different approaches to defining what constitutes a property. For
						example, JavaBean-properties are convention-based, whereas Groovy has explicit property support.
 						Equally, some environments may have framework-specific, base class properties that should be filtered out
 						and excluded from the list of 'real' business model properties.					
					</para>
					
					<para>
						The default property style is <classname>JavaBeanPropertyStyle</classname>. To change it within <filename>metawidget.xml</filename>:
					</para>
					
					<programlisting language="xml">&lt;propertyTypeInspector xmlns="java:org.metawidget.inspector.propertytype"
	config="org.metawidget.inspector.impl.BaseObjectInspectorConfig"&gt;
	&lt;propertyStyle&gt;
		&lt;groovyPropertyStyle xmlns="java:org.metawidget.inspector.impl.propertystyle.groovy"/&gt;
	&lt;/propertyStyle&gt;
&lt;/propertyTypeInspector&gt;</programlisting>
					
					<para>
						To change it programmatically:
					</para>
					
					<programlisting language="java">BaseObjectInspectorConfig config = new BaseObjectInspectorConfig();
config.setPropertyStyle( new GroovyPropertyStyle() );
metawidget.setInspector( new PropertyTypeInspector( config ) );</programlisting>

					<section id="section-inspectors-base-object-propertystyle-javabean">
						<title>JavaBeanPropertyStyle</title>
					
						<para>
							The <classname>JavaBeanPropertyStyle</classname> is the default property style used by all <classname>BaseObjectInspector</classname>
							subclasses (which includes all annotation inspectors).
						</para>
						
						<para>
							This property style recognizes JavaBean-convention <function>getXXX</function>, <function>setXXX</function> and <function>isXXX</function>
							methods, as well as public member variables. In addition, it maintains a cache of reflected classes for performance. 
						</para>
						
						<tip>
							<title>Note</title>
							When using getter methods with private members, make sure you annotate the getter <emphasis>not the private
							member</emphasis>. <classname>JavaBeanPropertyStyle</classname> cannot find annotations on private members, because
							the JavaBean specification does not define a way to determine which private members belong to which getters.
						</tip>
						
					</section>
					
					<section id="section-inspectors-base-object-propertystyle-groovy">
						<title>GroovyPropertyStyle</title>
					
						<para>
							The <classname>GroovyPropertyStyle</classname> recognizes GroovyBean properties.
						</para>
						
						<para>
							Groovy tries hard to make its GroovyBean properties compatible with JavaBean getters/setters, and indeed
							one can almost use the default <classname>JavaBeanPropertyStyle</classname> to read them. Unfortunately, GroovyBeans
							differ in that:
						</para>
						
						<itemizedlist>
							<listitem>
								<para>
									annotations defined on properties are only attached to the (generated) private member
									variable, not the (generated) getter/setter methods.
								</para>
							</listitem>
							<listitem>
								<para>
									GroovyBeans define an implicit <function>getMetaClass</function> method which, although matching
									the JavaBean signature, should not be treated as a business model property.
								</para>
							</listitem>
						</itemizedlist>
	
					</section>
					
					<section id="section-inspectors-base-object-propertystyle-javassist">
						<title>JavassistPropertyStyle</title>
							
						<para>
							The <classname>JavassistPropertyStyle</classname> extends
							<classname>JavaBeanPropertyStyle</classname> and makes use of Javassist for those environments
							that have it available.
						</para>
						
						<para>
							Javassist is used to inspect the debug line numbering information embedded in JVM bytecode
							to sort getters/setters according to their original declaration order in the source code. This saves business objects
							having to use <classname>@UiComesAfter</classname> (or an XML file, or some other method) to impose an ordering.
						</para>
						
						<para>
							However, a danger of this approach is that if the business objects are ever recompiled <emphasis>without</emphasis> debug
							line numbering information (eg. when moving from development to production) the UI fields will lose their
							ordering. Such a subtle bug may not be picked up, so as a safeguard <classname>JavassistPropertyStyle</classname>
							'fails hard' with an <classname>InspectorException</classname> if line numbers are not available.
						</para>
						
						<para>
							<classname>JavassistPropertyStyle</classname> uses the following sorting algorithm:
						</para>
						
						<itemizedlist>
							<listitem>
								<para>
									superclass public fields come first, sorted by name.
								</para>
							</listitem>
							<listitem>
								<para>
									superclass methods come next, sorted by getter line number (or, if no getter, setter line number).
								</para>
							</listitem>
							<listitem>
								<para>
									public fields come next, sorted by name.
								</para>
							</listitem>
							<listitem>
								<para>
									methods come last, sorted by getter line number (or, if no getter, setter line number).
								</para>
							</listitem>
						</itemizedlist>
						
						<para>
							Note this algorithm is less flexible than <classname>@UiComesAfter</classname>, which can
							interleave superclass and subclass properties. However, it is possible to use both
							<classname>@UiComesAfter</classname> and <classname>JavassistPropertyStyle</classname> together to get the best of
							both worlds.						
						</para>
							
					</section>
	
					<section id="section-inspectors-base-object-propertystyle-scala">
						<title>ScalaPropertyStyle</title>
					
						<para>
							The <classname>ScalaPropertyStyle</classname> recognizes Scala properties.
						</para>
						
						<para>
							Scala can make its properties compatible with JavaBean getters/setters, but only if you
							put special <classname>@BeanProperty</classname> annotations on them. Instead, <classname>ScalaPropertyStyle</classname>
							is designed to access Scala properties natively.
						</para>
						
					</section>
	
					<section id="section-inspectors-base-object-propertystyle-implementing-your-own">
						<title>Implementing Your Own PropertyStyle</title>
						<para>
							All property styles must implement the <classname>PropertyStyle</classname> interface. <classname>BasePropertyStyle</classname>
							assists in caching properties per class (looking them up is often expensive, involving reflection or similar
							techniques) and in excluding properties based on name, type or base class. Here
							is an example of a custom <classname>PropertyStyle</classname> that identifies fields based
							on <classname>ResourceBundle</classname> i18n entries. It extends the code from the tutorial
							(see <xref linkend="section-introduction-part1"/>).
						</para>
					
						<programlisting language="java">package com.myapp;
				
<symbol>import java.util.*;</symbol>
import javax.swing.*;
<symbol>import org.metawidget.inspector.iface.*;
import org.metawidget.inspector.impl.*;
import org.metawidget.inspector.impl.propertystyle.*;
import org.metawidget.inspector.impl.propertystyle.javabean.*;
import org.metawidget.inspector.propertytype.*;</symbol>
import org.metawidget.swing.*;
<symbol>import org.metawidget.util.*;</symbol>

public class Main {

	public static void main( String[] args ) {
		Person person = new Person();

		SwingMetawidget metawidget = new SwingMetawidget();
		<symbol>metawidget.setInspector( new PropertyTypeInspector( new BaseObjectInspectorConfig()
			.setPropertyStyle( new BundlePropertyStyle() ) ) );</symbol>
		metawidget.setToInspect( person );

		JFrame frame = new JFrame( "Metawidget Tutorial" );
		frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
		frame.getContentPane().add( metawidget );
		frame.setSize( 400, 250 );
		frame.setVisible( true );
	}
	
	<symbol>static class BundlePropertyStyle
		extends JavaBeanPropertyStyle {

		protected Map&lt;String, Property&gt; inspectProperties( Class&lt;?&gt; clazz ) {
			try {
				Map&lt;String, Property&gt; properties = CollectionUtils.newHashMap();
				ResourceBundle bundle = ResourceBundle.getBundle( "MyBundle" );

				for ( Enumeration&lt;String&gt; e = bundle.getKeys(); e.hasMoreElements(); ) {
					String key = e.nextElement();
					properties.put( key, new FieldProperty( key, clazz.getField( key ) ) );
				}

				return properties;
			}
			catch ( Exception ex ) {
				throw InspectorException.newException( ex );
			}
		}
	}</symbol>
}</programlisting>
					
						<para>
							For brevity, this example extends <classname>JavaBeanPropertyStyle</classname>. Normally, you would
							want to extend <classname>BasePropertyStyle</classname> and, as well as overriding <function>inspectProperties</function>
							to locate the properties, implement the <classname>Property</classname> interface with mechanisms
							for interrogating the property.
						</para>
						
						<tip>
							<title>Note</title>
							In this particular example, it may be useful to create a <classname>BundlePropertyStyleConfig</classname> class that implements
							<classname>NeedsResourceResolver</classname> (see <xref linkend="section-architecture-xml-resolving-resources"/>).
							Then it could use <classname>ResourceResolver.openResource</classname> to locate the bundle in case it
							was in a specialized location (such as <filename>WEB-INF/</filename>).
						</tip>
						
					</section>
				</section>
				
				<section id="section-inspectors-base-object-actionstyle">
					<title>ActionStyle</title>
					
					<para>
						The <classname>ActionStyle</classname> interface allows pluggable, fine-grained control over what is considered an 'action'.					
					</para>
					
					<para>
						Different environments may have different approaches to defining what constitutes an action. For
						example, the Swing AppFramework uses an <classname>@org.jdesktop.application.Action</classname> annotation.
					</para>
					
					<para>
						The default property style is <classname>MetawidgetActionStyle</classname>. To change it within <filename>metawidget.xml</filename>:
					</para>
					
				<programlisting language="xml">&lt;metawidgetAnnotationInspector config="org.metawidget.inspector.impl.BaseObjectInspectorConfig"&gt;
	&lt;actionStyle&gt;
		&lt;swingAppFrameworkActionStyle xmlns="java:org.metawidget.inspector.impl.actionstyle.swing"&gt;
	&lt;/actionStyle&gt;
&lt;/metawidgetAnnotationInspector&gt;</programlisting>
					
					<para>
						To change it programmatically:
					</para>
					
					<programlisting language="java">BaseObjectInspectorConfig config = new BaseObjectInspectorConfig();
config.setActionStyle( SwingAppFrameworkActionStyle.class );
metawidget.setInspector( new MetawidgetAnnotationInspector( config ) );</programlisting>

					<para>
						Note these action styles only apply to <classname>BaseObjectInspector</classname> and its subclasses. This covers
						most annotation-recognising inspectors (eg. <classname>JpaInspector</classname>, <classname>HibernateValidatorInspector</classname>)
						but <emphasis>not</emphasis> XML-based inspectors. For example, <classname>PageflowInspector</classname> recognizes actions in
						JBoss jBPM pageflow files without any concept of an 'action style'.
					</para>
					
					<section id="section-inspectors-base-object-metawidget">
						<title>MetawidgetActionStyle</title>
					
						<para>
							The default Metawidget action style recognizes any method annotated with <classname>@UiAction</classname>. Action methods
							must not accept any parameters in their signature. 
						</para>
						
					</section>
					
					<section id="section-inspectors-base-object-appframework">
						<title>SwingAppFrameworkActionStyle</title>
					
						<para>
							The <classname>SwingAppFrameworkActionStyle</classname> recognises Swing AppFramework's <classname>@Action</classname>
							annotation as denoting an action.
						</para>
	
					</section>
				</section>

			</section>
			
			<section id="section-inspectors-propertytype">
				<title>PropertyTypeInspector</title>
				
				<para>
					<classname>PropertyTypeInspector</classname> extends <classname>BaseObjectInspector</classname>, and so inherits its features.
					In addition, it returns the following attributes for the following business properties:
				</para>
				
				<informaltable>
					<colgroup>
						<col width="40%"/>
						<col width="60%"/>
					</colgroup>
					<thead>
						<tr>
							<th align="left">Metawidget Attribute</th>
							<th align="left">Property Type</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td><parameter>lookup</parameter></td>
							<td>
								lookup of 'true, false' if the type is Boolean
							</td>
						</tr>
						<tr>
							<td><parameter>lookup-labels</parameter></td>
							<td>
								lookup of 'Yes, No' if the type is Boolean. This will generally
								be localized by the Metawidget
							</td>
						</tr>
						<tr>
							<td><parameter>no-setter</parameter></td>
							<td>
								if the property has no <function>setXXX</function> method. Note <parameter>no-setter</parameter>
								is distinct from <parameter>read-only</parameter>, because it is common to
								have no setter for a complex type (eg. <function>Person.getAddress</function>) but
								this shouldn't make all its contents (eg. <function>Address.getStreet</function>) read-only.
							</td>
						</tr>
						<tr>
							<td><parameter>no-getter</parameter></td>
							<td>
								if the property has no <function>getXXX</function> method
							</td>
						</tr>
						<tr>
							<td><parameter>type</parameter></td>
							<td>declared type of the property</td>
						</tr>
						<tr>
							<td><parameter>actual-type</parameter></td>
							<td>
								if the actual type differs from the declared type (ie. it is a subclass)
							</td>
						</tr>
					</tbody>
				</informaltable>

			</section>
			
			<section id="section-inspectors-java5">
				<title>Java5Inspector</title>
				
				<para>
					<classname>Java5Inspector</classname> extends <classname>BaseObjectInspector</classname>, and so inherits its features.
					In addition, it returns the following attributes for the following business properties:
				</para>
				
				<informaltable>
					<colgroup>
						<col width="40%"/>
						<col width="60%"/>
					</colgroup>
					<thead>
						<tr>
							<th align="left">Metawidget Attribute</th>
							<th align="left">Java5 feature</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td><parameter>lookup</parameter></td>
							<td>
								values of enums, as returned by .name()
							</td>
						</tr>
						<tr>
							<td><parameter>lookup-labels</parameter></td>
							<td>
								labels of enums, as returned by .toString()
							</td>
						</tr>
						<tr>
							<td><parameter>parameterized-type</parameter></td>
							<td>
								if the property is using generics
							</td>
						</tr>
					</tbody>
				</informaltable>

			</section>

		</section>

		<section id="section-inspectors-annotation">
			<title>Annotation Inspectors</title>

			<para>
				Beyond the base issue of inspecting an object and its properties, a number of inspectors are focussed on
				third-party annotations. These annotation inspectors all extend <classname>BaseObjectInspector</classname>,
				and so inherit its features, but in addition they inspect the following frameworks.
			</para>

			<section id="section-inspectors-beanvalidation">
				<title>BeanValidationInspector</title>
				
				<para>
					<classname>BeanValidationInspector</classname> inspects Bean Validation (JSR 303) annotations. It returns the following
					attributes for the following business properties:
				</para>
				
				<informaltable>
					<colgroup>
						<col width="40%"/>
						<col width="60%"/>
					</colgroup>
					<thead>
						<tr>
							<th align="left">Metawidget Attribute</th>
							<th align="left">Bean Validation Annotation</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td><parameter>maximum-fractional-digits</parameter></td>
							<td><classname>@Digits(fraction=...)</classname></td>
						</tr>
						<tr>
							<td><parameter>maximum-integer-digits</parameter></td>
							<td><classname>@Digits(integer=...)</classname></td>
						</tr>
						<tr>
							<td><parameter>maximum-length</parameter></td>
							<td><classname>@Size(max=...)</classname></td>
						</tr>
						<tr>
							<td><parameter>maximum-value</parameter></td>
							<td><classname>@Max</classname></td>
						</tr>
						<tr>
							<td><parameter>minimum-length</parameter></td>
							<td><classname>@Size(min=...)</classname></td>
						</tr>
						<tr>
							<td><parameter>minimum-value</parameter></td>
							<td><classname>@Min</classname></td>
						</tr>
						<tr>
							<td><parameter>required</parameter></td>
							<td><classname>@NotNull</classname></td>
						</tr>
					</tbody>
				</informaltable>

			</section>

			<section id="section-inspectors-faces">
				<title>FacesInspector</title>
				
				<para>
					<classname>FacesInspector</classname> inspects Java Server Faces-specific annotations. It returns the following
					attributes for the following business properties:
				</para>
				
				<informaltable>
					<colgroup>
						<col width="40%"/>
						<col width="60%"/>
					</colgroup>
					<thead>
						<tr>
							<th align="left">Metawidget Attribute</th>
							<th align="left">Annotation</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>(any)</td>
							<td>
								<classname>@UiFacesAttributes</classname> and <classname>@UiFacesAttribute</classname> -annotates
								an arbitrary Metawidget attribute, based on a Java Server Faces EL expression.
								<para>
									Unlike <classname>@UiFacesLookup</classname>, which fits into a well-defined place within the JSF
									framework (ie. <parameter>f:selectItems</parameter>), the <classname>@UiFacesAttribute</classname> expression is
									evaluated by the <classname>Inspector</classname>, not by the <classname>Metawidget</classname>. This means the
									<classname>Inspector</classname> must be able access to <classname>FacesContext</classname>. In practice this
									usually happens automatically, but in some cases it may be necessary to 'combine remote
									inspections' (see <xref linkend="section-howto-combine-remote"/>).
								</para>
							</td>
						</tr>
						<tr>
							<td>
								<parameter>currency-code</parameter>,
								<parameter>currency-symbol</parameter>, 
								<parameter>number-uses-grouping-separators</parameter>, 
								<parameter>minimum-integer-digits</parameter>, 
								<parameter>maximum-integer-digits</parameter>, 
								<parameter>minimum-fractional-digits</parameter>, 
								<parameter>maximum-fractional-digits</parameter>, 
								<parameter>locale</parameter>,
								<parameter>number-pattern</parameter> and
								<parameter>number-type</parameter>
							</td>
							<td>
								<classname>@UiFacesNumberConverter</classname> - annotates the field should use the standard Faces
								<classname>NumberConverter</classname>.
								<para>
									Note: the <classname>NumberConverter</classname> property <parameter>integerOnly</parameter> is not specified
									using this annotation, as it can be inferred from the property's type
								</para>
							</td>
						</tr>
						<tr>
							<td>
								<parameter>date-style</parameter>,
								<parameter>locale</parameter>, 
								<parameter>datetime-pattern</parameter>, 
								<parameter>time-style</parameter>, 
								<parameter>time-zone</parameter> and
								<parameter>datetime-type</parameter> 
							</td>
							<td><classname>@UiFacesDateTimeConverter</classname> - annotates the field should use the standard Faces <classname>DateTimeConverter</classname></td>
						</tr>
						<tr>
							<td><parameter>faces-ajax-event</parameter></td>
							<td>
								<classname>@UiFacesAjax</classname> - annotates the widget for this field should use AJAX in
								response to the given event
							</td>
						</tr>
						<tr>
							<td><parameter>faces-component</parameter></td>
							<td>
								<classname>@UiFacesComponent</classname> - annotates the field should be rendered using the
								given Faces <classname>UIComponent</classname> in the UI.
								<para>
									Use of this annotation does not bind the business class to the UI quite as tightly
									as it may appear, because JSF has a loosely coupled relationship between
									<parameter>&lt;component-name&gt;</parameter> and <parameter>&lt;component-class&gt;</parameter>, and
									a further loose coupling between <parameter>&lt;component&gt;</parameter> and <parameter>&lt;render-kit&gt;</parameter> - as
									defined in <filename>faces-config.xml</filename>
								</para>
							</td>
						</tr>
						<tr>
							<td><parameter>faces-converter-id</parameter></td>
							<td>
								<classname>UiFacesConverter</classname> - annotates the field should use the given Faces converter
								in the UI.
								<para>
									This annotation uses the converter <emphasis>Id</emphasis>, not the class. Whilst it is possible to
									specify the class through the XML (see
									<parameter>FacesInspectionResultConstants.FACES_CONVERTER_CLASS</parameter>), this does not work well
									for the annotations because they are applied to domain objects, whereas converters are UI-object.
									Using an annotation value of type <classname>Class</classname> would introduce dependencies in the wrong
									direction. Using a value of type <classname>String</classname> that contains a fully-qualified classname
									would work, but is brittle to refactoring
								</para>
							</td>
						</tr>
						<tr>
							<td><parameter>faces-lookup</parameter></td>
							<td>
								<classname>@UiFacesLookup</classname> - annotates the value in the field should
								belong to the set returned by the given EL expression
							</td>
						</tr>
						<tr>
							<td><parameter>faces-suggest</parameter></td>
							<td>
								<classname>@UiFacesSuggest</classname> - annotates the value in the field should
								be 'suggested' (ie. using a pop-up box) using the set returned by the given EL expression
							</td>
						</tr>
					</tbody>
				</informaltable>

			</section>

			<section id="section-inspectors-hibernatevalidator">
				<title>HibernateValidatorInspector</title>
				
				<para>
					<classname>HibernateValidatorInspector</classname> inspects Hibernate Validator annotations. It returns the following
					attributes for the following business properties:
				</para>
				
				<informaltable>
					<colgroup>
						<col width="40%"/>
						<col width="60%"/>
					</colgroup>
					<thead>
						<tr>
							<th align="left">Metawidget Attribute</th>
							<th align="left">Hibernate Validator Annotation</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td><parameter>maximum-fractional-digits</parameter></td>
							<td><classname>@Digits(fractionalDigits=...)</classname></td>
						</tr>
						<tr>
							<td><parameter>maximum-integer-digits</parameter></td>
							<td><classname>@Digits(integerDigits=...)</classname></td>
						</tr>
						<tr>
							<td><parameter>maximum-length</parameter></td>
							<td><classname>@Length(max=...)</classname></td>
						</tr>
						<tr>
							<td><parameter>maximum-value</parameter></td>
							<td><classname>@Max</classname></td>
						</tr>
						<tr>
							<td><parameter>minimum-length</parameter></td>
							<td><classname>@Length(min=...)</classname></td>
						</tr>
						<tr>
							<td><parameter>minimum-value</parameter></td>
							<td><classname>@Min</classname></td>
						</tr>
						<tr>
							<td><parameter>required</parameter></td>
							<td><classname>@NotNull</classname> or <classname>@NotEmpty</classname></td>
						</tr>
					</tbody>
				</informaltable>

			</section>

			<section id="section-inspectors-jexl">
				<title>JexlInspector</title>
				
				<para>
					<classname>JexlInspector</classname> inspects <classname>@UiJexlAttribute</classname> annotations and
					sets arbitrary attributes based on the result of evaluating an Apache Commons JEXL expression. It can
					be used to introduce declarative UI scripting into environments that lack their	own expression language
					(ie. JSP has an EL, Swing does not). For example:
				</para>
				
				<programlisting language="java">import org.metawidget.inspector.commons.jexl.*;

public class Person {
	public boolean retired;
	@UiJexlAttribute( name = "hidden", value = "!this.retired" )
	public BigDecimal pension;
}</programlisting>

				<para>
					This code returns a <parameter>hidden</parameter> attribute based on evaluating the JEXL expression
					<parameter>!this.retired</parameter> (where <parameter>this</parameter> refers to the runtime instance of
					the <classname>Person</classname> being inspected). It could be used to show/hide the <parameter>pension</parameter>
					field in response to the <parameter>retired</parameter> checkbox being checked.
				</para>
				
				<para>
					The JEXL expression language also supports branching statements. For example:
				</para>
				
				<programlisting language="java">import org.metawidget.inspector.commons.jexl.*;

public class PersonController {

	@UiJexlAttribute( name = "label", value = "if ( this.readOnly ) 'Back'" )
	public void cancel() { ... }
}</programlisting>

				<para>
					This code overrides the <parameter>label</parameter> of an action to be either 'Back' or 'Cancel', depending
					on whether the <classname>Person</classname> was being edited. It is taken from the Swing Address Book
					sample (see <xref linkend="section-introduction-part2-desktop"/>).
				</para>
			</section>

			<section id="section-inspectors-jpa">
				<title>JpaInspector</title>
				
				<para>
					<classname>JpaInspector</classname> inspects Java Persistence Architecture annotations. It returns the following
					attributes for the following business properties:
				</para>
				
				<informaltable>
					<colgroup>
						<col width="40%"/>
						<col width="60%"/>
					</colgroup>
					<thead>
						<tr>
							<th align="left">Metawidget Attribute</th>
							<th align="left">JPA Annotation</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td><parameter>hidden</parameter></td>
							<td><classname>@Id</classname>, unless <classname>JpaInspectorConfig.setHideIds</classname> is false</td>
						</tr>
						<tr>
							<td><parameter>large</parameter></td>
							<td><classname>@Lob</classname></td>
						</tr>
						<tr>
							<td><parameter>maximum-length</parameter></td>
							<td><classname>@Column(length=...)</classname></td>
						</tr>
						<tr>
							<td><parameter>required</parameter></td>
							<td><classname>@Column(nullable=false)</classname> or <classname>@ManyToOne(optional=false)</classname></td>
						</tr>
					</tbody>
				</informaltable>

			</section>

			<section id="section-inspectors-metawidgetannotation">
				<title>MetawidgetAnnotationInspector</title>
				
				<para>
					As much as possible, Metawidget tries to inspect metadata from existing sources, without
					introducing new concepts. Where that is not sufficient, <classname>MetawidgetAnnotationInspector</classname> adds
					a handful of annotations:
				</para>
				
				<informaltable>
					<colgroup>
						<col width="40%"/>
						<col width="60%"/>
					</colgroup>
					<thead>
						<tr>
							<th align="left">Metawidget Attribute</th>
							<th align="left">Metawidget Annotation</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>(any)</td>
							<td><classname>@UiAttributes</classname> and <classname>@UiAttribute</classname> - a 'catch all' for denoting arbitrary UI metadata</td>
						</tr>
						<tr>
							<td>(order of fields)</td>
							<td><classname>@UiComesAfter</classname></td>
						</tr>
						<tr>
							<td><parameter>action</parameter></td>
							<td><classname>@UiAction</classname></td>
						</tr>
						<tr>
							<td><parameter>dont-expand</parameter></td>
							<td>
								<classname>@UiDontExpand</classname> - denotes a value should not be inspected and expanded into sub-widgets. This
								can be useful if, say, you have a read-only field and just want to display its top-level <function>toString()</function>
								rather than all its child properties
							</td>
						</tr>
						<tr>
							<td><parameter>hidden</parameter></td>
							<td><classname>@UiHidden</classname> - denotes a value should be hidden in the UI. The value may
								still be rendered on the client, depending on the Metawidget (ie. for Web clients,
								may use a HTML hidden field)
							</td>
						</tr>
						<tr>
							<td><parameter>label</parameter></td>
							<td><classname>@UiLabel</classname> - denotes the label to used in the UI. Can be a resource
								key if the UI is using resource bundles, or
								an EL expression if the UI has an expression language (ie. JSF)
							</td>
						</tr>
						<tr>
							<td><parameter>large</parameter></td>
							<td><classname>@UiLarge</classname> - denotes the field should be 'large' in the UI (ie. a multi-line textbox)</td>
						</tr>
						<tr>
							<td><parameter>lookup</parameter></td>
							<td><classname>@UiLookup</classname> - denotes the value in the field should belong to the given set of Strings</td>
						</tr>
						<tr>
							<td><parameter>masked</parameter></td>
							<td><classname>@UiMasked</classname> - denotes a value should be masked in the UI (eg. a password field)</td>
						</tr>
						<tr>
							<td><parameter>read-only</parameter></td>
							<td><classname>@UiReadOnly</classname> - denotes a value should be read-only in the UI</td>
						</tr>
						<tr>
							<td><parameter>read-only</parameter></td>
							<td><classname>@UiReadOnly</classname> - denotes a value should be read-only in the UI</td>
						</tr>
						<tr>
							<td><parameter>section</parameter></td>
							<td>
								<classname>@UiSection</classname> - denotes the start of a logical grouping in the UI.
								Subsequent fields are assumed
								to belong to the same section until a different section heading is encountered. Sections
								can be cancelled using a section heading with an empty String. Sections can be nested
								by specifying multiple section names.								
							</td>
						</tr>
						<tr>
							<td><parameter>wide</parameter></td>
							<td>
								<classname>@UiWide</classname> - denotes the field should be 'wide' in the UI, spanning all columns in a multi-column layout.
 								'Wide' is different to 'large', because 'large' implies a data size (ie. BLOB or CLOB) whereas 'wide' refers purely to spanning
 								columns. Generally all 'large' fields are implicitly 'wide', but not all 'wide' fields are 'large'. For example, you may want
 								a normal text field (not a text area) to span all columns.
 							</td>
						</tr>
					</tbody>
				</informaltable>

			</section>
			
			<section id="section-inspectors-oval">
				<title>OvalInspector</title>
				
				<para>
					<classname>OvalInspector</classname> inspects OVal annotations. It returns the following
					attributes for the following business properties:
				</para>
				
				<informaltable>
					<colgroup>
						<col width="40%"/>
						<col width="60%"/>
					</colgroup>
					<thead>
						<tr>
							<th align="left">Metawidget Attribute</th>
							<th align="left">OVal Annotation</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td><parameter>maximum-length</parameter></td>
							<td><classname>@Length(max=...)</classname> or <classname>@MaxLength</classname></td>
						</tr>
						<tr>
							<td><parameter>maximum-value</parameter></td>
							<td><classname>@Max</classname> or <classname>@Range(max=...)</classname></td>
						</tr>
						<tr>
							<td><parameter>minimum-length</parameter></td>
							<td><classname>@Length(min=...)</classname> or <classname>@MinLength</classname></td>
						</tr>
						<tr>
							<td><parameter>minimum-value</parameter></td>
							<td><classname>@Min</classname> or <classname>@Range(min=...)</classname></td>
						</tr>
						<tr>
							<td><parameter>required</parameter></td>
							<td><classname>@NotNull</classname> or <classname>@NotEmpty</classname> or <classname>@NotBlank</classname></td>
						</tr>
					</tbody>
				</informaltable>

			</section>

			<section id="section-inspectors-annotation-troubleshooting">
				<title>Troubleshooting</title>				

				<section id="section-inspectors-annotation-troubleshooting-1">
					<title>I get "java.lang.TypeNotPresentException"</title>
					
					<para>
						If you are using Sun's implementation of Java, Metawidget's annotation support requires
						Java 5.0u6 or later, which includes a fix for this bug (Bug Parade ID: 6322301).
					</para>
				</section>

				<section id="section-inspectors-annotation-troubleshooting-2">
					<title>My inspector is not finding my annotations</title>
					
					<para>
						Annotations are designed to 'silently fall away' in environments that do not
						support them: they never throw <classname>ClassDefNotFoundError</classname>. For example,
						if a JPA-annotated class is transferred to an application tier without <filename>ejb3-persistence.jar</filename>
						(or equivalent) in its classpath, the JPA annotations will disappear.
					</para>
					
					<para>
						If this is the cause, either add the appropriate JAR to the tier, or consider implementing a remote inspector
						(see <xref linkend="section-howto-order"/>).
					</para>
				</section>
			</section>
			
		</section>

		<section id="section-inspectors-xml">
			<title>XML Inspectors</title>
			
			<para>
				Whilst we don't necessarily encourage the use of XML-based metadata, if you <emphasis>already</emphasis> have XML configuration
				files in your architecture Metawidget will take advantage of them.
			</para>
			
			<para>
				Once nice feature of XML is that ordering of child elements (such as <parameter>&lt;property name=""&gt;</parameter>) is
				explicit, so XML-based inspectors make great 'first inspectors' for use within <classname>CompositeInspector</classname> (eg. you
				don't need to also use <classname>@UiComesAfter</classname>).
			</para>
			
			<section id="section-inspectors-basexml">
				<title>BaseXmlInspector</title>
				
				<para>
					<classname>BaseXmlInspector</classname>'s config class, <classname>BaseXmlInspectorConfig</classname>, uses a
					<function>setInputStream</function> method to specify the location of the XML. This allows a variety of options
					for sourcing the XML. For example:
				</para>

				<programlisting language="xml">&lt;xmlInspector xmlns="java:org.metawidget.inspector.xml"
	config="XmlInspectorConfig"&gt;
	&lt;inputStream&gt;
		&lt;resource&gt;com/myapp/metawidget-metadata.xml&lt;/resource&gt;
	&lt;/inputStream&gt;
&lt;/xmlInspector&gt;</programlisting>					
				
				<para>
					And:
				</para>

				<programlisting language="xml">&lt;xmlInspector xmlns="java:org.metawidget.inspector.xml"
	config="XmlInspectorConfig"&gt;
	&lt;inputStream&gt;
		&lt;url&gt;http://myserver.com/my-xml.xml&lt;/url&gt;
	&lt;/inputStream&gt;
&lt;/xmlInspector&gt;</programlisting>					

				<para>
					As well as specifying multiple files (which will all be inspected as one):
				</para>

				<programlisting language="xml">&lt;xmlInspector xmlns="java:org.metawidget.inspector.xml"
	config="XmlInspectorConfig"&gt;
	&lt;inputStreams&gt;
		&lt;array&gt;
			&lt;url&gt;http://myserver.com/my-xml-1.xml&lt;/url&gt;
			&lt;url&gt;http://myserver.com/my-xml-2.xml&lt;/url&gt;
		&lt;/array&gt;			
	&lt;/inputStreams&gt;
&lt;/xmlInspector&gt;</programlisting>					

			</section>

			<section id="section-inspectors-commonsvalidator">
				<title>CommonsValidatorInspector</title>
				
				<para>
					<classname>CommonsValidatorInspector</classname> inspects Apache Commons Validator <filename>validation.xml</filename>
					files. It returns the following attributes for the following business properties:
				</para>
				
				<informaltable>
					<colgroup>
						<col width="40%"/>
						<col width="60%"/>
					</colgroup>
					<thead>
						<tr>
							<th align="left">Metawidget Attribute</th>
							<th align="left">Validator XML</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td><parameter>maximum-length</parameter></td>
							<td><parameter>&lt;field depends="maxlength" /&gt;&lt;var&gt;&lt;var-name&gt;maxlength&lt;/var-name&gt;...</parameter></td>
						</tr>
						<tr>
							<td><parameter>maximum-value</parameter></td>
							<td><parameter>&lt;field depends="intRange" /&gt;&lt;var&gt;&lt;var-name&gt;max&lt;/var-name&gt;...</parameter> (or <parameter>floatRange</parameter> or <parameter>doubleRange</parameter>)</td>
						</tr>
						<tr>
							<td><parameter>minimum-length</parameter></td>
							<td><parameter>&lt;field depends="minlength" /&gt;&lt;var&gt;&lt;var-name&gt;minlength&lt;/var-name&gt;...</parameter></td>
						</tr>
						<tr>
							<td><parameter>minimum-value</parameter></td>
							<td><parameter>&lt;field depends="intRange" /&gt;&lt;var&gt;&lt;var-name&gt;min&lt;/var-name&gt;...</parameter> (or <parameter>floatRange</parameter> or <parameter>doubleRange</parameter>)</td>
						</tr>
						<tr>
							<td><parameter>required</parameter></td>
							<td><parameter>&lt;field depends="required" /&gt;</parameter></td>
						</tr>
					</tbody>
				</informaltable>

			</section>

			<section id="section-inspectors-hibernate">
				<title>HibernateInspector</title>
				
				<para>
					<classname>HibernateInspector</classname> inspects Hibernate <filename>hibernate.cfg.xml</filename> and
					<filename>mapping.hbm.xml</filename> files. For the former, it iterates over <parameter>&lt;session-factory&gt;</parameter>'s
					<parameter>&lt;mapping&gt;</parameter> elements and inspects all mapping files.
					It returns the following attributes for the following business properties:
				</para>
				
				<informaltable>
					<colgroup>
						<col width="40%"/>
						<col width="60%"/>
					</colgroup>
					<thead>
						<tr>
							<th align="left">Metawidget Attribute</th>
							<th align="left">Hibernate XML</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td><parameter>hidden</parameter></td>
							<td><parameter>&lt;id /&gt;</parameter></td>
						</tr>
						<tr>
							<td><parameter>large</parameter></td>
							<td><parameter>&lt;property type="clob" /&gt;</parameter></td>
						</tr>
						<tr>
							<td><parameter>maximum-length</parameter></td>
							<td><parameter>&lt;property length="..." /&gt;</parameter></td>
						</tr>
						<tr>
							<td><parameter>parameterized-type</parameter></td>
							<td><parameter>&lt;bag type="..." /&gt;</parameter> or <parameter>&lt;list type="..." /&gt;</parameter> or <parameter>&lt;set type="..." /&gt;</parameter></td>
						</tr>
						<tr>
							<td><parameter>required</parameter></td>
							<td><parameter>&lt;property not-null="true" /&gt;</parameter></td>
						</tr>
					</tbody>
				</informaltable>

			</section>

			<section id="section-inspectors-jexlxml">
				<title>JexlXmlInspector</title>
				
				<para>
					<classname>JexlXmlInspector</classname> inspects files in <filename>inspection-result-1.0.xsd</filename> format
					looking for XML attributes wrapped in <parameter>${...}</parameter> notation. It processes these attributes as
					JEXL expressions before returning them. For example:
				</para>
				
				<programlisting language="xml">&lt;inspection-result&gt;

	&lt;entity type="com.myapp.Person"&gt;
		&lt;property name="pension" hidden="${!this.retired}"/&gt;
	&lt;/entity&gt;

&lt;/inspection-result&gt;</programlisting>
				
				<para>
					<classname>JexlXmlInspector</classname> is effectively equivalent to <classname>JexlInspector</classname>
					but uses XML files instead of annotations.
				</para>
			</section>

			<section id="section-inspectors-pageflow">
				<title>PageflowInspector</title>
				
				<para>
					<classname>PageflowInspector</classname> inspects JBoss jBPM pageflow files 
					looking for <parameter>page</parameter> nodes and their associated <parameter>transition</parameter>s to
					be used as actions. For example, this <filename>pageflow.jpdl.xml</filename> file...
				</para>
				
				<programlisting language="xml">&lt;page name="confirm"&gt;
	&lt;transition name="purchase" to="complete" /&gt;
	&lt;transition name="cancel" to="cancel" /&gt;
&lt;/page&gt;</programlisting>
				
				<para>
					...would return <parameter>purchase</parameter> and <parameter>cancel</parameter> as available
					actions for the <parameter>confirm</parameter> page. For an example of <classname>PageflowInspector</classname>
					in use, see <xref linkend="section-introduction-part3-jbpm"/>.
				</para>
			</section>
			
			<section id="section-inspectors-seam">
				<title>SeamInspector</title>
				
				<para>
					<classname>SeamInspector</classname> inspects Seam XML files for useful metadata. Specifically:
				</para>
				
				<itemizedlist>
					<listitem>
						<para>
							Delegates <parameter>jbpm:pageflow-definitions</parameter> elements from <filename>components.xml</filename> to <classname>PageflowInspector</classname>.
						</para>
					</listitem>
				</itemizedlist>
			</section>

			<section id="section-inspectors-xml-xmlinspector">
				<title>XmlInspector</title>
				
				<para>
					<classname>XmlInspector</classname> inspects files in <filename>inspection-result-1.0.xsd</filename> format. It can
					be used when no other inspector is available for the given attribute.
				</para>
				
				<para>
					Some attributes accept multiple values, such as <parameter>lookup</parameter>. These can be supplied as a comma-separated
					string. The values will be trimmed for whitespace. If the values themselves contain commas, they can be escaped with the
					<parameter>\</parameter> character.
				</para>
				
			</section>

		</section>

	</chapter>

	<chapter id="chapter-inspectionresultprocessors">
		<title>InspectionResultProcessors</title>
		
		<para>
			This chapter covers each <classname>InspectionResultProcessor</classname> in detail. For an explanation of how
			<classname>InspectionResultProcessor</classname>s
			fit into the overall architecture of Metawidget, see <xref linkend="chapter-architecture"/>
		</para>
		
		<section id="section-inspectionresultprocessors-sort-comesafter">
			<title>ComesAfterInspectionResultProcessor</title>
			
			<para>
				<classname>ComesAfterInspectionResultProcessor</classname> sorts inspection results according
				to the <parameter>comes-after</parameter> attribute. This attribute can be created using the
				<classname>@UiComesAfter</classname> annotation (among other ways). For example, the following inspection result...
			</para>
			
			<programlisting language="xml">&lt;entity type="Address Screen"&gt;
	&lt;property name="city" comes-after="street"&gt;
	&lt;action name="save" comes-after="state"&gt;
	&lt;property name="state" comes-after="city"&gt;
	&lt;property name="street"&gt;
&lt;/entity&gt;</programlisting>

			<para>
				...would be sorted into...
			</para>
			
			<programlisting language="xml">&lt;entity type="Address Screen"&gt;
	&lt;property name="street"&gt;
	&lt;property name="city" comes-after="street"&gt;
	&lt;property name="state" comes-after="city"&gt;
	&lt;action name="save" comes-after="state"&gt;
&lt;/entity&gt;</programlisting>

			<para>
				The <parameter>comes-after</parameter> attribute can contain multiple names (comma separated) in which
				case the field will be sorted to come after all the named fields. Alternatively the attribute can be empty, in
				which case the field will come after every other field in the <parameter>entity</parameter>.
			</para>
			
		</section>
		
	</chapter>

	<chapter id="chapter-widgetbuilders">
		<title>Widget Builders</title>
		
		<para>
			This chapter covers each WidgetBuilder in detail. For an explanation of how WidgetBuilders
			fit into the overall architecture of Metawidget, see <xref linkend="chapter-architecture"/>
		</para>

		<para>
			Throughout this chapter when we refer to 'Metawidget Attributes' we mean the intermediate
			XML that Metawidget passes between <classname>Inspector</classname>s and <classname>WidgetBuilder</classname>s.
			Quite which <classname>Inspector</classname> set the attribute, and based on what, is covered in <xref linkend="chapter-inspectors"/>.
			For example, the <parameter>maximum-value</parameter> attribute could be set by <classname>HibernateValidatorInspector</classname>
			based on the <classname>@Max</classname> annotation, or by <classname>CommonsValidatorInspector</classname> based on
			an <parameter>intRange</parameter> element in an XML file, or some other source.
		</para>
		
		<section id="section-widgetbuilders-desktop">
			<title>Desktop Widget Builders</title>
			
			<section id="section-widgetbuilders-swing">
				<title>Swing Widget Builders</title>
				
				<section id="section-widgetbuilders-swing-default">
					<title>SwingWidgetBuilder</title>
					
					<para>
						SwingWidgetBuilder is the default WidgetBuilder for SwingMetawidget. It instantiates the
						following widgets for the following Metawidget attributes: 
					</para>
					
					<informaltable>
						<colgroup>
							<col width="5%"/>
							<col width="35%"/>
							<col width="60%"/>
						</colgroup>
						<thead>
							<tr>
								<th align="left" colspan="2">Widget</th>
								<th align="left">Metawidget Attribute</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<th align="left" colspan="3"><classname>javax.swing</classname></th>
							</tr>
							<tr>
								<td></td>
								<td><classname>JButton</classname></td>
								<td><parameter>action</parameter> (except when also <parameter>read-only</parameter>)</td>
							</tr>
							<tr>
								<td></td>
								<td><classname>JCheckBox</classname></td>
								<td>
									<parameter>type="boolean"</parameter> (and
									<parameter>type="java.lang.Boolean"</parameter>
									when also <parameter>required</parameter>)</td>
							</tr>
							<tr>
								<td></td>
								<td><classname>JComboBox</classname></td>
								<td><parameter>lookup</parameter></td>
							</tr>
							<tr>
								<td></td>
								<td><classname>JLabel</classname></td>
								<td><parameter>read-only</parameter> (except when also <parameter>type="java.util.Collection"</parameter> or <parameter>masked</parameter>)</td>
							</tr>
							<tr>
								<td></td>
								<td><classname>JPanel</classname></td>
								<td><parameter>read-only</parameter> and <parameter>masked</parameter></td>
							</tr>
							<tr>
								<td></td>
								<td><classname>JPasswordField</classname></td>
								<td><parameter>masked</parameter> (except when also <parameter>read-only</parameter>)</td>
							</tr>
							<tr>
								<td></td>
								<td><classname>JSlider</classname></td>
								<td><parameter>type</parameter> is a primitive (except boolean and char) and has both
								<parameter>minimum-value</parameter> and <parameter>maximum-value</parameter></td>
							</tr>
							<tr>
								<td></td>
								<td><classname>JSpinner</classname></td>
								<td><parameter>type</parameter> is a primitive (except boolean and char) and has only
								one, or neither <parameter>minimum-value</parameter> and <parameter>maximum-value</parameter>.
								For floats and doubles, the step size is governed by <parameter>maximum-fractional-digits</parameter></td>
							</tr>
							<tr>
								<td></td>
								<td><classname>JTextArea</classname></td>
								<td><parameter>type="java.lang.String"</parameter> and <parameter>large</parameter>. The <classname>JTextArea</classname> is
								automatically wrapped in a <classname>JScrollPane</classname></td>
							</tr>
							<tr>
								<td></td>
								<td><classname>JTextField</classname></td>
								<td><parameter>type</parameter> is a <classname>java.lang.String</classname>,
								<classname>java.util.Date</classname>,								 
								primitive wrapper (eg. <classname>Integer</classname> or <classname>Float</classname>)
								except <classname>java.lang.Boolean</classname>.
								Also if property is of unknown type but <parameter>dont-expand</parameter></td>
							</tr>
							<tr>
								<th align="left" colspan="3"><classname>org.metawidget.swing</classname></th>
							</tr>
							<tr>
								<td></td>					
								<td><classname>Stub</classname></td>
								<td><parameter>hidden</parameter>, <parameter>action</parameter> when also <parameter>read-only</parameter>,
								<parameter>type="java.util.Collection"</parameter> when also <parameter>read-only</parameter></td>
							</tr>
						</tbody>
					</informaltable>
					
				</section>			
		
				<section id="section-widgetbuilders-swing-swingx">
					<title>SwingXWidgetBuilder</title>
					
					<para>
						SwingXWidgetBuilder is a pluggable WidgetBuilder for the SwingX library. It is intended
						to be used in conjunction with the default SwingWidgetBuilder. It instantiates the
						following widgets for the following Metawidget attributes: 
					</para>
					
					<informaltable>
						<colgroup>
							<col width="5%"/>
							<col width="35%"/>
							<col width="60%"/>
						</colgroup>
						<thead>
							<tr>
								<th align="left" colspan="2">Widget</th>
								<th align="left">Metawidget Attribute</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<th align="left" colspan="3"><classname>org.jdesktop.swingx</classname></th>
							</tr>
							<tr>
								<td></td>
								<td><classname>JXDatePicker</classname></td>
								<td><parameter>type="java.util.Date"</parameter></td>
							</tr>
						</tbody>
					</informaltable>
				</section>
			</section>
		</section>

		<section id="section-widgetbuilders-web">
			<title>Web Widget Builders</title>
	
			<section id="section-widgetbuilders-jsp">
				<title>JSP Widget Builders</title>

				<section id="section-widgetbuilders-jsp-displaytag">
					<title>DisplayTagWidgetBuilder</title>
					
					<para>
						DisplayTagWidgetBuilder is a pluggable WidgetBuilder for the DisplayTag library. It is intended
						to be used in conjunction with the JSP <classname>HtmlWidgetBuilder</classname>, <classname>SpringWidgetBuilder</classname>
						or <classname>StrutsWidgetBuilder</classname>. It instantiates the following widgets for the following Metawidget attributes: 
					</para>
					
					<informaltable>
						<colgroup>
							<col width="5%"/>
							<col width="35%"/>
							<col width="60%"/>
						</colgroup>
						<thead>
							<tr>
								<th align="left" colspan="2">Widget</th>
								<th align="left">Type of field</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<th align="left" colspan="3"><classname>org.displaytag.tags</classname></th>
							</tr>
							<tr>
								<td></td>
								<td><classname>TableTag</classname></td>
								<td>
									<parameter>type="java.util.Collection"</parameter> or
									an array, except when also <parameter>hidden</parameter> or
									<parameter>lookup</parameter>. The
									columns in the table are based on inspecting
									<parameter>parameterized-type</parameter> or the
									component type of the array. If neither can be determined,
									the table will only have a single column
								</td>
							</tr>
						</tbody>
					</informaltable>
				</section>
				
				<section id="section-widgetbuilders-jsp-default">
					<title>HtmlWidgetBuilder</title>
					
					<para>
						<classname>HtmlWidgetBuilder</classname> is the default WidgetBuilder for the JSP HtmlMetawidgetTag. Since JSP has
						only a light component model (ie. HTML tags such as <parameter>&lt;input&gt;</parameter> and
						<parameter>&lt;select&gt;</parameter> are just
						strings, not modelled as JSP tags), <classname>HtmlWidgetBuilder</classname> uses
						<classname>org.metawidget.jsp.tagext.LiteralTag</classname>
						to wrap string-based fragments. It returns the following literals for the following Metawidget attributes: 
					</para>
					
					<informaltable>
						<colgroup>
							<col width="5%"/>
							<col width="35%"/>
							<col width="60%"/>
						</colgroup>
						<thead>
							<tr>
								<th align="left" colspan="2">Widget</th>
								<th align="left">Metawidget Attribute</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td></td>
								<td><classname>&lt;input type="checkbox"&gt;</classname></td>
								<td>
									<parameter>type="boolean"</parameter> (and
									<parameter>type="java.lang.Boolean"</parameter>
									when also <parameter>required</parameter>)</td>
							</tr>				
							<tr>
								<td></td>
								<td><classname>&lt;input type="hidden"&gt;</classname></td>
								<td><parameter>hidden</parameter> when also <parameter>HtmlMetawidgetTag.setCreateHiddenFields</parameter> is set to true</td>
							</tr>
							<tr>
								<td></td>
								<td><classname>&lt;input type="password"&gt;</classname></td>
								<td><parameter>masked</parameter> (except when also <parameter>read-only</parameter>)</td>
							</tr>
							<tr>
								<td></td>
								<td><classname>&lt;input type="submit"&gt;</classname></td>
								<td><parameter>action</parameter> (except when also <parameter>read-only</parameter>)</td>
							</tr>
							<tr>
								<td></td>
								<td><classname>&lt;input type="text"&gt;</classname></td>
								<td><parameter>type</parameter> is a <classname>java.lang.String</classname>,
								<classname>java.util.Date</classname>,								 
								primitive wrapper (eg. <classname>Integer</classname> or <classname>Float</classname>)
								except <classname>java.lang.Boolean</classname>.
								Also if property is of unknown type but <parameter>dont-expand</parameter>.
								If <parameter>maximum-length</parameter>, adds <parameter>maxlength="..."</parameter></td>							
							</tr>
							<tr>
								<td></td>
								<td><classname>&lt;select&gt;</classname></td>
								<td><parameter>lookup</parameter></td>
							</tr>					
							<tr>
								<td></td>
								<td>raw text</td>
								<td><parameter>read-only</parameter> (except when also <parameter>type="java.util.Collection"</parameter> or
								<parameter>masked</parameter>). If <parameter>HtmlMetawidgetTag.setCreateHiddenFields</parameter> is set to
								true, further adds a <classname>&lt;input type="hidden"&gt;</classname> so that something gets POSTed back</td>
							</tr>
							<tr>
								<td></td>
								<td><classname>&lt;textarea&gt;</classname></td>
								<td><parameter>type="java.lang.String"</parameter> and <parameter>large</parameter></td>
							</tr>
							<tr>
								<th align="left" colspan="3"><classname>org.metawidget.jsp.tagext</classname></th>
							</tr>
							<tr>
								<td></td>					
								<td><classname>StubTag</classname></td>
								<td><parameter>hidden</parameter>, <parameter>action</parameter> when also <parameter>read-only</parameter>,
								<parameter>type="java.util.Collection"</parameter> when also <parameter>read-only</parameter></td>
							</tr>
						</tbody>
					</informaltable>
					
				</section>				
	
				<section id="section-widgetbuilders-jsp-spring">
					<title>SpringWidgetBuilder</title>
					
					<para>
						SpringWidgetBuilder is the default WidgetBuilder for SpringMetawidgetTag, albeit
						used in conjunction with the JSP HtmlWidgetBuilder. Like HtmlWidgetBuilder, it simply
						returns fragments of HTML. The JSP component model is too light to support returning
						tags containing child tags (ie. a <classname>SelectTag</classname> containing
						<classname>OptionTag</classname>s).	SpringWidgetBuilder
						returns the following widgets for the following Metawidget attributes: 
					</para>
					
					<informaltable>
						<colgroup>
							<col width="5%"/>
							<col width="35%"/>
							<col width="60%"/>
						</colgroup>
						<thead>
							<tr>
								<th align="left" colspan="2">Widget</th>
								<th align="left">Metawidget Attribute</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<th align="left" colspan="3"><classname>org.springframework.web.servlet.tags.form</classname></th>
							</tr>
							<tr>
								<td></td>
								<td><classname>CheckboxTag</classname></td>
								<td>
									<parameter>type="boolean"</parameter> (and
									<parameter>type="java.lang.Boolean"</parameter>
									when also <parameter>required</parameter>)</td>
							</tr>
							<tr>
								<td></td>
								<td><classname>HiddenInputTag</classname></td>
								<td><parameter>hidden</parameter> when also <parameter>HtmlMetawidgetTag.setCreateHiddenFields</parameter> is set to true</td>
							</tr>
							<tr>
								<td></td>
								<td><classname>InputTag</classname></td>
								<td><parameter>type</parameter> is a <classname>java.lang.String</classname>,
								<classname>java.util.Date</classname>,								 
								primitive wrapper (eg. <classname>Integer</classname> or <classname>Float</classname>)
								except <classname>java.lang.Boolean</classname>.
								Also if property is of unknown type but <parameter>dont-expand</parameter>.
								If <parameter>maximum-length</parameter>, calls <function>setMaxlength</function></td>							
							</tr>
							<tr>
								<td></td>
								<td><classname>PasswordInputTag</classname></td>
								<td><parameter>masked</parameter> (except when also <parameter>read-only</parameter>)</td>
							</tr>
							<tr>
								<td></td>
								<td>raw text</td>								
								<td><parameter>read-only</parameter> (except when also <parameter>type="java.util.Collection"</parameter> or
								<parameter>masked</parameter>). If <parameter>HtmlMetawidgetTag.setCreateHiddenFields</parameter> is set to
								true, further adds a <classname>HiddenInputTag</classname> so that something gets POSTed back</td>
							</tr>
							<tr>
								<td></td>
								<td><classname>SelectTag</classname></td>
								<td><parameter>lookup</parameter></td>
							</tr>					
							<tr>
								<td></td>
								<td><classname>TextareaTag</classname></td>
								<td><parameter>type="java.lang.String"</parameter> and <parameter>large</parameter></td>
							</tr>
							<tr>
								<th align="left" colspan="3"><classname>org.metawidget.jsp.tagext</classname></th>
							</tr>
							<tr>
								<td></td>					
								<td><classname>StubTag</classname></td>
								<td><parameter>action</parameter> when not <parameter>read-only</parameter></td>
							</tr>
						</tbody>
					</informaltable>
				</section>	
		
				<section id="section-widgetbuilders-jsp-struts">
					<title>StrutsWidgetBuilder</title>
					
					<para>
						StrutsWidgetBuilder is the default WidgetBuilder for StrutsMetawidgetTag, albeit
						used in conjunction with the JSP HtmlWidgetBuilder. Like HtmlWidgetBuilder, it simply
						returns fragments of HTML. The JSP component model is too light to support returning
						tags containing child tags (ie. a <classname>SelectTag</classname> containing
						<classname>OptionTag</classname>s).	StrutsWidgetBuilder
						returns the following widgets for the following Metawidget attributes: 
					</para>
					
					<informaltable>
						<colgroup>
							<col width="5%"/>
							<col width="35%"/>
							<col width="60%"/>
						</colgroup>
						<thead>
							<tr>
								<th align="left" colspan="2">Widget</th>
								<th align="left">Metawidget Attribute</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<th align="left" colspan="3"><classname>org.apache.struts.taglib.html</classname></th>
							</tr>
							<tr>
								<td></td>
								<td><classname>CheckboxTag</classname></td>
								<td>
									<parameter>type="boolean"</parameter> (and
									<parameter>type="java.lang.Boolean"</parameter>
									when also <parameter>required</parameter>)</td>
							</tr>
							<tr>
								<td></td>
								<td><classname>SelectTag</classname></td>
								<td><parameter>lookup</parameter></td>
							</tr>
							<tr>
								<td></td>
								<td><classname>HiddenTag</classname></td>
								<td><parameter>hidden</parameter> when also <parameter>HtmlMetawidgetTag.setCreateHiddenFields</parameter> is set to true</td>
							</tr>
							<tr>
								<td></td>
								<td><classname>PasswordTag</classname></td>
								<td><parameter>masked</parameter> (except when also <parameter>read-only</parameter>)</td>
							</tr>
							<tr>
								<td></td>
								<td>raw text</td>
								<td><parameter>read-only</parameter> (except when also <parameter>type="java.util.Collection"</parameter> or
								<parameter>masked</parameter>). If <parameter>HtmlMetawidgetTag.setCreateHiddenFields</parameter> is set to
								true, further adds a <classname>HiddenInputTag</classname> so that something gets POSTed back</td>
							</tr>
							<tr>
								<td></td>
								<td><classname>TextTag</classname></td>
								<td><parameter>type</parameter> of <classname>java.util.Date</classname>,								 
								primitive wrapper (eg. <classname>Integer</classname> or <classname>Float</classname>)
								except <classname>java.lang.Boolean</classname>.
								Also if property is of unknown type but <parameter>dont-expand</parameter>.
								If <parameter>maximum-length</parameter>, calls <function>setMaxlength</function></td>							
							</tr>
							<tr>
								<td></td>
								<td><classname>TextareaTag</classname></td>
								<td><parameter>type="java.lang.String"</parameter> and <parameter>large</parameter></td>
							</tr>
							<tr>
								<th align="left" colspan="3"><classname>org.metawidget.jsp.tagext</classname></th>
							</tr>
							<tr>
								<td></td>					
								<td><classname>StubTag</classname></td>
								<td><parameter>action</parameter> when not <parameter>read-only</parameter></td>
							</tr>
						</tbody>
					</informaltable>
				</section>	

			</section>
			
			<section id="section-widgetbuilders-gwt">
				<title>GWT Widget Builders</title>
			
				<section id="section-widgetbuilders-gwt-extgwt">
					<title>ExtGwtWidgetBuilder</title>
					
					<para>
						ExtGwtWidgetBuilder is a pluggable WidgetBuilder for the ExtGWT library. It is intended
						to be used in conjunction with the default GwtWidgetBuilder. It instantiates the
						following widgets for the following Metawidget attributes: 
					</para>
					
					<informaltable>
						<colgroup>
							<col width="5%"/>
							<col width="35%"/>
							<col width="60%"/>
						</colgroup>
						<thead>
							<tr>
								<th align="left" colspan="2">Widget</th>
								<th align="left">Metawidget Attribute</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<th align="left" colspan="3"><classname>com.extjs.gxt.ui.client.widget.form</classname></th>
							</tr>
							<tr>
								<td></td>
								<td><classname>DateField</classname></td>
								<td><parameter>type="java.util.Date"</parameter></td>
							</tr>
							<tr>
								<td></td>
								<td><classname>Slider</classname></td>
								<td><parameter>type</parameter> is a primitive (except boolean and char) and has both
								<parameter>minimum-value</parameter> and <parameter>maximum-value</parameter></td>
							</tr>
						</tbody>
					</informaltable>
					
					<para>
						To build applications that use <classname>ExtGwtWidgetBuilder</classname>, include <filename>metawidget.jar</filename>
						<emphasis>and</emphasis> <filename>examples\gwt\metawidget-gwt.jar</filename>
						<emphasis>and</emphasis> <filename>examples\gwt\metawidget-gwt-extgwt-client.jar</filename>
						in the <parameter>CLASSPATH</parameter> during the GWTCompiler phase.
					</para>
					
				</section>

				<section id="section-widgetbuilders-gwt-default">
					<title>GwtWidgetBuilder</title>
					
					<para>
						GwtWidgetBuilder is the default WidgetBuilder for GwtMetawidget. It instantiates the
						following widgets for the following Metawidget attributes: 
					</para>
					
					<informaltable>
						<colgroup>
							<col width="5%"/>
							<col width="35%"/>
							<col width="60%"/>
						</colgroup>
						<thead>
							<tr>
								<th align="left" colspan="2">Widget</th>
								<th align="left">Metawidget Attribute</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<th align="left" colspan="3"><classname>com.google.gwt.user.client.ui</classname></th>
							</tr>
							<tr>
								<td></td>
								<td><classname>Button</classname></td>
								<td><parameter>action</parameter> (except when also <parameter>read-only</parameter>)</td>
							</tr>
							<tr>
								<td></td>
								<td><classname>CheckBox</classname></td>
								<td>
									<parameter>type="boolean"</parameter> (and
									<parameter>type="java.lang.Boolean"</parameter>
									when also <parameter>required</parameter>)</td>
							</tr>
							<tr>
								<td></td>
								<td><classname>Label</classname></td>
								<td><parameter>read-only</parameter> (except when also <parameter>type="java.util.Collection"</parameter> or <parameter>masked</parameter>)</td>								
							</tr>
							<tr>
								<td></td>
								<td><classname>ListBox</classname></td>
								<td><parameter>lookup</parameter></td>
							</tr>
							<tr>
								<td></td>
								<td><classname>PasswordTextBox</classname></td>
								<td><parameter>masked</parameter> (except when also <parameter>read-only</parameter>)</td>
							</tr>
							<tr>
								<td></td>
								<td><classname>SimplePanel</classname></td>
								<td><parameter>masked</parameter> and <parameter>read-only</parameter></td>
							</tr>
							<tr>
								<td></td>
								<td><classname>TextArea</classname></td>
								<td><parameter>type="java.lang.String"</parameter> and <parameter>large</parameter></td>
							</tr>
							<tr>
								<td></td>
								<td><classname>TextBox</classname></td>
								<td><parameter>type</parameter> of <classname>java.util.Date</classname>,								 
								primitive wrapper (eg. <classname>Integer</classname> or <classname>Float</classname>)
								except <classname>java.lang.Boolean</classname>.
								Also if property is of unknown type but <parameter>dont-expand</parameter>.
								If <parameter>maximum-length</parameter>, calls <function>setMaxlength</function></td>							
							</tr>
							<tr>
								<th align="left" colspan="3"><classname>org.metawidget.gwt.client.ui</classname></th>
							</tr>
							<tr>
								<td></td>					
								<td><classname>Stub</classname></td>
								<td><parameter>hidden</parameter>, <parameter>action</parameter> when also <parameter>read-only</parameter>,
								<parameter>type="java.util.Collection"</parameter> when also <parameter>read-only</parameter></td>
							</tr>
						</tbody>
					</informaltable>
					
				</section>			
			
			</section>
	
			<section id="section-widgetbuilders-faces">
				<title>JSF Widget Builders</title>
				
				<section id="section-widgetbuilders-faces-default">
					<title>HtmlWidgetBuilder</title>
					
					<para>
						HtmlWidgetBuilder is the default WidgetBuilder for the JSF HtmlMetawidget. It instantiates the
						following widgets for the following Metawidget attributes: 
					</para>
					
					<informaltable>
						<colgroup>
							<col width="5%"/>
							<col width="35%"/>
							<col width="60%"/>
						</colgroup>
						<thead>
							<tr>
								<th align="left" colspan="2">Widget</th>
								<th align="left">Metawidget Attribute</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<th align="left" colspan="3"><classname>javax.faces.component.html</classname></th>
							</tr>
							<tr>
								<td></td>
								<td><classname>HtmlCommandButton</classname></td>
								<td><parameter>action</parameter> (except when also <parameter>read-only</parameter>)</td>
							</tr>
							<tr>
								<td></td>
								<td><classname>HtmlDataTable</classname></td>
								<td>
									<parameter>type</parameter> of List, DataModel or
									array, except when also <parameter>hidden</parameter> or
									<parameter>lookup</parameter>. The
									columns in the table are based on inspecting
									<parameter>parameterized-type</parameter> or the
									component type of the array. If neither can be determined,
									the table will only have a single column
								</td>
							</tr>
							<tr>
								<td></td>
								<td><classname>HtmlInputHidden</classname></td>
								<td><parameter>hidden</parameter> when <parameter>HtmlMetawidget.setCreateHiddenFields</parameter> is set to true</td>
							</tr>
							<tr>
								<td></td>
								<td><classname>HtmlInputSecret</classname></td>
								<td><parameter>masked</parameter> (except when also <parameter>read-only</parameter>)</td>
							</tr>
							<tr>
								<td></td>
								<td><classname>HtmlInputText</classname></td>
								<td><parameter>type</parameter> of <classname>java.util.Date</classname>,								 
								primitive wrapper (eg. <classname>Integer</classname> or <classname>Float</classname>)
								except <classname>java.lang.Boolean</classname>.
								Also if property is of unknown type but <parameter>dont-expand</parameter>.
								If <parameter>maximum-length</parameter>, calls <function>setMaxlength</function></td>							
							</tr>
							<tr>
								<td></td>
								<td><classname>HtmlInputTextarea</classname></td>
								<td><parameter>type="java.lang.String"</parameter> and <parameter>large</parameter></td>
							</tr>
							<tr>
								<td></td>
								<td><classname>HtmlOutputText</classname></td>
								<td><parameter>read-only</parameter> (except when also <parameter>type="java.util.Collection"</parameter> or <parameter>masked</parameter>)</td>								
							</tr>
							<tr>
								<td></td>
								<td><classname>HtmlSelectBooleanCheckbox</classname></td>
								<td>
									<parameter>type="boolean"</parameter> (and
									<parameter>type="java.lang.Boolean"</parameter>
									when also <parameter>required</parameter>)</td>
							</tr>
							<tr>
								<td></td>
								<td><classname>HtmlSelectManyCheckbox</classname></td>
								<td><parameter>type</parameter> of List or array, with <parameter>lookup</parameter></td>
							</tr>					
							<tr>
								<td></td>
								<td><classname>HtmlSelectOneListbox</classname></td>
								<td><parameter>lookup</parameter></td>
							</tr>					
							<tr>
								<th align="left" colspan="3"><classname>org.metawidget.faces.component</classname></th>
							</tr>
							<tr>
								<td></td>					
								<td><classname>HtmlLookupOutputText</classname></td>
								<td><parameter>read-only</parameter> with <parameter>lookup-label</parameter></td>
							</tr>
							<tr>
								<td></td>					
								<td><classname>UIStub</classname></td>
								<td><parameter>hidden</parameter>, <parameter>action</parameter> when also <parameter>read-only</parameter>,
								<parameter>masked</parameter> when also <parameter>read-only</parameter>,
								<parameter>type="java.util.Collection"</parameter> when also <parameter>read-only</parameter></td>								
							</tr>
						</tbody>
					</informaltable>
					
				</section>
	
				<section id="section-widgetbuilders-icefaces">
					<title>IceFacesWidgetBuilder</title>
					
					<para>
						IceFacesWidgetBuilder is a pluggable WidgetBuilder for the JSF UIMetawidget. It is intended
						to be used in conjunction with the default JSF <classname>HtmlWidgetBuilder</classname>. For an
						example, see <xref linkend="section-introduction-part3-icefaces"/>.
						IceFacesWidgetBuilder instantiates the following widgets for the following Metawidget attributes: 
					</para>
					
					<informaltable>
						<colgroup>
							<col width="5%"/>
							<col width="35%"/>
							<col width="60%"/>
						</colgroup>
						<thead>
							<tr>
								<th align="left" colspan="2">Widget</th>
								<th align="left">Metawidget Attribute</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<th align="left" colspan="3"><classname>com.icesoft.faces.component.ext</classname></th>
							</tr>
							<tr>
								<td></td>
								<td><classname>HtmlCommandButton</classname></td>
								<td><parameter>action</parameter> (except when also <parameter>read-only</parameter>)</td>
							</tr>
							<tr>
								<td></td>
								<td><classname>HtmlInputSecret</classname></td>
								<td><parameter>masked</parameter> (except when also <parameter>read-only</parameter>)</td>
							</tr>
							<tr>
								<td></td>
								<td><classname>HtmlInputText</classname></td>
								<td><parameter>type</parameter> of <classname>java.util.Date</classname>,								 
								primitive wrapper (eg. <classname>Integer</classname> or <classname>Float</classname>)
								except <classname>java.lang.Boolean</classname>.
								Also if property is of unknown type but <parameter>dont-expand</parameter>.
								If <parameter>maximum-length</parameter>, calls <function>setMaxlength</function></td>							
							</tr>
							<tr>
								<td></td>
								<td><classname>HtmlInputTextarea</classname></td>
								<td><parameter>type="java.lang.String"</parameter> and <parameter>large</parameter></td>
							</tr>
							<tr>
								<td></td>
								<td><classname>HtmlSelectBooleanCheckbox</classname></td>
								<td>
									<parameter>type="boolean"</parameter> (and
									<parameter>type="java.lang.Boolean"</parameter>
									when also <parameter>required</parameter>)</td>
							</tr>
							<tr>
								<td></td>
								<td><classname>HtmlSelectManyCheckbox</classname></td>
								<td>
									<parameter>type="boolean"</parameter> (and
									<parameter>type="java.lang.Boolean"</parameter>
									when also <parameter>required</parameter>)</td>
							</tr>					
							<tr>
								<td></td>
								<td><classname>HtmlSelectOneListbox</classname></td>
								<td><parameter>lookup</parameter></td>
							</tr>					
							<tr>
								<th align="left" colspan="3"><classname>com.icesoft.faces.component</classname></th>
							</tr>
							<tr>
								<td></td>					
								<td><classname>SelectInputDate</classname></td>
								<td>
									<parameter>type="java.util.Date"</parameter>
									<para>
										<emphasis>
											Note: the ICEfaces SelectInputDate widget uses internal state to control
											its popup. Therefore Metawidget will not destroy and recreate it upon
											POSTback, as it does with most other widgets (in order to update them to
											reflect changes in business model state).
										</emphasis>
									</para>
								</td>
							</tr>
						</tbody>
					</informaltable>
					
					<para>
						All components are instantiated with <parameter>partialSubmit</parameter> set to true.
					</para>
		
				</section>			
		
				<section id="section-widgetbuilders-richfaces">
					<title>RichFacesWidgetBuilder</title>
					
					<para>
						RichFacesWidgetBuilder is a pluggable WidgetBuilder for the JSF UIMetawidget. It is intended
						to be used in conjunction with the default JSF <classname>HtmlWidgetBuilder</classname>. For an example, see <xref linkend="section-introduction-part2-web-richfaces"/>.
						RichFacesWidgetBuilder instantiates the following widgets for the following Metawidget attributes: 
					</para>
					
					<informaltable>
						<colgroup>
							<col width="5%"/>
							<col width="35%"/>
							<col width="60%"/>
						</colgroup>
						<thead>
							<tr>
								<th align="left" colspan="2">Widget</th>
								<th align="left">Metawidget Attribute</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<th align="left" colspan="3"><classname>org.richfaces.component.html</classname></th>
							</tr>
							<tr>
								<td></td>
								<td><classname>HtmlCalendar</classname></td>
								<td><parameter>type="java.util.Date"</parameter></td>
							</tr>
							<tr>
								<td></td>
								<td><classname>HtmlColorPicker</classname></td>
								<td><classname><parameter>type="java.awt.Color"</parameter></classname></td>
							</tr>
							<tr>
								<td></td>
								<td><classname>HtmlInputNumberSlider</classname></td>
								<td><parameter>type</parameter> is a primitive (except boolean and char) and has both
								<parameter>minimum-value</parameter> and <parameter>maximum-value</parameter></td>
							</tr>
							<tr>
								<td></td>
								<td><classname>HtmlInputNumberSpinner</classname></td>
								<td><parameter>type</parameter> is a primitive (except boolean and char) or
								a <classname>Number</classname> and has only
								one, or neither <parameter>minimum-value</parameter> and <parameter>maximum-value</parameter></td>
							</tr>
							<tr>
								<td></td>
								<td><classname>HtmlSuggestionBox</classname></td>
								<td><parameter>faces-suggest</parameter></td>
							</tr>
						</tbody>
					</informaltable>
				</section>

				<section id="section-widgetbuilders-tomahawk">
					<title>TomahawkWidgetBuilder</title>
					
					<para>
						TomahawkWidgetBuilder is a pluggable WidgetBuilder for the JSF UIMetawidget. It is intended
						to be used in conjunction with the default JSF <classname>HtmlWidgetBuilder</classname>.
						TomahawkWidgetBuilder instantiates the following widgets for the following Metawidget attributes: 
					</para>
					
					<informaltable>
						<colgroup>
							<col width="5%"/>
							<col width="35%"/>
							<col width="60%"/>
						</colgroup>
						<thead>
							<tr>
								<th align="left" colspan="2">Widget</th>
								<th align="left">Metawidget Attribute</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<th align="left" colspan="3"><classname>org.apache.myfaces.custom</classname></th>
							</tr>
							<tr>
								<td></td>
								<td><classname>HtmlInputFileUpload</classname></td>
								<td><parameter>type="org.apache.myfaces.custom.fileupload.UploadedFile"</parameter></td>
							</tr>
						</tbody>
					</informaltable>
				</section>	

			</section>

		</section>	

		<section id="section-widgetbuilders-mobile">
			<title>Mobile Widget Builders</title>

			<section id="section-widgetbuilders-android">
				<title>Android Widget Builders</title>

				<section id="section-widgetbuilders-android-default">
					<title>AndroidWidgetBuilder</title>
					
					<para>
						AndroidWidgetBuilder is the default WidgetBuilder for AndroidMetawidget. It instantiates the
						following widgets for the following Metawidget attributes: 
					</para>
					
					<informaltable>
						<colgroup>
							<col width="5%"/>
							<col width="35%"/>
							<col width="60%"/>
						</colgroup>
						<thead>
							<tr>
								<th align="left" colspan="2">Widget</th>
								<th align="left">Metawidget Attribute</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<th align="left" colspan="3"><classname>android.widget</classname></th>
							</tr>
							<tr>
								<td></td>
								<td><classname>CheckBox</classname></td>
								<td>
									<parameter>type="boolean"</parameter> (and
									<parameter>type="java.lang.Boolean"</parameter>
									when also <parameter>required</parameter>)</td>
							</tr>
							<tr>
								<td></td>
								<td><classname>DatePicker</classname></td>
								<td><parameter>type="java.utils.Date"</parameter> when also <parameter>required</parameter></td>
							</tr>
							<tr>
								<td></td>
								<td><classname>EditText</classname></td>
								<td><parameter>type</parameter> of primitive wrapper
								(eg. <classname>Integer</classname> or <classname>Float</classname>)
								except <classname>java.lang.Boolean</classname>.
								Also if property is of unknown type but <parameter>dont-expand</parameter>.
								If <parameter>large</parameter>, calls <function>setMinLines</function>.
								If <parameter>masked</parameter>, sets a <classname>PasswordTransformationMethod</classname>.
								If numeric, sets a <classname>DigitsKeyListener</classname>.
								If <parameter>maximum-length</parameter>, sets a <classname>InputFilter.LengthFilter</classname>.
								If <parameter>type</parameter> is a Date, sets a <classname>DateKeyListener</classname></td>							
							</tr>
							<tr>
								<td></td>
								<td><classname>PasswordTextBox</classname></td>
								<td><parameter>masked</parameter> (except when also <parameter>read-only</parameter>)</td>
							</tr>
							<tr>
								<td></td>
								<td><classname>Spinner</classname></td>
								<td><parameter>lookup</parameter></td>
							</tr>
							<tr>
								<td></td>
								<td><classname>TextView</classname></td>
								<td><parameter>read-only</parameter> (except when also <parameter>type="java.util.Collection"</parameter>).
								If <parameter>masked</parameter> sets <classname>View.INVISIBLE</classname></td>
							</tr>
							<tr>
								<th align="left" colspan="3"><classname>org.metawidget.gwt.client.ui</classname></th>
							</tr>
							<tr>
								<td></td>					
								<td><classname>Stub</classname></td>
								<td><parameter>hidden</parameter>, <parameter>action</parameter> when also <parameter>read-only</parameter>,
								<parameter>masked</parameter> when also <parameter>read-only</parameter>,
								<parameter>type="java.util.Collection"</parameter> when also <parameter>read-only</parameter></td>								
							</tr>
						</tbody>
					</informaltable>
					
				</section>
			</section>
		</section>
					
	</chapter>
	
	<chapter id="chapter-widgetprocessors">
		<title>WidgetProcessors</title>
		
		<para>
			This chapter covers each <classname>WidgetProcessor</classname> in detail. For an explanation of
			how <classname>WidgetProcessor</classname>s fit into the overall architecture of Metawidget, see
			<xref linkend="chapter-architecture"/>.
		</para>
		
		<section id="section-widgetprocessors-desktop">
			<title>Desktop Widget Processors</title>
		
			<section id="section-widgetprocessors-desktop-swing">
				<title>Swing Widget Processors</title>
				
				<section id="section-widgetprocessors-desktop-swing-propertybinding">
					<title>Property Binding</title>
					
					<para>
						Swing does not include an automatic <classname>JComponent</classname> to <classname>Object</classname> binding mechanism, but Metawidget
						supports third-party alternatives via <function>addWidgetProcessor</function>.
					</para>
					
					<section id="section-widgetprocessors-desktop-swing-binding-beansbinding">
						<title>BeansBindingProcessor</title>
						
						<para>
							<classname>BeansBindingProcessor</classname> binds properties using Beans Binding (JSR 295). It supports the various
							Beans Binding update strategies:
						</para>
						
						<programlisting language="java">myMetawidget.addWidgetProcessor( new BeansBindingProcessor(
	new BeansBindingProcessorConfig()
		.setUpdateStrategy( UpdateStrategy.READ )) );</programlisting>
		
						<para>
							If set to <parameter>READ</parameter> or <parameter>READ_WRITE</parameter> (the default is
							<parameter>READ_ONCE</parameter>), the object being inspected must
							provide <classname>PropertyChangeSupport</classname>. If set to <parameter>READ_WRITE</parameter>, updates
							to the UI are automatically sync'ed back to the <function>setToInspect</function>, otherwise the
							client must manually call <function>save</function>:
						</para>

						<programlisting language="java">myMetawidget.getWidgetProcessor( BeansBindingProcessor.class ).save( myMetawidget )</programlisting>
						
						<para>
							After <classname>JComponent</classname>s have been generated for the initial <function>setToInspect</function>, clients
							can update their values to a new Object without a full re-inspection by using <function>rebind</function>: 
						</para>
						
						<programlisting language="java">myMetawidget.getWidgetProcessor( BeansBindingProcessor.class ).rebind( newObject, myMetawidget )</programlisting>
						
						<para>
							For more details, see <xref linkend="section-performance-rebind"/>.
						</para>

					</section>
				
					<section id="section-widgetprocessors-desktop-swing-binding-beanutilsbinding">
						<title>BeanUtilsProcessor</title>
						
						<para>
							<classname>BeanUtilsProcessor</classname> binds properties using
							<ulink url="http://commons.apache.org/beanutils">Apache BeanUtils</ulink>. It supports JavaBean
							and Scala property styles:
						</para>
						
						<programlisting language="java">myMetawidget.addWidgetProcessor( new BeanUtilsBindingProcessor(
	new BeanUtilsBindingProcessorConfig()
		.setPropertyStyle( BeanUtilsBindingProcessorConfig.PROPERTYSTYLE_SCALA )) );</programlisting>
		
						<para>
							Updates to the UI can be saved back to the <function>setToInspect</function> by calling <function>save</function>:
						</para>

						<programlisting language="java">myMetawidget.getWidgetProcessor( BeanUtilsBindingProcessor.class ).save( myMetawidget )</programlisting>
						
						<para>
							After <classname>JComponent</classname>s have been generated for the initial <function>setToInspect</function>, clients
							can update their values to a new Object without a full re-inspection by using <function>rebind</function>: 
						</para>
						
						<programlisting language="java">myMetawidget.getWidgetProcessor( BeanUtilsBindingProcessor.class ).rebind( newObject, myMetawidget )</programlisting>
						
						<para>
							For more details, see <xref linkend="section-performance-rebind"/>.
						</para>

					</section>

				</section>
	
				<section id="section-widgetprocessors-desktop-swing-actionbinding">
					<title>Action Binding</title>
					
					<para>
						Swing supplies <classname>javax.swing.Action</classname> for binding <classname>JButtons</classname> to backing classes, and this is
						typically combined with Java-based reflection to support runtime binding. This is exactly what the default action binding,
						<classname>ReflectionBinding</classname>, does.
					</para>
					
					<para>
						However, Metawidget makes action bindings pluggable to support other use cases. In particular, use cases where there
						<emphasis>is</emphasis> no backing class, and instead the <classname>JButton</classname> should invoke, say, an RPC
						call. Implement your own pluggable binding by implementing <classname>WidgetProcessor</classname> and use it by calling:
					</para>
					
					<programlisting language="java">myMetawidget.addWidgetProcessor( new MyWidgetProcessor() );</programlisting>
										
				</section>
			</section>
		</section>
		
		<section id="section-widgetprocessors-web">
			<title>Web Widget Processors</title>

			<section id="section-widgetprocessors-web-gwt">
				<title>GWT Widget Processors</title>

				<section id="section-widgetprocessors-web-gwt-propertybinding">
					<title>Property Binding</title>
						
					<para>
						Like most other Metawidgets, <classname>GwtMetawidget</classname> supports property binding. Property binding
						generally requires reflection, and GWT recommends using <classname>Generators</classname> to achieve this. As of
						the time of writing, however, much of the burden of implementation rests on the developer.
					</para>
						
					<para>
						<classname>GwtMetawidget</classname> automates this burden by supplying a <classname>SimpleBindingProcessor</classname>
						implementation. This implementation is pluggable, so may be swapped out as and when later releases of GWT
						more fully support data binding.
					</para>
						
					<para>
						<classname>SimpleBindingProcessor</classname> expects every domain object to be wrapped with a <classname>SimpleBindingProcessorAdapter</classname>.
						The supplied <classname>SimpleBindingProcessorAdapterGenerator</classname> automates this process. To configure it, add the following
						to the <filename>application-name.gwt.xml</filename> file...
					</para>
						
					<programlisting language="xml">&lt;generate-with
	class="org.metawidget.gwt.generator.widgetprocessor.binding.simple.SimpleBindingProcessorAdapterGenerator"&gt;
	&lt;when-type-assignable class="org.metawidget.example.shared.addressbook.model.Contact"/&gt;
&lt;/generate-with&gt;</programlisting>
	
					<para>
						...and in the application code...
					</para>
						
					<programlisting language="java">metawidget.addWidgetProcessor( new SimpleBindingProcessor(
new SimpleBindingProcessorConfig().setAdapter( Contact.class,
	(SimpleBindingProcessorAdapter&lt;Contact&gt;) GWT.create(Contact.class)));</programlisting>
	
					<important>
						<title>ClassCastException</title>
						If this line throws a <classname>ClassCastException</classname> casting to <classname>SimpleBindingProcessorAdapter</classname>,
						it means GWT is not applying the <classname>SimpleBindingProcessorAdapterGenerator</classname>. Check you've
						specified the correct class in your <parameter>generate-with</parameter> block.
					</important>						
						
					<para>
						Updates to the UI can be saved back to the <function>setToInspect</function> by calling <function>save</function>:
					</para>

					<programlisting language="java">myMetawidget.getWidgetProcessor( SimpleBindingProcessor.class ).save( myMetawidget )</programlisting>
					
					<para>
						After <classname>Widget</classname>s have been generated for the initial <function>setToInspect</function>, clients
						can update their values to a new Object without a full re-inspection by using <function>rebind</function>: 
					</para>
					
					<programlisting language="java">myMetawidget.getWidgetProcessor( SimpleBindingProcessor.class ).rebind( newObject, myMetawidget )</programlisting>
					
					<para>
						For more details, see <xref linkend="section-performance-rebind"/>.
					</para>
				</section>
					
				<section id="section-widgetprocessors-web-gwt-actionbinding">
					<title>Action Binding</title>
						
					<para>
						GWT supplies <classname>com.google.gwt.user.client.ui.ClickListener</classname> for binding <classname>Buttons</classname> to backing
						classes. It is futher possible to combine this with a generator to support runtime binding. This is exactly what
						the default action binding, <classname>SimpleBindingProcessor</classname>, does.
					</para>
						
					<para>
						However, Metawidget makes action bindings pluggable to support other use cases. In particular, use cases where there
						<emphasis>is</emphasis> no backing class, and instead the <classname>Button</classname> should invoke, say, an RPC
						call. Implement your own pluggable binding by implementing <classname>WidgetProcessor</classname> and use it by calling...
					</para>
						
					<programlisting language="java">myMetawidget.addWidgetProcessor( new MyWidgetProcessor() );</programlisting>
						
				</section>				
			
			</section>
			
			<section id="section-widgetprocessors-web-faces">
				<title>JSF Widget Processors</title>
			
				<section id="section-widgetprocessors-web-faces-hidden">
					<title>HiddenFieldProcessor</title>
					
				</section>

				<section id="section-widgetprocessors-web-faces-validation">
					<title>StandardValidationProcessor</title>
					
					<para>
						By default, <classname>UIMetawidget</classname> uses <classname>StandardValidator</classname>, which adds <parameter>required</parameter>,
						<classname>RangeValidator</classname> and <classname>LengthValidator</classname> to all widgets.
					</para>
					
					<para>
						You can implement your own validators by extending <classname>org.metawidget.faces.component.validator.Validator</classname>, or
						disable validation by setting <parameter>validatorClass=""</parameter>.
					</para>
					
				</section>
				
				<section id="section-widgetprocessors-web-faces-richfaces">
					<title>RichFacesProcessor</title>
					
				</section>

			</section>
			
		</section>
		
	</chapter>
	
	<chapter id="chapter-layouts">
		<title>Layouts</title>
		
		<para>
			This chapter covers each <classname>Layout</classname> in detail. For an explanation of
			how <classname>Layout</classname>s fit into the overall architecture of Metawidget, see
			<xref linkend="chapter-architecture"/>.
		</para>
		
		<section id="section-layouts-desktop">
			<title>Desktop Layouts</title>

			<section id="section-layouts-desktop-swing">
				<title>Swing Layouts</title>

				<section id="section-layouts-desktop-swing-box">
					<title>BoxLayout</title>
					
					<para>
						<classname>Layout</classname> to simply output components one after another, with no labels and no structure, using
 						<classname>javax.swing.BoxLayout</classname>. This is like <classname>FlowLayout</classname> (below), except it fills width.
 						It can be useful for <classname>JTable</classname> <classname>CellEditor</classname>s.										
					</para>

				</section>				

				<section id="section-layouts-desktop-swing-flow">
					<title>FlowLayout</title>
					
					<para>
						<classname>Layout</classname> to simply output components one after another, with no labels and no structure,
 						using <classname>javax.awt.FlowLayout</classname>. This is like <classname>BoxLayout</classname>, except it does not fill width.
 						It can be useful for button bars. 								
					</para>

				</section>				

				<section id="section-layouts-desktop-swing-gridbag">
					<title>GridBagLayout</title>
					
					<para>
						<classname>Layout</classname> to arrange widgets using <classname>javax.awt.GridBagLayout</classname>. Widgets are arranged in a table,
						with one column for labels and another for the widget.
						This <classname>Layout</classname> recognizes the following parameters, configured
						using <classname>GridBagLayoutConfig</classname>:											
					</para>
					
					<informaltable>
						<colgroup>
							<col width="30%"/>
							<col width="70%"/>
						</colgroup>
						<thead>
							<tr>
								<th align="left">Property</th>
								<th align="left">Description</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td><parameter>labelAlignment</parameter></td>
								<td>Such as <classname>SwingConstants.LEFT</classname> or <classname>SwingConstants.RIGHT</classname></td>
							</tr>
							<tr>
								<td><parameter>labelFont</parameter></td>
								<td>Label font</td>
							</tr>
							<tr>
								<td><parameter>labelForeground</parameter></td>
								<td>Label foreground color</td>
							</tr>
							<tr>
								<td><parameter>labelSuffix</parameter></td>
								<td>Text to display after label text. Defaults to a colon (:)</td>
							</tr>
							<tr>
								<td><parameter>numberOfColumns</parameter></td>
								<td>number of columns. Each label/component pair is considered one column</td>
							</tr>
							<tr>
								<td><parameter>requiredAlignment</parameter></td>
								<td>Such as <classname>SwingConstants.LEFT</classname> or <classname>SwingConstants.RIGHT</classname></td>
							</tr>
							<tr>
								<td><parameter>requiredText</parameter></td>
								<td>Text to display for required fields. Defaults to a star (*)</td>
							</tr>
						</tbody>						
					</informaltable>					
				</section>
				
				<section id="section-layouts-desktop-swing-group">
					<title>GroupLayout</title>
					
					<para>
						<classname>Layout</classname> to arrange widgets using <classname>javax.swing.GroupLayout</classname>.
						Widgets are arranged in a table, with one column for labels and another for the widget.										
					</para>
					
				</section>

				<section id="section-layouts-desktop-swing-mig">
					<title>MigLayout</title>
					
					<para>
						<classname>Layout</classname> to arrange widgets using <classname>net.miginfocom.swing.MigLayout</classname>. Widgets are arranged in a table,
						with one column for labels and another for the widget.
						This <classname>Layout</classname> recognizes the following parameters, configured
						using <classname>MigLayoutConfig</classname>:											
					</para>
					
					<informaltable>
						<colgroup>
							<col width="30%"/>
							<col width="70%"/>
						</colgroup>
						<thead>
							<tr>
								<th align="left">Property</th>
								<th align="left">Description</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td><parameter>numberOfColumns</parameter></td>
								<td>number of columns. Each label/component pair is considered one column</td>
							</tr>
						</tbody>						
					</informaltable>					
				</section>				

				<section id="section-layouts-desktop-swing-separator">
					<title>SeparatorLayoutDecorator</title>
					
					<para>
						<classname>LayoutDecorator</classname> to decorate widgets from different sections using a <classname>JSeparator</classname>. This
						<classname>LayoutDecorator</classname> recognizes the following parameters, configured
						using <classname>SeparatorLayoutDecoratorConfig</classname>:						
					</para>
					
					<informaltable>
						<colgroup>
							<col width="30%"/>
							<col width="70%"/>
						</colgroup>
						<thead>
							<tr>
								<th align="left">Property</th>
								<th align="left">Description</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td><parameter>alignment</parameter></td>
								<td>
									One of <classname>SwingConstants.LEFT</classname> or <classname>SwingConstants.RIGHT</classname>.
								</td>
							</tr>
							<tr>
								<td><parameter>layout</parameter></td>
								<td>
									Metawidget <classname>Layout</classname> to use for laying out the sections,
									for example <classname>org.metawidget.swing.layout.GridBagLayout</classname>.
								</td>
							</tr>
						</tbody>						
					</informaltable>					
					
				</section>

				<section id="section-layouts-desktop-swing-tabbedpane">
					<title>TabbedPaneLayoutDecorator</title>
					
					<para>
						<classname>LayoutDecorator</classname> to decorate widgets from different sections using a <classname>JTabbedPane</classname>. This
						<classname>LayoutDecorator</classname> recognizes the following parameters, configured
						using <classname>TabbedPaneLayoutDecoratorConfig</classname>:						
					</para>
					
					<informaltable>
						<colgroup>
							<col width="30%"/>
							<col width="70%"/>
						</colgroup>
						<thead>
							<tr>
								<th align="left">Property</th>
								<th align="left">Description</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td><parameter>layout</parameter></td>
								<td>
									Metawidget <classname>Layout</classname> to use for laying out the sections,
									for example <classname>org.metawidget.swing.layout.GridBagLayout</classname>.
								</td>
							</tr>
							<tr>
								<td><parameter>tabAlignment</parameter></td>
								<td>
									One of <classname>SwingConstants.TOP</classname>, <classname>SwingConstants.BOTTOM</classname>,
									<classname>SwingConstants.LEFT</classname> or <classname>SwingConstants.RIGHT</classname>
									as defined by <classname>JTabbedPane.setTabAlignment</classname>.
								</td>
							</tr>
						</tbody>						
					</informaltable>					
				</section>

				<section id="section-layouts-desktop-swing-titledpanel">
					<title>TitledPanelLayoutDecorator</title>
					
					<para>
						<classname>LayoutDecorator</classname> to decorate widgets from different sections using a <classname>JPanel</classname> with
						a <classname>TitledBorder</classname>. This	<classname>LayoutDecorator</classname> recognizes the following parameters, configured
						using <classname>LayoutDecoratorConfig</classname>:						
					</para>
					
					<informaltable>
						<colgroup>
							<col width="30%"/>
							<col width="70%"/>
						</colgroup>
						<thead>
							<tr>
								<th align="left">Property</th>
								<th align="left">Description</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td><parameter>layout</parameter></td>
								<td>
									Metawidget <classname>Layout</classname> to use for laying out the sections,
									for example <classname>org.metawidget.swing.layout.GridBagLayout</classname>.
								</td>
							</tr>
						</tbody>						
					</informaltable>					
				</section>

			</section>
			
		</section>

		<section id="section-layouts-web">
			<title>Web Layouts</title>

			<section id="section-layouts-web-gwt">
				<title>GWT Layouts</title>
				
				<section id="section-layouts-web-gwt-flextable">
					<title>FlexTableLayout</title>
					
					<para>
						<classname>Layout</classname> to arrange widgets in a table, with one column for labels and another for the widget.					
						This <classname>Layout</classname> recognizes the following parameters, configured
						using <classname>FlexTableLayoutConfig</classname>:
					</para>
					
					<informaltable>
						<colgroup>
							<col width="30%"/>
							<col width="70%"/>
						</colgroup>
						<thead>
							<tr>
								<th align="left">Property</th>
								<th align="left">Description</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td><parameter>columnStyleNames</parameter></td>
								<td>comma delimited string of CSS style classes to apply to table columns in order of: label, component, required</td>
							</tr>
							<tr>
								<td><parameter>footerStyleName</parameter></td>
								<td>CSS style class to apply to table footer</td>
							</tr>
							<tr>
								<td><parameter>numberOfColumns</parameter></td>
								<td>number of columns. Each label/component pair is considered one column</td>
							</tr>
							<tr>
								<td><parameter>tableStyleName</parameter></td>
								<td>CSS style class to apply to outer table tag</td>
							</tr>
						</tbody>						
					</informaltable>
				</section>
				
				<section id="section-layouts-web-gwt-flow">
					<title>FlowLayout</title>
				
					<para>
						<classname>Layout</classname> to simply output components one after another, with no labels and no structure. This
						<classname>Layout</classname> is suited to rendering single components, or for rendering components whose
 						layout relies entirely on CSS.
					</para>
				</section>
				
				<section id="section-layouts-web-gwt-labeldecorator">
					<title>LabelLayoutDecorator</title>
					
					<para>
						<classname>LayoutDecorator</classname> to decorate widgets from different sections using a <classname>Label</classname>.
						This <classname>Layout</classname> recognizes the following parameters, configured
						using <classname>LabelLayoutDecoratorConfig</classname>:
					</para>
					
					<informaltable>
						<colgroup>
							<col width="30%"/>
							<col width="70%"/>
						</colgroup>
						<thead>
							<tr>
								<th align="left">Property</th>
								<th align="left">Description</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td><parameter>styleName</parameter></td>
								<td>CSS style class to apply to section label</td>
							</tr>
						</tbody>						
					</informaltable>
				</section>
				
				<section id="section-layouts-web-gwt-tabpaneldecorator">
					<title>TabPanelLayoutDecorator</title>
					
					<para>
						<classname>LayoutDecorator</classname> to decorate widgets from different sections using a
						<classname>TabPanel</classname>.
					</para>
				</section>

			</section>

			<section id="section-layouts-web-faces">
				<title>JSF Layouts</title>
				
				<para>
					<classname>Layout</classname>s in JSF behave a little differently to those for other Metawidgets. By and
					large, JSF already provides a pluggable mechanism (<classname>javax.faces.render.Renderer</classname>s)
					that can be used for displaying a component in different ways. Metawidget leverages this mechanism
					via its <classname>xxxLayoutRenderer</classname> classes (see below).
				</para>
				
				<para>
					However, JSF <classname>Renderer</classname>s are not supposed to <emphasis>modify</emphasis>
					the component tree (say, to wrap a group of components into a tabbed panel). For those cases,
					Metawidget employs its usual <classname>Layout</classname> mechanism. <classname>Layout</classname>s
					are executed at component-building-time, which is before <classname>Renderer</classname>-time
					so can safely modify the component tree.
				</para>
				
				<para>
					Separating <classname>xxxLayout</classname>
					and <classname>xxxLayoutRenderer</classname> classes in this way has the added advantage they
					can be mix-and-matched. For example, you can combine a <classname>RichFacesLayout</classname> (for
					wrapping components in tabs) with either a <classname>HtmlTableLayoutRenderer</classname> (to render
					the inside of the tabs as a table) or a <classname>HtmlDivLayoutRenderer</classname> (to render
					the inside of the tabs using <parameter>div</parameter>s).
				</para>
				
				<section id="section-layouts-web-faces-table">
					<title>HtmlDivLayoutRenderer</title>
					
					<para>
						<classname>Layout</classname> to arrange widgets in HTML <parameter>DIV</parameter> tags, with one <parameter>DIV</parameter> per label and
						per widget, and an outer <parameter>DIV</parameter> around both.
						This <classname>Layout</classname> recognizes the following parameters (passed either as
						<parameter>&lt;f:param&gt;</parameter> tags or set via &lt;parameter&gt; in
						<filename>metawidget.xml</filename>):
					</para>
					
					<informaltable>
						<colgroup>
							<col width="30%"/>
							<col width="70%"/>
						</colgroup>
						<thead>
							<tr>
								<th align="left">Parameter</th>
								<th align="left">Description</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td><parameter>componentStyle</parameter></td>
								<td>
									CSS styles to apply to the component DIV. This is the style applied to the DIV <emphasis>around</emphasis> the
 									component, not to the component itself. The widget component can be styled using the <parameter>style</parameter>
 									attribute on the Metawidget tag
 								</td>
							</tr>
							<tr>
								<td><parameter>divStyleClasses</parameter></td>
								<td>comma separated list of style classes to apply to the DIVs, in order of outer, label, required, component, errors</td>
							</tr>
							<tr>
								<td><parameter>inlineMessages</parameter></td>
								<td>whether to wrap input components with inline <classname>h:message</classname> tags. True by default</td>
							</tr>
							<tr>
								<td><parameter>labelStyle</parameter></td>
								<td>CSS styles to apply to the label DIV</td>
							</tr>
							<tr>
								<td><parameter>outerStyle</parameter></td>
								<td>CSS styles to apply to the outer DIV</td>
							</tr>
							<tr>
								<td><parameter>requiredStyle</parameter></td>
								<td>CSS styles to apply to the required DIV</td>
							</tr>
						</tbody>						
					</informaltable>

				</section>

				<section id="section-layouts-web-faces-div">
					<title>HtmlTableLayoutRenderer</title>
					
					<para>
						<classname>Layout</classname> to arrange components in a table, with one column for labels and another for the
 						component.					
						This <classname>Layout</classname> recognizes the following parameters (passed either as
						<parameter>&lt;f:param&gt;</parameter> tags or set via &lt;parameter&gt; in
						<filename>metawidget.xml</filename>):
					</para>
					
					<informaltable>
						<colgroup>
							<col width="30%"/>
							<col width="70%"/>
						</colgroup>
						<thead>
							<tr>
								<th align="left">Parameter</th>
								<th align="left">Description</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td><parameter>columns</parameter></td>
								<td>number of columns. Each label/component pair is considered one column</td>
							</tr>
							<tr>
								<td><parameter>columnClasses</parameter></td>
								<td>comma delimited string of CSS style classes to apply to table columns in order of: label, component, required</td>
							</tr>
							<tr>
								<td><parameter>componentStyle</parameter></td>
								<td>CSS styles to apply to required column</td>
							</tr>
							<tr>
								<td><parameter>footerStyle</parameter></td>
								<td>CSS styles to apply to table footer</td>
							</tr>
							<tr>
								<td><parameter>footerStyleClass</parameter></td>
								<td>CSS style class to apply to table footer</td>
							</tr>
							<tr>
								<td><parameter>headerStyle</parameter></td>
								<td>CSS styles to apply to table header</td>
							</tr>
							<tr>
								<td><parameter>headerStyleClass</parameter></td>
								<td>CSS style class to apply to table header</td>
							</tr>
							<tr>
								<td><parameter>inlineMessages</parameter></td>
								<td>whether to wrap input components with inline <classname>h:message</classname> tags. True by default</td>
							</tr>
							<tr>
								<td><parameter>labelStyle</parameter></td>
								<td>CSS styles to apply to label column</td>
							</tr>
							<tr>
								<td><parameter>labelSuffix</parameter></td>
								<td>suffix to put after the label name. Defaults to a colon (ie. 'Name:')</td>
							</tr>
							<tr>
								<td><parameter>requiredStyle</parameter></td>
								<td>CSS styles to apply to required column (ie. the star)</td>
							</tr>
							<tr>
								<td><parameter>rowClasses</parameter></td>
								<td>comma delimited string of CSS style classes to apply to alternating table rows</td>
							</tr>
							<tr>
								<td><parameter>tableStyle</parameter></td>
								<td>CSS styles to apply to outer table tag</td>
							</tr>
							<tr>
								<td><parameter>tableStyleClass</parameter></td>
								<td>CSS style class to apply to outer table tag</td>
							</tr>
						</tbody>						
					</informaltable>
					
				</section>

				<section id="section-layouts-web-faces-outputtext">
					<title>OutputTextLayoutDecorator</title>

					<para>
						<classname>LayoutDecorator</classname> to decorate widgets from different sections using an <classname>HtmlOutputText</classname>.
						As dictated by the JSF spec, CSS styles and style classes applied to an <classname>HtmlOutputText</classname> are
						wrapped in an HTML <parameter>span</parameter> tag. Therefore you must use CSS...
					</para>
					
					<programlisting language="css">display: block</programlisting>
					
					<para>
						...if you want to use margins or padding around the <classname>HtmlOutputText</classname>.						
					</para>
					
					<para>
						This <classname>LayoutDecorator</classname> recognizes the following parameters, configured
						using <classname>OutputTextLayoutDecoratorConfig</classname>:
					</para>
					
					<informaltable>
						<colgroup>
							<col width="30%"/>
							<col width="70%"/>
						</colgroup>
						<thead>
							<tr>
								<th align="left">Property</th>
								<th align="left">Description</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td><parameter>style</parameter></td>
								<td>CSS styles to apply to <classname>HtmlOutputText</classname></td>
							</tr>
							<tr>
								<td><parameter>styleClass</parameter></td>
								<td>CSS style class to apply to <classname>HtmlOutputText</classname></td>
							</tr>
						</tbody>						
					</informaltable>
				</section>

				<section id="section-layouts-web-faces-richfaces-panel">
					<title>PanelLayoutDecorator</title>

					<para>
						<classname>LayoutDecorator</classname> to decorate widgets from different sections using a RichFaces Panel. This
						<classname>LayoutDecorator</classname> recognizes the following parameters, configured
						using <classname>PanelLayoutDecoratorConfig</classname>:
					</para>
					
					<informaltable>
						<colgroup>
							<col width="30%"/>
							<col width="70%"/>
						</colgroup>
						<thead>
							<tr>
								<th align="left">Property</th>
								<th align="left">Description</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td><parameter>style</parameter></td>
								<td>CSS styles to apply to the panel</td>
							</tr>
							<tr>
								<td><parameter>styleClass</parameter></td>
								<td>CSS style class to apply to the panel</td>
							</tr>
						</tbody>						
					</informaltable>
				</section>

				<section id="section-layouts-web-faces-richfaces-simpletogglepanel">
					<title>SimpleTogglePanelLayoutDecorator</title>

					<para>
						<classname>LayoutDecorator</classname> to decorate widgets from different sections using a RichFaces SimpleTogglePanel.
						This <classname>LayoutDecorator</classname>
						recognizes the following parameters, configured
						using <classname>SimpleTogglePanelLayoutDecoratorConfig</classname>:
					</para>
					
					<informaltable>
						<colgroup>
							<col width="30%"/>
							<col width="70%"/>
						</colgroup>
						<thead>
							<tr>
								<th align="left">Property</th>
								<th align="left">Description</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td><parameter>style</parameter></td>
								<td>CSS styles to apply to the panel</td>
							</tr>
							<tr>
								<td><parameter>styleClass</parameter></td>
								<td>CSS style class to apply to the panel</td>
							</tr>
							<tr>
								<td><parameter>switchType</parameter></td>
								<td>Mechanism to use to open/close panels. Either 'client' or 'ajax'. Default is 'client'</td>
							</tr>
							<tr>
								<td><parameter>opened</parameter></td>
								<td>whether the panel is initially opened. Defaults to true</td>
							</tr>
						</tbody>						
					</informaltable>
				</section>

				<section id="section-layouts-web-faces-simple">
					<title>SimpleLayout</title>
					
					<para>
						<classname>SimpleLayout</classname> is the default JSF <classname>Layout</classname>. It simply adds
						the widget as a child of the Metawidget, leaving everything up to the <classname>Renderer</classname>.
					</para>
				</section>
				
				<section id="section-layouts-web-faces-richfaces-tabpanel">
					<title>TabPanelLayoutDecorator</title>

					<para>
						<classname>LayoutDecorator</classname> to decorate widgets from different sections using a RichFaces
						TabPanel. This <classname>LayoutDecorator</classname>
						recognizes the following parameters, configured
						using <classname>TabPanelLayoutDecoratorConfig</classname>:
					</para>
					
					<informaltable>
						<colgroup>
							<col width="30%"/>
							<col width="70%"/>
						</colgroup>
						<thead>
							<tr>
								<th align="left">Property</th>
								<th align="left">Description</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td><parameter>headerAlignment</parameter></td>
								<td>Defaults to 'left'</td>
							</tr>
						</tbody>						
					</informaltable>
				</section>				

			</section>

			<section id="section-layouts-web-jsp">
				<title>JSP Layouts</title>
				
				<para>
					All of the supported JSP-based technologies (ie. 'pure' JSP, Spring and Struts) share the same
					<classname>Layout</classname>s.
				</para>
				
				<section id="section-layouts-web-jsp-headingtaglayoutdecorator">
					<title>HeadingTagLayoutDecorator</title>

					<para>
						<classname>LayoutDecorator</classname> to decorate widgets from different sections using
						an HTML heading tag (ie. <parameter>H1</parameter>, <parameter>H2</parameter> etc).
						This <classname>LayoutDecorator</classname> recognizes the following parameters, configured
						using <classname>HeadingTagLayoutDecoratorConfig</classname>:				
					</para>
					
					<informaltable>
						<colgroup>
							<col width="30%"/>
							<col width="70%"/>
						</colgroup>
						<thead>
							<tr>
								<th align="left">Property</th>
								<th align="left">Description</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td><parameter>style</parameter></td>
								<td>CSS styles to apply to heading tag</td>
							</tr>
							<tr>
								<td><parameter>styleClass</parameter></td>
								<td>CSS style class to apply to heading tag</td>
							</tr>
						</tbody>						
					</informaltable>
				</section>
				
				<section id="section-layouts-web-jsp-htmltable">
					<title>HtmlTableLayout</title>
					
					<para>
						<classname>Layout</classname> to arrange widgets in a table, with one column for labels and another for the widget.					
						This <classname>Layout</classname> recognizes the following parameters, configured
						using <classname>HtmlTableLayoutConfig</classname>:
					</para>
					
					<informaltable>
						<colgroup>
							<col width="30%"/>
							<col width="70%"/>
						</colgroup>
						<thead>
							<tr>
								<th align="left">Property</th>
								<th align="left">Description</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td><parameter>columnStyleClasses</parameter></td>
								<td>comma delimited string of CSS style classes to apply to table columns in order of: label, component, required</td>
							</tr>
							<tr>
								<td><parameter>footerStyle</parameter></td>
								<td>CSS styles to apply to table footer</td>
							</tr>
							<tr>
								<td><parameter>footerStyleClass</parameter></td>
								<td>CSS style class to apply to table footer</td>
							</tr>
							<tr>
								<td><parameter>numberOfColumns</parameter></td>
								<td>number of columns. Each label/component pair is considered one column</td>
							</tr>
							<tr>
								<td><parameter>tableStyle</parameter></td>
								<td>CSS styles to apply to outer table tag</td>
							</tr>
							<tr>
								<td><parameter>tableStyleClass</parameter></td>
								<td>CSS style class to apply to outer table tag</td>
							</tr>
						</tbody>						
					</informaltable>
				</section>
				
				<section id="section-layouts-web-jsp-simple">
					<title>SimpleLayout</title>
				
					<para>
						<classname>Layout</classname> to simply output components one after another, with no labels and no structure. This
						<classname>Layout</classname> is suited to rendering single components, or for rendering components whose
 						layout relies entirely on CSS.
					</para>
				</section>

			</section>
			
		</section>
		
		<section id="section-layouts-mobile">
			<title>Mobile Layouts</title>

			<section id="section-layouts-mobile-android">
				<title>Android Layouts</title>
				
				<section id="section-layouts-web-android-linear">
					<title>LinearLayout</title>
					
					<para>
						<classname>Layout</classname> to arrange widgets vertically, using <classname>android.widget.LinearLayout</classname>.
						This <classname>Layout</classname> recognizes the following parameters, configured
						using <classname>LinearLayoutConfig</classname>:						
					</para>
					
					<informaltable>
						<colgroup>
							<col width="30%"/>
							<col width="70%"/>
						</colgroup>
						<thead>
							<tr>
								<th align="left">Property</th>
								<th align="left">Description</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td><parameter>labelStyle</parameter></td>
								<td>
									Android style (ie. <parameter>@com.myapp:style/label</parameter>) to apply to labels. The
									style should be defined within <filename>res/values/styles.xml</filename>. For example:
									<programlisting language="xml">&lt;style name="section"&gt;
	&lt;item name="android:textSize"&gt;20sp&lt;/item&gt;
	&lt;item name="android:paddingTop"&gt;10px&lt;/item&gt;
	&lt;item name="android:paddingBottom"&gt;5px&lt;/item&gt;
&lt;/style&gt;</programlisting>
								</td>
							</tr>
						</tbody>						
					</informaltable>
					
				</section>				
				
				<section id="section-layouts-web-android-table">
					<title>TableLayout</title>
					
					<para>
						<classname>Layout</classname> to arrange widgets in a table, with one column for labels and another for the widget,
						using <classname>android.widget.TableLayout</classname>.
						This <classname>Layout</classname> recognizes the following parameters, configured
						using <classname>TableLayoutConfig</classname>:						
					</para>
					
					<informaltable>
						<colgroup>
							<col width="30%"/>
							<col width="70%"/>
						</colgroup>
						<thead>
							<tr>
								<th align="left">Property</th>
								<th align="left">Description</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td><parameter>labelStyle</parameter></td>
								<td>
									Android style (ie. <parameter>@com.myapp:style/label</parameter>) to apply to labels. The
									style should be defined within <filename>res/values/styles.xml</filename>. For example:
									<programlisting language="xml">&lt;style name="label"&gt;
	&lt;item name="android:textSize"&gt;20sp&lt;/item&gt;
	&lt;item name="android:paddingTop"&gt;10px&lt;/item&gt;
	&lt;item name="android:paddingBottom"&gt;5px&lt;/item&gt;
&lt;/style&gt;</programlisting>
								</td>
							</tr>
						</tbody>						
					</informaltable>
					
				</section>
				
				<section id="section-layouts-web-android-tab">
					<title>TabHostLayoutDecorator</title>

					<para>
						<classname>LayoutDecorator</classname> to wrap widgets in different sections inside a <classname>TabHost</classname>,
						as in <xref linkend="section-layouts-web-android-tab-screenshot"/>.
					</para>
					
					<figure id="section-layouts-web-android-tab-screenshot">
						<title>TabHostLayoutDecorator</title>
						<screenshot>
							<graphic fileref="images/screenshots/mobile-tabsection.jpg" width="60mm" />
						</screenshot>
					</figure>
				
					<para>
						This <classname>LayoutDecorator</classname> recognizes the following parameters, configured
						using <classname>LayoutDecoratorConfig</classname>:						
					</para>
					
					<informaltable>
						<colgroup>
							<col width="30%"/>
							<col width="70%"/>
						</colgroup>
						<thead>
							<tr>
								<th align="left">Property</th>
								<th align="left">Description</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td><parameter>layout</parameter></td>
								<td>
									Metawidget <classname>Layout</classname> to use for laying out the inside of the tabs,
									for example <classname>org.metawidget.android.widget.layout.TableLayout</classname>.
								</td>
							</tr>
						</tbody>						
					</informaltable>
				</section>

				<section id="section-layouts-web-android-heading">
					<title>TextViewLayoutDecorator</title>

					<para>
						<classname>LayoutDecorator</classname> to decorate widgets from different sections using a <classname>TextView</classname>. This
						<classname>LayoutDecorator</classname> recognizes the following parameters, configured
						using <classname>TextViewLayoutDecoratorConfig</classname>:						
					</para>
					
					<informaltable>
						<colgroup>
							<col width="30%"/>
							<col width="70%"/>
						</colgroup>
						<thead>
							<tr>
								<th align="left">Property</th>
								<th align="left">Description</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td><parameter>layout</parameter></td>
								<td>
									Metawidget <classname>Layout</classname> to use for laying out the sections,
									for example <classname>org.metawidget.android.widget.layout.TableLayout</classname>.
								</td>
							</tr>
							<tr>
								<td><parameter>style</parameter></td>
								<td>Android style (ie. <parameter>@com.myapp:style/section</parameter>) to apply to section breaks</td>
							</tr>
						</tbody>						
					</informaltable>
				</section>

			</section>
		</section>
		
	</chapter>

	<chapter id="chapter-howto">
		<title>How To's</title>
		
		<para>
			This section contains 'How To's' (or 'Recipes') for various scenarios you may encounter when using Metawidget.
		</para>
		
		<section id="section-howto-order">
			<title>Order Fields</title>
			
			<para>
				Metawidget supports several ways to control the order of fields in the UI, depending on your architecture and your
				preference:
			</para>
			
			<itemizedlist>
				<listitem>
					<para>
						Annotate the fields with <classname>@UiComesAfter</classname> and use <classname>MetawidgetAnnotationInspector</classname>
						as the first inspector in your <classname>CompositeInspector</classname> chain.
					</para>
				</listitem>
				<listitem>
					<para>
						Use one of the XML-based inspectors (such as <classname>XmlInspector</classname> or <classname>HibernateInspector</classname>)
						as the first inspector in your <classname>CompositeInspector</classname> chain. XML nodes are inherently ordered.
					</para>
				</listitem>
				<listitem>
					<para>
						Compile your business model with debug information turned on, and use <classname>JavassistPropertyStyle</classname>. This
						approach uses Javassist to extract line numbering information, and order the fields in source file order.
					</para>
				</listitem>
				<listitem>
					<para>
						Write your own <classname>Inspector</classname>. 
					</para>
				</listitem>
				<listitem>
					<para>
						Write your own <classname>PropertyStyle</classname>. For example, <classname>JavassistPropertyStyle</classname> extends
						<classname>JavaBeanPropertyStyle</classname> and reorders the fields using debug information.
					</para>
				</listitem>
			</itemizedlist>
			
		</section>

		<section id="section-howto-remote">
			<title>Remote Inspection</title>
			
			<para>
				Metawidget inspects back-end metadata and creates front-end UI widgets. If your application is split over multiple
				tiers, however, sometimes the back-end metadata is not accessible from the front-end. For example, annotations
				(such as JPA ones) are designed to 'fall away' if the class is transferred to a tier without JPA in its classpath.
				Equally, configuration files may not be accessible across tiers.
			</para>
			
			<para>
				Metawidget supports these situations. Because each remoting environment is different, however, you will
				need to add a little code yourself. Every inspector returns an XML string, which is inherently serializable and safe
				to pass across tiers. Therefore, to run inspection remotely:
			</para>
			
			<itemizedlist>
				<listitem>
					<para>
						create a back-end class suited to your environment, such as an EJB Session Bean. Have the back-end class instantiate
						an inspector - either programmatically:
					</para>
					
					<programlisting language="java">XmlInspectorConfig config = new XmlInspectorConfig();
config.setInputStream( getClass().getResourceAsStream( "metawidget-backend-metadata.xml" ));
Inspector inspector = new XmlInspector( config );</programlisting>

					<para>
						Or by using a <filename>metawidget.xml</filename> file and the <classname>ConfigReader</classname> helper class:
					</para>
					
					<programlisting language="java">inspector = ConfigReader.configure( "backend-metawidget.xml", Inspector.class );</programlisting>
				</listitem>
				<listitem>
					<para>
						have the back-end class declare the <classname>Inspector</classname> interface. Implement the interface by
						delegating to the inspector you just instantiated.
					</para>
				</listitem>
				<listitem>
					<para>
						depending on your environment, it may futher be necessary to create a front-end class (a proxy). Have it declare
						the <classname>Inspector</classname> interface. Implement the interface by remoting to the back-end class and
						returning the XML string.
					</para>
				</listitem>
				<listitem>
					<para>
						set the inspector on the Metawidget by using the <function>setInspector</function> method (rather than
						the <function>setConfig</function> method).
					</para>
				</listitem>
			</itemizedlist>
			
			<para>
				An example of this technique can be seen in <classname>GwtRemoteInspectorProxy</classname> and <classname>GwtRemoteInspectorImpl</classname>.
			</para>
			
			<tip>
				<title>Note</title>
				All inspectors are both thread-safe and immutable. Therefore you only need one inspector for your
				<emphasis>entire</emphasis> application. Some remoting architectures support 'singletons' or 'service beans' well suited
				to this.
			</tip>
						
		</section>
				
		<section id="section-howto-combine-remote">
			<title>Combine Remote Inspections</title>
			
			<para>
				If your architecture is strongly separated, some metadata may only be available in one tier (eg. JPA annotations
				in the back-end) and some only available in another tier (eg. <filename>struts-config.xml</filename> in the
				front-end).
			</para>
			
			<para>
				For this, <classname>CompositeInspector</classname> supplies an overloaded method outside the normal <classname>Inspector</classname>
				interface. The overloaded <function>CompositeInspector.inspect</function> method takes an additional XML string of inspection results,
				and merges forthcoming inspection results with it.
			</para>
			
			<para>
				Therefore, to combine metadata from different tiers:
			</para>
			
			<itemizedlist>
				<listitem>
					<para>
						create a front-end class that implements the <classname>Inspector</classname> interface
					</para>
				</listitem>
				<listitem>
					<para>
						implement the interface by first remoting to the back-end class and returning the XML string, as before
					</para>
				</listitem>
				<listitem>
					<para>
						next, delegate to a <classname>CompositeInspector</classname> to inspect the front-end, passing it the XML
						string from the back-end as a starting point
					</para>
				</listitem>
			</itemizedlist>			
		</section>

	</chapter>
	
	<chapter id="chapter-performance">
		<title>Performance</title>
		
		<para>
			Performance is very important to Metawidget. Whilst generating a UI dynamically - as opposed to hard coding it
			statically - is always likely to involve a performance tradeoff, Metawidget supports a number of techniques
			to help minimize this.
		</para>
		
		<section id="section-performance-jar">
			<title>JAR Size</title>

			<para>
				Metawidget has no mandatory third-party JAR dependencies and is highly modular. This
				allows the standard <filename>metawidget.jar</filename> to be repackaged for different environments to save JAR size.
			</para>
			
			<para>		
				For example, the <filename>example-swing-addressbook-applet</filename> Ant task	builds
				<filename>examples\swing\applet\addressbook\metawidget-applet.jar</filename>. This JAR includes only those
				classes (<classname>Inspectors</classname>, <classname>WidgetBuilders</classname> and so on) necessary for the
				Swing Address Book example applet (it is further compressed using <filename>pack200</filename>).
				Similarly, the <filename>example-android-addressbook</filename> Ant task includes only those classes necessary for
				the Android Address Book.
			</para>
			
		</section>

		<section id="section-performance-memory">
			<title>Memory Usage</title>
			
			<para>
				All <classname>Inspector</classname>s, <classname>InspectionResultProcessor</classname>s,
				<classname>WidgetBuilder</classname>s, <classname>WidgetProcessor</classname>s
				and <classname>Layout</classname>s are immutable. This means you only
				need a single instance of them for your entire application.
				If you are using <filename>metawidget.xml</filename> then <classname>ConfigReader</classname>
				takes care of this for you, but if you are instantiating them yourself in Java
				code you should reuse instances to save memory.
			</para>
			
		</section>
	
		<section id="section-performance-rebind">
			<title>Rebinding</title>
			
			<para>
				For Metawidgets that do not use automatic binding, the general approach is to call <function>setToInspect</function>
				and then <function>setValue</function> to populate the generated widgets with values. This technique has an implicit side
				effect: the values can also be <emphasis>re</emphasis>populated as many times as required from different objects, without re-calling
				<function>setToInspect</function>. This allows the Metawidget to be generated once and reused many times, mitigating the
				performance cost of generation.
			</para>
			
			<para>
				For Metawidgets that <emphasis>do</emphasis> use automatic binding, however, <function>setValue</function> is never used. Setting
				new values requires re-calling <parameter>setToInspect</parameter> (and re-running generation) for every different object. 
			</para>
			
			<para>
				To avoid this some <classname>WidgetProcessor</classname>s support a second, lightweight version of <function>setToInspect</function>
				called <function>rebind</function>. Using <function>rebind</function>, a <classname>WidgetProcessor</classname> can update the values in
				the generated widgets <emphasis>without</emphasis> re-running generation. This allows the Metawidget to be generated once and reused
				many times.
			</para>
			
			<para>
				The downside of <function>rebind</function> is that the rebound object must have exactly the same set of field names
				as the original object. It becomes the responsibility of the caller to ensure this consistency.
			</para>
			
			<para>
				For an example of using rebinding, see the GWT Address Book sample application.
			</para>
			
		</section>
	</chapter>
	
	<chapter id="chapter-epilogue">
		<title>Epilogue</title>
		
		<para>
			That concludes the Metawidget User Guide and Reference Documentation.
		</para>
		
		<para>
			For further documentation - including forums, bug reports, a Wiki community area
			and information on how to contribute - please visit <ulink url="http://www.metawidget.org">http://www.metawidget.org</ulink>.			
		</para>
		
		<para>
			Thank you for using Metawidget!
		</para>

	</chapter>

</book>
